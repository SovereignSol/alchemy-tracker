<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Field Notes</title>

  <style>
    * { box-sizing: border-box; }

    :root{
      --ink:#000000;

      /* Dark app theme */
      --app-bg-1:#0a1020;
      --app-bg-2:#05070d;
      --panel-bg: rgba(26, 30, 40, 0.72);
      --panel-border: rgba(120, 130, 155, 0.38);
      --scene-bg: rgba(22, 26, 36, 0.70);
      --scene-border: rgba(120, 130, 155, 0.34);

      --edge:#d9c8aa;
      --good:#1f7a3a;
      --warn:#8a5a00;
      --bad:#8b1d2c;
      --shadow: 0 16px 40px rgba(0,0,0,0.38);
      --shadow2: 0 10px 24px rgba(0,0,0,0.32);

      --base: 13px;
      --small: 12px;
      --h1: 18px;

      /* Book UI scale */
      --book-ui: 0.84;

      /* Book overlay placement */
      --book-top: 19.8%;
      --book-bottom: 10%;
      --book-left: 3.6%;
      --book-right: 15.5%;
      --book-gap: 2.4%;
      --book-pad: 8px;

      /* Width control inside pages */
      --page-content-width: 78%;
      --line-width: 78%;
      --right-box-width: 96%;

      /* Right page shift */
      --right-page-shift: 150px;

      /* Right-page note box width */
      --right-notebox-width: 84%;

      --brew-maxw: 1000px;

      /* Bag UI */
      --bag-maxw: 1040px;

      /* Trim/padding inside Backpack_UI.webp before placing tiles */
      --bag-trim: 34px;
      --bag-trim-mobile: 18px;

      /* Push bag items downward inside Backpack_UI.webp */
      --bag-top-offset: 70px;
    }

    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
    }

    body{
      color: #e9edf6;
      background:
        radial-gradient(1100px 640px at 12% 0%, rgba(90,120,255,0.10), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(0,255,200,0.06), transparent 60%),
        linear-gradient(180deg, var(--app-bg-1), var(--app-bg-2));
      font-family: "Segoe Print","Bradley Hand","Comic Sans MS",cursive,system-ui;
      letter-spacing: 0.12px;
      font-size: var(--base);
      line-height: 1.15;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -webkit-touch-callout: none;
    }

    .wrap{
      max-width: 1000px;
      margin: 0 auto;
      padding: 12px;
    }
    .hidden{ display:none !important; }

    button, input, select, textarea{
      font-size: var(--base);
      padding: 8px 9px;
      border-radius: 14px;
      border: 1px solid rgba(217,200,170,0.35);
      background: rgba(255,255,255,0.84);
      color: #000;
      outline: none;
      box-shadow: 0 2px 0 rgba(0,0,0,0.04) inset;
      font-family: inherit;
      line-height: 1.1;
      transition: all 120ms ease;
    }

    button:hover:not(:disabled){
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.12);
    }
    button:active:not(:disabled){
      transform: translateY(1px);
      box-shadow: 0 2px 0 rgba(0,0,0,0.04) inset;
    }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    input::placeholder, textarea::placeholder{
      color: rgba(0,0,0,0.45);
    }

    .btn-primary{
      background: linear-gradient(180deg, rgba(122,62,31,0.92), rgba(122,62,31,0.78));
      color: #fff7ee;
      border-color: rgba(122,62,31,0.45);
      box-shadow: 0 10px 22px rgba(0,0,0,0.28);
      font-weight: 900;
    }
    .btn-primary:hover:not(:disabled){
      box-shadow: 0 14px 28px rgba(0,0,0,0.32);
    }

    .btn-bad{
      background: linear-gradient(180deg, rgba(139,29,44,0.92), rgba(139,29,44,0.78));
      color: #fff7ee;
      border-color: rgba(139,29,44,0.45);
      box-shadow: 0 10px 22px rgba(0,0,0,0.28);
      font-weight: 900;
    }

    .btn-quiet{
      background: rgba(255,255,255,0.70);
      color: #000;
      font-weight: 900;
    }

    input:focus, select:focus, textarea:focus{
      border-color: rgba(122,62,31,0.6);
      box-shadow: 0 0 0 3px rgba(122,62,31,0.15) inset;
    }

    .muted{ color: rgba(233,237,246,0.78); font-size: var(--small); }

    .title{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
      flex-wrap: wrap;
    }
    h1{
      margin:0;
      font-size: var(--h1);
      line-height:1.05;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-weight: 900;
      color: #f2f6ff;
    }
    .sub{ margin-top:4px; color: rgba(233,237,246,0.78); font-size: var(--small); }

    /* Main screen */
    .main-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: stretch;
    }
    @media (min-width: 860px){
      .main-grid{ grid-template-columns: 1fr 1fr; }
    }
    .panel-below{
      margin-top: 12px;
    }

    .panel{
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      box-shadow: var(--shadow2);
      overflow:hidden;
      min-height: 220px;
      position: relative;
      transition: transform 200ms ease, box-shadow 200ms ease;
    }
    .panel:hover{
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }
    .panel button.overlayBtn{
      all: unset;
      cursor: pointer;
      display:block;
      width:100%;
      height:100%;
    }
    .panel img.coverArt{
      width:100%;
      height:100%;
      object-fit: contain;
      display:block;
      background: rgba(0,0,0,0.10);
      filter: saturate(1.02);
    }
    .panel .hint{
      position:absolute;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(20,22,30,0.88);
      box-shadow: 0 10px 20px rgba(0,0,0,0.32);
      font-weight: 900;
      color: #f2f6ff;
      font-size: var(--small);
      pointer-events: none;
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ opacity:0.8; }
      50%{ opacity:1; }
    }

    /* Scene wrapper */
    .scene{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: var(--scene-bg);
      box-shadow: var(--shadow2);
      overflow:hidden;
      position: relative;
    }

    .sceneTopBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,18,26,0.62);
      flex-wrap: wrap;
    }
    .topLeftBtns{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }

    .backBtn{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.72);
      box-shadow: 0 8px 16px rgba(0,0,0,0.32);
      font-weight: 900;
      color: #f2f6ff;
      font-size: var(--small);
      cursor: pointer;
    }
    .backBtn:hover{
      background: rgba(30,35,50,0.82);
      box-shadow: 0 10px 20px rgba(0,0,0,0.40);
    }
    .backBtn img{ width: 16px; height: 16px; opacity: 0.92; filter: brightness(1.2); }

    /* Book layout */
    .bookWrap{
      position: relative;
      width:100%;
      height: min(86vh, 800px);
      min-height: 560px;
      background: rgba(0,0,0,0.10);
    }
    .bookBg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: contain;
      opacity: 0.98;
      pointer-events:none;
      user-select:none;
      background: rgba(0,0,0,0.05);
    }

    .bookPages{
      position:absolute;
      top: var(--book-top);
      bottom: var(--book-bottom);
      left: var(--book-left);
      right: var(--book-right);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--book-gap);
      align-items: stretch;
      box-sizing: border-box;
      z-index: 2;

      transform: scale(var(--book-ui));
      transform-origin: top left;
      width: calc(100% / var(--book-ui));
      height: calc(100% / var(--book-ui));
    }

    /* Force all book text black */
    .bookPages, .bookPages *{
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }
    .bookPages .muted{
      opacity: 1 !important;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }

    @media (max-width: 760px){
      :root{
        --book-top: 21.5%;
        --book-bottom: 12%;
        --book-left: 4.5%;
        --book-right: 10%;
        --book-gap: 10px;
        --book-ui: 0.88;
        --page-content-width: 90%;
        --line-width: 90%;
        --right-box-width: 98%;
        --right-page-shift: 0px;
        --right-notebox-width: 96%;

        --bag-top-offset: 40px;
      }
      .bookWrap{
        height: auto;
        min-height: 920px;
      }
      .bookPages{
        grid-template-columns: 1fr;
        gap: 12px;
      }
    }

    /* Page alignment */
    .page{
      border-radius: 14px;
      padding: var(--book-pad);
      background: rgba(255,255,255,0.00);
      overflow: hidden;
      min-height: 0;
      display:flex;
      justify-content:flex-start;
      flex-direction: column;
      align-items: stretch;
    }
    .pageInner{
      height: 100%;
      overflow:auto;
      padding-right: 6px;
      width: var(--page-content-width);
      max-width: var(--page-content-width);
      margin-left: 0;
      margin-right: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(0,0,0,0.2) transparent;
    }
    .pageInner::-webkit-scrollbar{ width: 4px; }
    .pageInner::-webkit-scrollbar-track{ background: transparent; }
    .pageInner::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.2); border-radius: 2px; }

    /* Right page: shift left */
    .pageRight{
      justify-content: center;
      align-items: flex-start;
      overflow: visible;
    }
    .pageRight .pageInner{
      width: var(--right-box-width);
      max-width: var(--right-box-width);
      margin-left: 0;
      margin-right: auto;
      padding-right: 10px;
      transform: translateX(calc(-1 * var(--right-page-shift)));
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* Shrink ONLY the right-page note boxes */
    .pageRight .noteBox{
      width: var(--right-notebox-width);
      margin-left: 0;
      margin-right: auto;
    }

    .leftCentered{
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }

    .page h2{
      margin: 0 0 6px 0;
      font-size: 13.5px;
      font-weight: 950;
      width: 100%;
    }
    .page h3{
      margin: 10px 0 6px 0;
      font-size: 12px;
      font-weight: 950;
      width: 100%;
    }
    .hr{
      height:1px;
      background: rgba(0,0,0,0.35);
      margin: 9px auto;
      width: var(--line-width);
    }

    .bookPages button, .bookPages input, .bookPages select, .bookPages textarea{
      font-size: var(--small);
      padding: 7px 8px;
      border-radius: 12px;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }
    .bookPages textarea::placeholder,
    .bookPages input::placeholder{
      opacity: 0.55 !important;
      -webkit-text-fill-color: rgba(0,0,0,0.55) !important;
    }

    .bookPages .btn-quiet,
    .bookPages button.backBtn,
    .bookPages button.smallBtn,
    .bookPages button.qtyBtn,
    .bookPages button#revealRandomBtn,
    .bookPages button#resetRevealsBtn{
      background: rgba(255,255,255,0.20);
      box-shadow: none;
      border: 1px solid rgba(0,0,0,0.18);
    }

    /* Index rows */
    .indexRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items:center;
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      box-shadow: none;
      margin: 0 auto 6px auto;
      width: var(--line-width);
      transition: background 150ms ease;
    }
    .indexRow:hover{ background: rgba(0,0,0,0.04); }

    @media (max-width: 420px){
      .indexRow{ grid-template-columns: 1fr; width: 100%; }
      .inventoryBox{ justify-content:flex-start; }
      .hr{ width: 100%; }
    }

    .ingNameBtn{
      all: unset;
      cursor:pointer;
      font-weight: 950;
      padding: 2px 3px;
      font-size: 12.5px;
      transition: opacity 120ms ease;
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
      opacity: 0.85;
    }
    .ingNameBtn:hover{ opacity: 1; }

    .inventoryBox{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 4px;
      flex-wrap: nowrap;
    }
    .count{
      min-width: 28px;
      text-align:center;
      font-weight: 950;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      font-size: var(--small);
    }
    .qtyBtn{
      padding: 4px 6px;
      border-radius: 10px;
      font-weight: 950;
      min-width: 28px;
      background: rgba(255,255,255,0.00);
      box-shadow:none;
      border: 1px solid rgba(0,0,0,0.22);
      font-size: var(--small);
    }

    /* Ingredient page */
    .noteBox{
      border-radius: 12px;
      border: 1px dashed rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.18);
      padding: 8px 9px;
      font-size: var(--small);
      line-height: 1.2;
      white-space: pre-wrap;
      word-break: break-word;
      width: 100%;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
      max-height: 200px;
      overflow-y: auto;
    }

    .plantImg{
      width:100%;
      max-width: 250px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.12);
      box-shadow: none;
      display:block;
      margin: 0 auto;
    }

    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      font-size: var(--small);
      font-weight: 950;
      box-shadow:none;
    }
    .pill-rare{ border-color: rgba(31,122,58,0.40); }
    .pill-common{ border-color: rgba(122,62,31,0.40); }
    .pill-unknown{ border-color: rgba(0,0,0,0.22); }

    .effects{
      display:grid;
      gap: 7px;
      margin-top: 9px;
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }
    .effect-line{
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap: 6px;
      align-items: stretch;
    }
    .effect-text{
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px dashed rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.18);
      box-shadow: none;
      min-height: 16px;
      display:flex;
      align-items:center;
      font-size: var(--small);
      line-height: 1.15;
      word-break: break-word;
    }
    .effect-hidden{
      color: transparent !important;
      -webkit-text-fill-color: transparent !important;
      text-shadow: 0 0 10px rgba(0,0,0,0.55);
      user-select: none;
    }
    .smallBtn{
      padding: 4px 8px;
      font-size: var(--small);
      border-radius: 10px;
      font-weight: 950;
      background: rgba(255,255,255,0.00);
      box-shadow:none;
      border: 1px solid rgba(0,0,0,0.22);
      white-space: nowrap;
    }

    /* Brewing UI */
    .brewPage{
      max-width: var(--brew-maxw);
      margin: 0 auto;
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .brewImageFrame{
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid var(--scene-border);
      background: rgba(0,0,0,0.15);
      box-shadow: var(--shadow2);
    }
    .brewBgImg{
      width:100%;
      height: min(52vh, 520px);
      min-height: 300px;
      object-fit: contain;
      background: rgba(0,0,0,0.10);
      display:block;
    }
    .brewControls{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: rgba(18, 22, 30, 0.72);
      box-shadow: var(--shadow);
      padding: 12px;
      color:#f2f6ff;
    }
    .brewControls .muted{ color: rgba(233,237,246,0.78); }

    .brewTopRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .themeBtn{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.72);
      box-shadow: 0 8px 16px rgba(0,0,0,0.32);
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
      cursor: pointer;
    }
    .themeBtn:hover{
      background: rgba(30,35,50,0.82);
      box-shadow: 0 10px 20px rgba(0,0,0,0.40);
    }
    .themeBtn img{ width: 16px; height: 16px; opacity: 0.92; filter: brightness(1.2); }

    .brewGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 760px){
      .brewGrid{ grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    }
    .slotTitle{ font-weight: 950; margin-bottom: 6px; font-size: var(--small); color:#f2f6ff; }
    .slotBox{
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,0.20);
      background: rgba(255,255,255,0.06);
      padding: 10px;
    }
    .slotBox select{ width: 100%; }

    .discoveredList{
      margin-top: 8px;
      display:flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .discoveredPill{
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      padding: 4px 8px;
      background: rgba(255,255,255,0.10);
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
    }

    .resultBox{
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      padding: 10px;
      font-size: var(--small);
      line-height: 1.2;
      color: #f2f6ff;
      min-height: 40px;
      display:flex;
      align-items:center;
    }

    .brewBtnRow{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .brewBtnRow button{
      width: 100%;
      font-weight: 950;
    }

    /* Concentrate crafting controls on Brewing page */
    .concControls{
      display:flex;
      flex-direction: column;
      gap: 8px;
    }
    .concControls button{
      width: 100%;
      font-weight: 950;
      white-space: nowrap;
    }

    select{
      background: rgba(255,255,255,0.86);
      color:#000;
      border: 1px solid rgba(255,255,255,0.25);
    }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(20,22,30,0.95);
      border: 1px solid rgba(255,255,255,0.18);
      color: #f2f6ff;
      border-radius: 999px;
      padding: 9px 12px;
      box-shadow: var(--shadow);
      max-width: calc(100vw - 32px);
      display:none;
      z-index: 50;
      font-size: var(--small);
      font-weight: 950;
    }
    .toast.good{ border-color: rgba(31,122,58,0.40); }
    .toast.bad{ border-color: rgba(139,29,44,0.45); }

    /* Collapsible */
    details{
      border: 1px dashed rgba(0,0,0,0.25);
      border-radius: 14px;
      background: rgba(255,255,255,0.12);
      padding: 10px;
      margin-top: 12px;
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }
    details summary{
      cursor: pointer;
      font-weight: 950;
      list-style: none;
      font-size: var(--small);
    }
    details summary::-webkit-details-marker{ display:none; }
    .sigil{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      letter-spacing: 0.4px;
      font-size: 10px;
      opacity: 0.7;
    }

    /* Loading dot */
    .loading{
      display:inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #f2f6ff;
      animation: spin 800ms linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    @media (max-width: 480px){
      .title{ flex-direction: column; align-items: flex-start; }
    }

    /* Bag view */
    .bagPage{
      max-width: var(--bag-maxw);
      margin: 0 auto;
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .bagFrame{
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid var(--scene-border);
      background: rgba(0,0,0,0.15);
      box-shadow: var(--shadow2);
      position: relative;
    }
    .bagBgImg{
      width:100%;
      height: min(72vh, 740px);
      min-height: 520px;
      object-fit: contain;
      display:block;
      background: rgba(0,0,0,0.10);
      user-select: none;
      pointer-events: none;
    }

    .bagOverlay{
      position:absolute;
      inset: 0;
      padding: var(--bag-trim);
      padding-top: calc(var(--bag-trim) + var(--bag-top-offset));
      display:flex;
      align-items: stretch;
      justify-content: center;
    }

    @media (max-width: 760px){
      .bagOverlay{
        padding: var(--bag-trim-mobile);
        padding-top: calc(var(--bag-trim-mobile) + var(--bag-top-offset));
      }
    }

    .bagSlots{
      width: 100%;
      height: 100%;
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 10px;
      align-content: start;
      overflow: auto;
      padding: 8px;
    }
    .bagTile{
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,0.25);
      background: rgba(255,255,255,0.10);
      box-shadow: 0 10px 20px rgba(0,0,0,0.18);
      padding: 10px;
      display:flex;
      flex-direction: column;
      gap: 8px;
      backdrop-filter: blur(2px);
    }
    .bagTileTop{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 86px;
    }
    .bagIcon{
      width: 72px;
      height: 72px;
      object-fit: contain;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.25));
      user-select: none;
      pointer-events: none;
    }
    .bagLabel{
      font-weight: 950;
      color: rgba(245,248,255,0.95);
      text-shadow: 0 1px 0 rgba(0,0,0,0.45);
      font-size: 12px;
      line-height: 1.15;
      text-align:center;
      word-break: break-word;
      min-height: 34px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .bagMeta{
      font-size: 11px;
      line-height: 1.2;
      color: rgba(233,237,246,0.86);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 28px;
      padding: 2px 4px;
      border-radius: 10px;
      background: rgba(0,0,0,0.10);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .bagQtyRow{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 6px;
      flex-wrap: nowrap;
    }
    .bagQtyRow .count{
      border-color: rgba(255,255,255,0.18);
      color: #f2f6ff;
      background: rgba(0,0,0,0.12);
    }
    .bagQtyRow .qtyBtn{
      border-color: rgba(255,255,255,0.18);
      color: #f2f6ff;
      background: rgba(0,0,0,0.14);
    }

    /* Brew success overlay */
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.58);
      z-index: 80;
      display:none;
      align-items: center;
      justify-content: center;
      padding: 14px;
    }
    .overlayCard{
      width: min(760px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(18, 22, 30, 0.92);
      box-shadow: var(--shadow);
      padding: 12px;
      color: #f2f6ff;
    }
    .overlayTitle{
      font-weight: 950;
      font-size: 14px;
      margin-bottom: 6px;
    }
    .overlaySub{
      font-size: 12px;
      color: rgba(233,237,246,0.78);
      margin-bottom: 10px;
      line-height: 1.25;
    }
    .overlayGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      max-height: min(62vh, 520px);
      overflow:auto;
      padding-right: 6px;
    }
    .overlayRow{
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,0.20);
      background: rgba(255,255,255,0.06);
      padding: 10px;
      display:flex;
      flex-direction: column;
      gap: 8px;
    }
    .overlayRowTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .overlayEffectName{
      font-weight: 950;
      font-size: 13px;
    }
    .overlayHint{
      font-size: 12px;
      color: rgba(233,237,246,0.78);
      line-height: 1.25;
    }
    .overlayInputRow{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }
    .overlayInputRow input{
      flex: 1 1 180px;
      min-width: 160px;
    }
    .overlayFooter{
      margin-top: 10px;
      display:flex;
      gap: 8px;
      justify-content:flex-end;
      flex-wrap: wrap;
    }
    .overlayFooter button{
      font-weight: 950;
      white-space: nowrap;
    }
    .pillMini{
      display:inline-flex;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      font-size: 11px;
      font-weight: 950;
      color: rgba(245,248,255,0.95);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>Field Notes</h1>
        <div class="sub">A travel-worn record of leaves, powders, and quiet discoveries.</div>
      </div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button class="btn-quiet" id="refreshBtn" title="Pulls in any prepared ingredients.">
          <span id="refreshText">Update Notes</span>
        </button>
      </div>
    </div>

    <!-- MAIN -->
    <section id="viewMain">
      <div class="main-grid">
        <div class="panel" title="Open Field Notes">
          <button class="overlayBtn" id="openBookBtn" aria-label="Open Field Notes">
            <img class="coverArt" src="assets/ui/cover_closed.webp" alt="Field Notes cover" />
            <div class="hint">Tap to open</div>
          </button>
        </div>

        <div class="panel" title="Brewing">
          <button class="overlayBtn" id="openBrewBtn" aria-label="Open brewing">
            <img class="coverArt" src="assets/ui/cauldron_main.webp" alt="Brewing cauldron" />
            <div class="hint">Brewing</div>
          </button>
        </div>
      </div>

      <!-- Bag panel below -->
      <div class="panel panel-below" title="Bag">
        <button class="overlayBtn" id="openBagBtn" aria-label="Open bag">
          <img class="coverArt" src="assets/ui/Backpack.webp" alt="Backpack" />
          <div class="hint">Bag</div>
        </button>
      </div>

      <div class="muted" style="margin-top:12px;">
        Your discoveries stay on this device.
      </div>
    </section>

    <!-- BOOK -->
    <section id="viewBook" class="scene hidden">
      <div class="sceneTopBar">
        <div class="topLeftBtns">
          <button class="backBtn" id="closeBookBtn" type="button" aria-label="Close book">
            <img src="assets/icons/arrow_back.webp" alt="" />
            Close
          </button>

          <button class="backBtn hidden" id="backToIndexTopBtn" type="button" aria-label="Back to Index">
            <img src="assets/icons/arrow_back.webp" alt="" />
            Index
          </button>
        </div>

        <div class="muted" id="bookStatus">Ready.</div>
      </div>

      <div class="bookWrap">
        <img class="bookBg" src="assets/ui/book_open.webp" alt="" />

        <!-- BOOK: INDEX SPREAD -->
        <div class="bookPages" id="spreadIndex">
          <div class="page">
            <div class="pageInner">
              <div class="leftCentered">
                <h2 style="text-align:center;">Index</h2>
                <div class="muted" style="text-align:center; margin-bottom:8px;">Tap a name to open its page.</div>
              </div>

              <div class="hr"></div>

              <div class="leftCentered">
                <h3>Record Ingredient</h3>
                <div class="muted">Write the mark you were given.</div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; width:100%;">
                  <input id="markInput" inputmode="numeric" placeholder="Mark" aria-label="Mark" />
                  <button class="btn-primary" id="recordBtn" type="button">Record</button>
                </div>
              </div>

              <div class="hr"></div>

              <div class="leftCentered">
                <h3 style="text-align:center;">Inventory</h3>
              </div>

              <div id="indexList"></div>

              <details>
                <summary>ðŸ“‹ Keep Safe</summary>
                <div class="muted" style="margin-top:8px;">
                  If you change devices, export your notes first.
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:9px;">
                  <button id="exportBtn" type="button">Export Notes</button>
                  <button id="importBtn" type="button">Import Notes</button>
                  <button id="wipeBtn" type="button">Burn All Notes</button>
                </div>
                <textarea id="saveBox" rows="6" style="width:100%; margin-top:9px;" placeholder="Notes appear here for export or import."></textarea>
                <div class="muted sigil" style="margin-top:8px;">
                  This page never sends your discoveries anywhere, unless you export them.
                </div>
              </details>
            </div>
          </div>

          <div class="page pageRight">
            <div class="pageInner">
              <h2>Concentrates</h2>
              <div class="muted">Your bottled effects, tracked here.</div>
              <div class="hr" style="width:100%;"></div>
              <div id="concList" class="noteBox" style="max-height: 320px;"></div>
              <div class="muted" style="margin-top:8px;">
                Brew concentrates from the Brewing screen.
              </div>
            </div>
          </div>
        </div>

        <!-- BOOK: INGREDIENT SPREAD -->
        <div class="bookPages hidden" id="spreadIngredient">
          <div class="page">
            <div class="pageInner">
              <div style="width:var(--line-width); margin: 0 auto;">
                <h2 id="ingName" style="margin:0;">Ingredient</h2>
              </div>

              <div style="margin-top:8px; width:var(--line-width); margin-left:auto; margin-right:auto; text-align:center;">
                <span class="pill" id="rarityPill">Unknown</span>
              </div>

              <div style="margin-top:8px; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <img class="plantImg" id="ingImage" alt="Ingredient" />
              </div>

              <div style="margin-top:9px; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <h3 style="margin:0 0 6px 0;">Description</h3>
                <div class="noteBox" id="ingNotes"></div>
              </div>

              <div style="margin-top:9px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <button id="revealRandomBtn" type="button">Reveal a Property</button>
                <button id="resetRevealsBtn" type="button" class="btn-quiet">Forget Properties</button>
              </div>

              <div class="effects" id="effectsList"></div>
            </div>
          </div>

          <div class="page pageRight">
            <div class="pageInner">
              <h2>Known Recipes</h2>
              <div class="muted">What you have learned so far.</div>
              <div class="hr" style="width:100%;"></div>
              <div id="recipesList" class="noteBox" style="max-height: 320px;"></div>
            </div>
          </div>
        </div>

      </div>
    </section>

    <!-- BREW -->
    <section id="viewBrew" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromBrewBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="brewStatus">Choose your ingredients.</div>
      </div>

      <div class="brewPage">
        <div class="brewImageFrame">
          <img class="brewBgImg" id="brewBg" src="assets/themes/wilderness_bg.webp" alt="" />
        </div>

        <div class="brewControls">
          <div class="brewTopRow">
            <button class="themeBtn" id="themeToggleBtn" type="button" aria-label="Switch theme">
              <img id="themeIcon" src="assets/icons/theme_wilderness.webp" alt="" />
              <span id="themeLabel">Wilderness</span>
            </button>

            <label style="display:flex; align-items:center; gap:7px; font-weight:950; color:#f2f6ff; font-size:var(--small); cursor:pointer;">
              <input type="checkbox" id="useThird" />
              Third ingredient (optional)
            </label>
          </div>

          <div class="brewGrid">
            <div class="slotBox">
              <div class="slotTitle">First ingredient</div>
              <select id="mixA"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discA"></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Second ingredient</div>
              <select id="mixB"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discB"></div>
            </div>

            <div class="slotBox hidden" id="thirdSlot">
              <div class="slotTitle">Third ingredient</div>
              <select id="mixC"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discC"></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Brew</div>

              <div class="muted" id="brewDc" style="margin-bottom:8px;">
                DC: (choose ingredients)
              </div>

              <div class="brewBtnRow">
                <button class="btn-primary" id="brewSuccessBtn" type="button">Brew (Success)</button>
                <button class="btn-bad" id="brewFailBtn" type="button">Brew (Failure)</button>
              </div>

              <div class="resultBox" id="mixResult" style="margin-top:9px;">
                <div class="muted">No mixture yet.</div>
              </div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Concentrate</div>
              <div class="muted" style="margin-bottom:8px;">Spend 3 of the same ingredient to bottle a revealed property.</div>
              <div class="concControls">
                <select id="concBaseSelect" aria-label="Choose ingredient"></select>
                <select id="concEffectSelect" aria-label="Choose property"></select>
                <button class="btn-primary" id="concCraftBtn" type="button">Concentrate (Spend 3)</button>
              </div>
              <div class="muted" style="margin-top:8px;">Result appears in the Field Notes concentrates inventory, and in the Bag.</div>
            </div>
          </div>

          <div class="muted" style="margin-top:10px;">
            Brewing draws from your Inventory. If you lack an ingredient, the attempt is refused.
          </div>
        </div>
      </div>
    </section>

    <!-- BAG -->
    <section id="viewBag" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromBagBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="bagStatus">Your bag.</div>
      </div>

      <div class="bagPage">
        <div class="bagFrame">
          <img class="bagBgImg" src="assets/ui/Backpack_UI.webp" alt="Bag UI" />
          <div class="bagOverlay" aria-label="Bag slots overlay">
            <div class="bagSlots" id="bagSlots"></div>
          </div>
        </div>

        <div class="muted">
          Honor system: adjust counts freely.
        </div>
      </div>
    </section>
  </div>

  <!-- Success overlay -->
  <div class="overlay" id="brewOverlay" role="dialog" aria-modal="true" aria-label="Record potion results">
    <div class="overlayCard">
      <div class="overlayTitle">Record Your Concoction</div>
      <div class="overlaySub" id="overlaySub">
        Enter the bonus roll for each shared property. The base dice are shown as a reminder.
      </div>

      <div class="overlayGrid" id="overlayGrid"></div>

      <div class="overlayFooter">
        <button class="btn-quiet" id="overlayCancelBtn" type="button">Cancel</button>
        <button class="btn-primary" id="overlaySaveBtn" type="button">Save to Bag</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <audio id="sfxPage" src="assets/sfx/page_turn.mp3" preload="auto"></audio>
  <audio id="sfxSuccess" src="assets/sfx/brew_success.mp3" preload="auto"></audio>

<script>
  const SUPABASE_URL = "https://yjelzojkirlzdnwftupz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqZWx6b2praXJsemRud2Z0dXB6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAzNTk0MTEsImV4cCI6MjA4NTkzNTQxMX0.5TCIyj5cAUlCAmNc2yBOIdpfNoN4NLqOOfcnBVbCzZA";

  const REST_BASE = `${SUPABASE_URL}/rest/v1`;
  const INGREDIENTS_ENDPOINT = `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&order=id.asc`;
  const INGREDIENT_BY_MARK = (mark) => `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&id=eq.${encodeURIComponent(mark)}&limit=1`;
  const PUBLIC_STORAGE_BASE = `${SUPABASE_URL}/storage/v1/object/public/`;

  const LOCAL_KEY = "field_notes_v2";
  let LOCAL = loadLocal();
  let REVEALS = LOCAL.reveals;
  let INDEX = LOCAL.index;
  let RECIPES = LOCAL.recipes;
  let CONCENTRATES = LOCAL.concentrates;
  let POTIONS = LOCAL.potions; // Bag inventory

  let ING_BY_ID = {};
  let currentIngredientId = null;
  let theme = "wilderness";
  let isFetching = false;

  let pendingBrew = null; // used for overlay save

  const viewMain = document.getElementById("viewMain");
  const viewBook = document.getElementById("viewBook");
  const viewBrew = document.getElementById("viewBrew");
  const viewBag = document.getElementById("viewBag");
  const spreadIndex = document.getElementById("spreadIndex");
  const spreadIngredient = document.getElementById("spreadIngredient");

  const el = (id) => document.getElementById(id);

  function headers() {
    return { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${SUPABASE_ANON_KEY}` };
  }

  function saveLocal() {
    LOCAL = { reveals: REVEALS, index: INDEX, recipes: RECIPES, concentrates: CONCENTRATES, potions: POTIONS };
    localStorage.setItem(LOCAL_KEY, JSON.stringify(LOCAL));
  }

  function loadLocal() {
    const raw = localStorage.getItem(LOCAL_KEY);
    if (!raw) return { reveals: {}, index: {}, recipes: [], concentrates: {}, potions: {} };
    try {
      const parsed = JSON.parse(raw);
      const reveals = (parsed && typeof parsed.reveals === "object" && parsed.reveals) ? parsed.reveals : {};
      const index = (parsed && typeof parsed.index === "object" && parsed.index) ? parsed.index : {};
      const recipes = Array.isArray(parsed?.recipes) ? parsed.recipes : [];
      const concentrates = (parsed && typeof parsed.concentrates === "object" && parsed.concentrates) ? parsed.concentrates : {};
      const potions = (parsed && typeof parsed.potions === "object" && parsed.potions) ? parsed.potions : {};

      const cleanIndex = {};
      for (const [k,v] of Object.entries(index)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanIndex[String(k)] = Math.floor(n);
      }

      const cleanConcs = {};
      for (const [k,v] of Object.entries(concentrates)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanConcs[String(k)] = Math.floor(n);
      }

      const cleanPotions = {};
      for (const [k,v] of Object.entries(potions)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanPotions[String(k)] = Math.floor(n);
      }

      return { reveals, index: cleanIndex, recipes, concentrates: cleanConcs, potions: cleanPotions };
    } catch {
      return { reveals: {}, index: {}, recipes: [], concentrates: {}, potions: {} };
    }
  }

  function toast(msg, kind) {
    const t = el("toast");
    t.className = "toast";
    if (kind === "good") t.classList.add("good");
    if (kind === "bad") t.classList.add("bad");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => { t.style.display = "none"; }, 2200);
  }

  function playSfx(audioId) {
    const a = document.getElementById(audioId);
    if (!a) return;
    a.currentTime = 0;
    a.play().catch(() => {});
  }

  function showOnly(which) {
    viewMain.classList.add("hidden");
    viewBook.classList.add("hidden");
    viewBrew.classList.add("hidden");
    viewBag.classList.add("hidden");

    if (which === "main") viewMain.classList.remove("hidden");
    if (which === "book") viewBook.classList.remove("hidden");
    if (which === "brew") viewBrew.classList.remove("hidden");
    if (which === "bag") viewBag.classList.remove("hidden");
  }

  function showBookSpread(which) {
    spreadIndex.classList.add("hidden");
    spreadIngredient.classList.add("hidden");
    el("backToIndexTopBtn").classList.toggle("hidden", which !== "ingredient");
    if (which === "index") spreadIndex.classList.remove("hidden");
    if (which === "ingredient") spreadIngredient.classList.remove("hidden");
  }

  function getImageUrl(image_path) {
    if (!image_path) return "";
    return `${PUBLIC_STORAGE_BASE}${image_path}?t=${Date.now()}`;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\"": "&quot;",
      "'": "&#39;"
    }[c]));
  }

  function placeholderImageDataUri(label) {
    const svg =
      `<svg xmlns='http://www.w3.org/2000/svg' width='800' height='800'>` +
      `<rect width='100%' height='100%' fill='%23ffffff'/>` +
      `<rect x='20' y='20' width='760' height='760' rx='38' ry='38' fill='%23f6f0e3' stroke='%23d9c8aa' stroke-width='6'/>` +
      `<text x='50%' y='52%' dominant-baseline='middle' text-anchor='middle' fill='%23000' font-size='42' font-family='Segoe Print,Bradley Hand,cursive'>${escapeHtml(label)}</text>` +
      `</svg>`;
    return "data:image/svg+xml," + encodeURIComponent(svg);
  }

  function rarityClass(r) {
    const v = String(r || "").trim().toLowerCase();
    if (!v) return "pill-unknown";
    if (v.includes("rare") || v.includes("uncommon") || v.includes("legend")) return "pill-rare";
    return "pill-common";
  }

  function rarityLabel(r) {
    const v = String(r || "").trim();
    return v ? v : "Unknown";
  }

  function normKey(s) {
    return String(s || "")
      .trim()
      .replace(/\s+/g, " ")
      .toLowerCase();
  }

  function rarityTier(r) {
    const v = normKey(r);
    if (v.includes("legend")) return "legendary";
    if (v.includes("rare")) return "rare";
    if (v.includes("uncommon")) return "uncommon";
    return "common";
  }

  function rarityRank(tier) {
    const t = normKey(tier);
    if (t === "legendary") return 3;
    if (t === "rare") return 2;
    if (t === "uncommon") return 1;
    return 0;
  }

  function dcForRarityTier(tier) {
    const t = normKey(tier);
    if (t === "legendary") return 18;
    if (t === "rare") return 15;
    if (t === "uncommon") return 12;
    return 10;
  }

  function formatCoins(c) {
    const gp = Number(c?.gp) || 0;
    const sp = Number(c?.sp) || 0;
    const cp = Number(c?.cp) || 0;
    const parts = [];
    if (gp) parts.push(`${gp} gp`);
    if (sp) parts.push(`${sp} sp`);
    if (cp) parts.push(`${cp} cp`);
    return parts.length ? parts.join(", ") : "0 gp";
  }

  function addCoins(a, b) {
    return {
      gp: (Number(a?.gp) || 0) + (Number(b?.gp) || 0),
      sp: (Number(a?.sp) || 0) + (Number(b?.sp) || 0),
      cp: (Number(a?.cp) || 0) + (Number(b?.cp) || 0),
    };
  }

  function normalizeCoins(c) {
    let gp = Number(c?.gp) || 0;
    let sp = Number(c?.sp) || 0;
    let cp = Number(c?.cp) || 0;

    if (cp >= 10) { sp += Math.floor(cp / 10); cp = cp % 10; }
    if (sp >= 10) { gp += Math.floor(sp / 10); sp = sp % 10; }

    if (cp < 0) cp = 0;
    if (sp < 0) sp = 0;
    if (gp < 0) gp = 0;

    return { gp, sp, cp };
  }

  async function fetchAllIngredients() {
    if (isFetching) return;
    isFetching = true;

    el("refreshBtn").disabled = true;
    el("refreshText").innerHTML = '<span class="loading"></span>';

    el("bookStatus").textContent = "Turning pages...";
    el("brewStatus").textContent = "Stirring embers...";
    el("bagStatus").textContent = "Packing...";

    try {
      const res = await fetch(INGREDIENTS_ENDPOINT, { headers: headers() });
      if (!res.ok) throw new Error(await res.text());
      const rows = await res.json();

      ING_BY_ID = {};
      for (const r of rows) {
        const idStr = String(r.id);
        ING_BY_ID[idStr] = r;
        if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
      }

      for (const idStr of Object.keys(INDEX)) {
        if (!ING_BY_ID[idStr]) delete INDEX[idStr];
      }

      saveLocal();
      renderIndex();
      fillBrewChoices();
      enforceDistinctMixing();
      renderBrewDiscovered();
      renderConcentratesInventory();
      fillConcentrateCraftChoices();
      renderBag();
      updateBrewDcDisplay();

      el("bookStatus").textContent = "Ready.";
      el("brewStatus").textContent = "Choose your ingredients.";
      el("bagStatus").textContent = "Your bag.";
      toast("Notes updated.", "good");
    } catch (e) {
      el("bookStatus").textContent = "Could not update.";
      el("brewStatus").textContent = "Could not update.";
      el("bagStatus").textContent = "Could not update.";
      toast("The ink smudged. Try again.", "bad");
      console.error(e);
    } finally {
      isFetching = false;
      el("refreshBtn").disabled = false;
      el("refreshText").textContent = "Update Notes";
    }
  }

  async function fetchOne(mark) {
    const res = await fetch(INGREDIENT_BY_MARK(mark), { headers: headers() });
    if (!res.ok) throw new Error(await res.text());
    const rows = await res.json();
    return rows?.[0] || null;
  }

  function sortedIndexIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id]);
    ids.sort((a,b) => Number(a) - Number(b));
    return ids;
  }

  function setQty(idStr, qty) {
    const q = Math.max(0, Math.floor(Number(qty) || 0));
    INDEX[String(idStr)] = q;
    saveLocal();
  }

  /* =========================
     Concentrates inventory (book right page)
     ========================= */
  function concKey(idStr, effectText) {
    const cleanId = String(idStr);
    const eff = String(effectText || "").trim();
    return `c:${cleanId}:${encodeURIComponent(eff)}`;
  }

  function parseConcKey(key) {
    const s = String(key || "");
    if (!s.startsWith("c:")) return null;
    const parts = s.split(":");
    if (parts.length < 3) return null;
    const idStr = parts[1];
    const effEnc = parts.slice(2).join(":");
    const effect = decodeURIComponent(effEnc || "");
    return { idStr, effect };
  }

  function setConcQty(key, qty) {
    const q = Math.max(0, Math.floor(Number(qty) || 0));
    if (q <= 0) {
      delete CONCENTRATES[String(key)];
    } else {
      CONCENTRATES[String(key)] = q;
    }
    saveLocal();
  }

  function revealedEffectsForIngredient(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) return [];
    const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4].map(v => (v ? String(v).trim() : ""));
    const revealed = REVEALS[idStr] || [false,false,false,false];
    const out = [];
    for (let i = 0; i < 4; i++) {
      if (revealed[i] && effs[i]) out.push(effs[i]);
    }
    return out;
  }

  function craftableIngredientIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id] && (Number(INDEX[id]) || 0) >= 3);
    const craftable = [];
    for (const idStr of ids) {
      const effects = revealedEffectsForIngredient(idStr);
      if (effects.length) craftable.push(String(idStr));
    }
    craftable.sort((a,b) => Number(a) - Number(b));
    return craftable;
  }

  function fillConcentrateCraftChoices() {
    const baseSel = el("concBaseSelect");
    const effSel = el("concEffectSelect");
    const craftBtn = el("concCraftBtn");
    if (!baseSel || !effSel || !craftBtn) return;

    const craftable = craftableIngredientIds();

    if (!craftable.length) {
      baseSel.innerHTML = `<option value="">No craftable ingredients</option>`;
      effSel.innerHTML = `<option value="">No revealed properties</option>`;
      craftBtn.disabled = true;
      return;
    }

    const prevBase = baseSel.value;
    baseSel.innerHTML = craftable.map(idStr => {
      const name = ING_BY_ID[idStr]?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;
      return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
    }).join("");

    baseSel.value = craftable.includes(prevBase) ? prevBase : craftable[0];

    const effects = revealedEffectsForIngredient(baseSel.value);
    const prevEff = effSel.value;

    if (!effects.length) {
      effSel.innerHTML = `<option value="">No revealed properties</option>`;
      craftBtn.disabled = true;
      return;
    }

    effSel.innerHTML = effects.map(e => `<option value="${escapeHtml(e)}">${escapeHtml(e)}</option>`).join("");
    effSel.value = effects.includes(prevEff) ? prevEff : effects[0];

    craftBtn.disabled = false;
  }

  function renderConcentratesInventory() {
    const list = el("concList");
    if (!list) return;

    const entries = Object.entries(CONCENTRATES || {})
      .map(([k,v]) => ({ key: k, qty: Number(v) || 0, meta: parseConcKey(k) }))
      .filter(x => x.qty > 0 && x.meta && x.meta.effect);

    if (!entries.length) {
      list.innerHTML = `<div class="muted">No concentrates yet.</div>`;
      return;
    }

    entries.sort((a,b) => {
      const ea = a.meta.effect.toLowerCase();
      const eb = b.meta.effect.toLowerCase();
      if (ea < eb) return -1;
      if (ea > eb) return 1;
      return Number(a.meta.idStr) - Number(b.meta.idStr);
    });

    list.innerHTML = "";
    for (const e of entries) {
      const row = document.createElement("div");
      row.className = "indexRow";
      row.style.width = "100%";

      const label = document.createElement("div");
      label.style.fontWeight = "950";
      label.style.fontSize = "12.5px";
      label.style.opacity = "0.9";
      label.textContent = `Concentrate of ${e.meta.effect}`;

      const right = document.createElement("div");
      right.className = "inventoryBox";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "âˆ’";
      minus.addEventListener("click", () => {
        setConcQty(e.key, e.qty - 1);
        renderConcentratesInventory();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(e.qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        setConcQty(e.key, e.qty + 1);
        renderConcentratesInventory();
      });

      right.appendChild(minus);
      right.appendChild(count);
      right.appendChild(plus);

      row.appendChild(label);
      row.appendChild(right);
      list.appendChild(row);
    }
  }

  function craftConcentrate() {
    const baseSel = el("concBaseSelect");
    const effSel = el("concEffectSelect");
    if (!baseSel || !effSel) return;

    const idStr = String(baseSel.value || "");
    const effect = String(effSel.value || "").trim();
    if (!idStr || !effect) {
      toast("Choose an ingredient and a property.", "bad");
      return;
    }

    const qty = Number(INDEX[idStr]) || 0;
    if (qty < 3) {
      toast("Not enough of that ingredient.", "bad");
      fillConcentrateCraftChoices();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      renderConcentratesInventory();
      updateBrewDcDisplay();
      return;
    }

    const revealed = revealedEffectsForIngredient(idStr);
    if (!revealed.includes(effect)) {
      toast("That property is not revealed.", "bad");
      fillConcentrateCraftChoices();
      return;
    }

    // Spend 3, gain 1 concentrate
    setQty(idStr, qty - 3);

    const key = concKey(idStr, effect);
    const haveConc = Number(CONCENTRATES[key]) || 0;
    CONCENTRATES[key] = haveConc + 1;

    saveLocal();

    // Add to bag (minimal)
    addPotion({
      type: "concentrate",
      rarity: rarityTier(ING_BY_ID[idStr]?.rarity),
      effects: [{ name: effect, kind: "numeric", bonus: null, baseNote: null, bonusDice: null }],
      price: { gp: 0, sp: 0, cp: 0 }
    }, 1);

    renderIndex();
    fillBrewChoices();
    renderBrewDiscovered();
    renderConcentratesInventory();
    fillConcentrateCraftChoices();
    updateBrewDcDisplay();

    toast("Concentrate bottled.", "good");
  }

  /* =========================
     Bag inventory (potions)
     ========================= */
  function stableStringify(obj) {
    return JSON.stringify(obj, Object.keys(obj).sort());
  }

  function potionKeyFromMeta(meta) {
    const type = normKey(meta?.type || "");
    const rarity = normKey(meta?.rarity || "");
    const effects = Array.isArray(meta?.effects) ? meta.effects.slice() : [];

    effects.sort((a,b) => {
      const na = normKey(a?.name);
      const nb = normKey(b?.name);
      if (na < nb) return -1;
      if (na > nb) return 1;
      return 0;
    });

    const packed = effects.map(e => ({
      name: String(e?.name || ""),
      kind: String(e?.kind || ""),
      bonus: (e?.bonus === null || e?.bonus === undefined) ? null : Number(e?.bonus),
      baseNote: e?.baseNote ? String(e.baseNote) : null,
      bonusDice: e?.bonusDice ? String(e.bonusDice) : null
    }));

    const keyObj = {
      t: type,
      r: rarity,
      e: packed,
      p: normalizeCoins(meta?.price || { gp:0, sp:0, cp:0 })
    };

    return "p:" + encodeURIComponent(stableStringify(keyObj));
  }

  function parsePotionKey(key) {
    const s = String(key || "");
    if (!s.startsWith("p:")) return null;
    try{
      const json = decodeURIComponent(s.slice(2));
      const obj = JSON.parse(json);
      return obj;
    } catch {
      return null;
    }
  }

  function potionLabelFromKeyObj(obj) {
    const t = normKey(obj?.t);
    const rarity = String(obj?.r || "");
    const effects = Array.isArray(obj?.e) ? obj.e : [];
    const names = effects.map(x => String(x?.name || "")).filter(Boolean);
    const effText = names.length ? names.join(", ") : "Unknown";

    const typeLabel = (t === "concentrate") ? "Concentrate" : "Concoction";
    const rarityLabelText = rarity ? (rarity.charAt(0).toUpperCase() + rarity.slice(1)) : "Common";

    return `${typeLabel} (${rarityLabelText}) of ${effText}`;
  }

  function potionMetaTextFromKeyObj(obj) {
    const effects = Array.isArray(obj?.e) ? obj.e : [];
    const lines = [];

    for (const e of effects) {
      const name = String(e?.name || "").trim();
      if (!name) continue;

      const baseNote = e?.baseNote ? String(e.baseNote) : "";
      const bonusDice = e?.bonusDice ? String(e.bonusDice) : "";
      const bonus = (e?.bonus === null || e?.bonus === undefined || !Number.isFinite(Number(e.bonus))) ? null : Number(e.bonus);

      if (bonus !== null) {
        const parts = [];
        if (baseNote) parts.push(`Base ${baseNote}`);
        if (bonusDice) parts.push(`Bonus ${bonusDice}`);
        const hint = parts.length ? ` (${parts.join(", ")})` : "";
        lines.push(`${name}: +${bonus}${hint}`);
      } else {
        const hint = baseNote || bonusDice ? ` (Base ${baseNote || "?"}, Bonus ${bonusDice || "?"})` : "";
        lines.push(`${name}${hint}`);
      }
    }

    const price = normalizeCoins(obj?.p || { gp:0, sp:0, cp:0 });
    lines.push(`Value: ${formatCoins(price)}`);

    return lines.join("\n");
  }

  function potionIconPath(type) {
    const t = normKey(type);
    if (t === "concentrate") return "assets/icons/Generic_Concentrate.webp";
    return "assets/icons/Generic_Potion.webp";
  }

  function setPotionQty(key, qty) {
    const q = Math.max(0, Math.floor(Number(qty) || 0));
    if (q <= 0) {
      delete POTIONS[String(key)];
    } else {
      POTIONS[String(key)] = q;
    }
    saveLocal();
  }

  function addPotion(meta, amount = 1) {
    const key = potionKeyFromMeta(meta);
    const have = Number(POTIONS[key]) || 0;
    POTIONS[key] = Math.max(0, have + (Number(amount) || 0));
    saveLocal();
    renderBag();
  }

  function renderBag() {
    const wrap = el("bagSlots");
    if (!wrap) return;

    const entries = Object.entries(POTIONS || {})
      .map(([k,v]) => ({ key: k, qty: Number(v) || 0, obj: parsePotionKey(k) }))
      .filter(x => x.qty > 0 && x.obj);

    if (!entries.length) {
      wrap.innerHTML = `
        <div class="muted" style="grid-column: 1 / -1; padding: 10px;">
          Your bag is empty.
        </div>
      `;
      return;
    }

    entries.sort((a,b) => {
      const la = potionLabelFromKeyObj(a.obj).toLowerCase();
      const lb = potionLabelFromKeyObj(b.obj).toLowerCase();
      if (la < lb) return -1;
      if (la > lb) return 1;
      return 0;
    });

    wrap.innerHTML = "";
    for (const e of entries) {
      const tile = document.createElement("div");
      tile.className = "bagTile";

      const top = document.createElement("div");
      top.className = "bagTileTop";

      const img = document.createElement("img");
      img.className = "bagIcon";
      img.src = potionIconPath(e.obj?.t) + "?t=" + Date.now();
      img.alt = "Potion";
      img.onerror = () => { img.src = placeholderImageDataUri("Potion"); };

      top.appendChild(img);

      const label = document.createElement("div");
      label.className = "bagLabel";
      label.textContent = potionLabelFromKeyObj(e.obj);

      const meta = document.createElement("div");
      meta.className = "bagMeta";
      meta.textContent = potionMetaTextFromKeyObj(e.obj);

      const qtyRow = document.createElement("div");
      qtyRow.className = "bagQtyRow";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "âˆ’";
      minus.addEventListener("click", () => {
        setPotionQty(e.key, e.qty - 1);
        renderBag();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(e.qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        setPotionQty(e.key, e.qty + 1);
        renderBag();
      });

      qtyRow.appendChild(minus);
      qtyRow.appendChild(count);
      qtyRow.appendChild(plus);

      tile.appendChild(top);
      tile.appendChild(label);
      tile.appendChild(meta);
      tile.appendChild(qtyRow);

      wrap.appendChild(tile);
    }
  }

  /* =========================
     Index rendering
     ========================= */
  function renderIndex() {
    const wrap = el("indexList");
    wrap.innerHTML = "";

    const ids = sortedIndexIds();
    if (ids.length === 0) {
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No entries yet.";
      wrap.appendChild(d);
      renderConcentratesInventory();
      return;
    }

    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      const name = row?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;

      const line = document.createElement("div");
      line.className = "indexRow";

      const left = document.createElement("div");
      const nameBtn = document.createElement("button");
      nameBtn.type = "button";
      nameBtn.className = "ingNameBtn";
      nameBtn.textContent = name;
      nameBtn.addEventListener("click", () => {
        playSfx("sfxPage");
        openIngredient(idStr);
      });
      left.appendChild(nameBtn);

      const right = document.createElement("div");
      right.className = "inventoryBox";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "âˆ’";
      minus.addEventListener("click", () => {
        setQty(idStr, qty - 1);
        renderIndex();
        fillBrewChoices();
        renderBrewDiscovered();
        fillConcentrateCraftChoices();
        updateBrewDcDisplay();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        setQty(idStr, qty + 1);
        renderIndex();
        fillBrewChoices();
        renderBrewDiscovered();
        fillConcentrateCraftChoices();
        updateBrewDcDisplay();
      });

      right.appendChild(minus);
      right.appendChild(count);
      right.appendChild(plus);

      line.appendChild(left);
      line.appendChild(right);
      wrap.appendChild(line);
    }

    renderConcentratesInventory();
  }

  async function recordIngredientFromMark(mark) {
    const clean = String(mark || "").replace(/\D/g, "");
    if (!clean) {
      toast("Enter a mark.", "bad");
      return;
    }

    if (ING_BY_ID[clean]) {
      if (INDEX[clean] === undefined) INDEX[clean] = 0;
      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateCraftChoices();
      updateBrewDcDisplay();
      toast("Recorded.", "good");
      el("markInput").value = "";
      return;
    }

    try {
      el("recordBtn").disabled = true;
      const row = await fetchOne(clean);
      if (!row) {
        toast("That mark is unknown.", "bad");
        el("recordBtn").disabled = false;
        return;
      }
      ING_BY_ID[clean] = row;
      if (!REVEALS[clean]) REVEALS[clean] = [false,false,false,false];
      if (INDEX[clean] === undefined) INDEX[clean] = 0;
      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateCraftChoices();
      updateBrewDcDisplay();
      toast("Recorded.", "good");
      el("markInput").value = "";
      el("recordBtn").disabled = false;
    } catch {
      toast("Could not read that mark.", "bad");
      el("recordBtn").disabled = false;
    }
  }

  function openIngredient(idStr) {
    currentIngredientId = idStr;
    showBookSpread("ingredient");
    renderIngredient(idStr);
  }

  function renderIngredient(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) {
      toast("That page is missing.", "bad");
      showBookSpread("index");
      return;
    }

    el("ingName").textContent = row.name || "Unknown Ingredient";
    const pill = el("rarityPill");
    pill.className = "pill " + rarityClass(row?.rarity);
    pill.textContent = rarityLabel(row?.rarity);

    const imgUrl = getImageUrl(row.image_path);
    el("ingImage").src = imgUrl || placeholderImageDataUri("No sketch");
    el("ingImage").onerror = () => {
      el("ingImage").src = placeholderImageDataUri(row.name);
    };

    el("ingNotes").textContent = row.notes ? String(row.notes) : "No notes written yet.";

    const effects = [row.effect_1,row.effect_2,row.effect_3,row.effect_4].map(v => v || "");
    const revealed = REVEALS[idStr] || [false,false,false,false];

    const list = el("effectsList");
    list.innerHTML = "";

    effects.forEach((eff, idx) => {
      const line = document.createElement("div");
      line.className = "effect-line";

      const label = document.createElement("div");
      label.className = "pill";
      label.textContent = `Property ${idx + 1}`;

      const text = document.createElement("div");
      text.className = "effect-text";
      text.textContent = eff || "(blank)";
      if (!revealed[idx]) text.classList.add("effect-hidden");

      const btn = document.createElement("button");
      btn.className = "smallBtn";
      btn.textContent = revealed[idx] ? "Known" : "Reveal";
      btn.disabled = revealed[idx];
      btn.addEventListener("click", () => {
        REVEALS[idStr][idx] = true;
        saveLocal();
        renderIngredient(idStr);
        toast("Noted.", "good");
      });

      line.appendChild(label);
      line.appendChild(text);
      line.appendChild(btn);
      list.appendChild(line);
    });

    el("revealRandomBtn").onclick = () => {
      const hidden = [];
      for (let i = 0; i < 4; i++) if (!REVEALS[idStr][i]) hidden.push(i);
      if (hidden.length === 0) {
        toast("Nothing more to learn here.", "good");
        return;
      }
      const pick = hidden[Math.floor(Math.random() * hidden.length)];
      REVEALS[idStr][pick] = true;
      saveLocal();
      renderIngredient(idStr);
      toast("Noted.", "good");
    };

    el("resetRevealsBtn").onclick = () => {
      REVEALS[idStr] = [false,false,false,false];
      saveLocal();
      renderIngredient(idStr);
      toast("Forgotten.", "bad");
    };

    renderRecipesForIngredient(idStr);
  }

  function renderRecipesForIngredient(idStr) {
    const box = el("recipesList");
    const nameOf = (iid) => ING_BY_ID[iid]?.name || `Ingredient ${iid}`;

    const related = RECIPES.filter(r => Array.isArray(r.ids) && r.ids.includes(idStr));
    if (related.length === 0) {
      box.textContent = "No recipes recorded yet.";
      return;
    }

    const lines = related.map(r => {
      const parts = r.ids.map(x => nameOf(String(x)));
      const effects = Array.isArray(r.effects) ? r.effects : [];
      const effText = effects.length ? effects.join(", ") : "Unknown";
      return `â€¢ ${parts.join(" + ")} = Concoction of ${effText}`;
    });

    box.textContent = lines.join("\n");
  }

  function setTheme(next) {
    theme = next;
    if (theme === "wilderness") {
      el("brewBg").src = "assets/themes/wilderness_bg.webp?t=" + Date.now();
      el("themeIcon").src = "assets/icons/theme_wilderness.webp?t=" + Date.now();
      el("themeLabel").textContent = "Wilderness";
    } else {
      el("brewBg").src = "assets/themes/town_bg.webp?t=" + Date.now();
      el("themeIcon").src = "assets/icons/theme_town.webp?t=" + Date.now();
      el("themeLabel").textContent = "Town";
    }
  }

  function availableForBrewIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id] && (Number(INDEX[id]) || 0) > 0);
    ids.sort((a,b) => Number(a) - Number(b));
    return ids;
  }

  function fillBrewChoices() {
    const a = el("mixA"), b = el("mixB"), c = el("mixC");
    const ids = availableForBrewIds();

    if (ids.length < 2) {
      a.innerHTML = "";
      b.innerHTML = "";
      c.innerHTML = "";
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      renderBrewDiscovered();
      updateBrewDcDisplay();
      return;
    }

    const opts = ids.map(idStr => {
      const name = ING_BY_ID[idStr]?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;
      return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
    }).join("");

    const prevA = a.value, prevB = b.value, prevC = c.value;

    a.innerHTML = opts;
    b.innerHTML = opts;
    c.innerHTML = opts;

    a.value = ids.includes(prevA) ? prevA : ids[0];
    const bCandidate = ids.includes(prevB) ? prevB : ids.find(x => x !== a.value);
    b.value = (bCandidate && bCandidate !== a.value) ? bCandidate : (ids.find(x => x !== a.value) || ids[0]);

    const cDefault = ids.find(x => x !== a.value && x !== b.value) || ids[0];
    c.value = ids.includes(prevC) ? prevC : cDefault;
    if (el("useThird").checked && (c.value === a.value || c.value === b.value)) c.value = cDefault;

    renderBrewDiscovered();
    updateBrewDcDisplay();
  }

  function enforceDistinctMixing() {
    const a = el("mixA"), b = el("mixB"), c = el("mixC");
    const ids = availableForBrewIds();

    if (a.value && b.value && a.value === b.value) {
      const next = ids.find(x => x !== a.value);
      if (next) b.value = next;
    }

    if (el("useThird").checked) {
      if (c.value === a.value || c.value === b.value) {
        const nextC = ids.find(x => x !== a.value && x !== b.value);
        if (nextC) c.value = nextC;
      }
      if (a.value === c.value) {
        const nextA = ids.find(x => x !== c.value && x !== b.value);
        if (nextA) a.value = nextA;
      }
      if (b.value === c.value) {
        const nextB = ids.find(x => x !== c.value && x !== a.value);
        if (nextB) b.value = nextB;
      }
    }

    renderBrewDiscovered();
    updateBrewDcDisplay();
  }

  function discoveredEffectsFor(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) return [];
    const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
    const revealed = REVEALS[idStr] || [false,false,false,false];
    const known = [];
    for (let i = 0; i < 4; i++) {
      if (revealed[i] && effs[i]) known.push(String(effs[i]));
    }
    return known;
  }

  function renderDiscoveredInto(containerId, effects) {
    const wrap = el(containerId);
    wrap.innerHTML = "";
    if (!effects.length) {
      const s = document.createElement("div");
      s.className = "muted";
      s.textContent = "None yet.";
      wrap.appendChild(s);
      return;
    }
    effects.forEach(e => {
      const p = document.createElement("div");
      p.className = "discoveredPill";
      p.textContent = e;
      wrap.appendChild(p);
    });
  }

  function renderBrewDiscovered() {
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    renderDiscoveredInto("discA", aId ? discoveredEffectsFor(aId) : []);
    renderDiscoveredInto("discB", bId ? discoveredEffectsFor(bId) : []);
    if (useThird) renderDiscoveredInto("discC", cId ? discoveredEffectsFor(cId) : []);
  }

  function computeShared(ids) {
    const rows = ids.map(id => ING_BY_ID[id]).filter(Boolean);
    if (rows.length < 2) return [];
    const sets = rows.map(r => new Set([r.effect_1,r.effect_2,r.effect_3,r.effect_4].filter(Boolean)));
    let shared = sets[0];
    for (let i = 1; i < sets.length; i++) {
      shared = new Set([...shared].filter(x => sets[i].has(x)));
    }
    return [...shared];
  }

  function canSpend(ids) {
    const needed = {};
    for (const id of ids) needed[id] = (needed[id] || 0) + 1;
    for (const [id, n] of Object.entries(needed)) {
      const have = Number(INDEX[id]) || 0;
      if (have < n) return false;
    }
    return true;
  }

  function spend(ids) {
    const needed = {};
    for (const id of ids) needed[id] = (needed[id] || 0) + 1;
    for (const [id, n] of Object.entries(needed)) {
      setQty(id, (Number(INDEX[id]) || 0) - n);
    }
  }

  function revealSharedAutomatically(ids, shared) {
    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      if (!row) continue;
      const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
      if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
      for (let i = 0; i < 4; i++) {
        if (shared.includes(effs[i])) REVEALS[idStr][i] = true;
      }
    }
    saveLocal();
  }

  function recordRecipe(ids, shared) {
    const norm = ids.map(String).slice().sort((a,b) => Number(a) - Number(b));
    const key = norm.join("+") + "::" + shared.slice().sort().join("|");
    const exists = RECIPES.some(r =>
      (Array.isArray(r.ids) ? r.ids.slice().sort((a,b)=>Number(a)-Number(b)).join("+") : "") +
      "::" +
      (Array.isArray(r.effects)? r.effects.slice().sort().join("|"):"") === key
    );
    if (exists) return;
    RECIPES.push({ ids: norm, effects: shared.slice(), at: Date.now() });
    saveLocal();
  }

  function selectedBrewIds() {
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    const ids = [aId,bId].filter(Boolean);
    if (useThird && cId) ids.push(cId);
    return ids;
  }

  function brewRarityTierFromIds(ids) {
    const tiers = ids.map(id => rarityTier(ING_BY_ID[id]?.rarity));
    let best = "common";
    for (const t of tiers) {
      if (rarityRank(t) > rarityRank(best)) best = t;
    }
    return best;
  }

  function computeDcFromSelection() {
    const ids = selectedBrewIds();
    if (ids.length < 2) return null;
    const tier = brewRarityTierFromIds(ids);
    let dc = dcForRarityTier(tier);
    if (el("useThird").checked && ids.length === 3) dc += 2;
    return { dc, tier };
  }

  function updateBrewDcDisplay() {
    const out = el("brewDc");
    if (!out) return;

    const ids = selectedBrewIds();
    if (ids.length < 2) {
      out.textContent = "DC: (choose ingredients)";
      return;
    }

    const info = computeDcFromSelection();
    if (!info) {
      out.textContent = "DC: (choose ingredients)";
      return;
    }

    const rarityText = info.tier.charAt(0).toUpperCase() + info.tier.slice(1);
    const plus = (el("useThird").checked && ids.length === 3) ? " (+2 for 3 ingredients)" : "";
    out.textContent = `DC: ${info.dc} (Base ${rarityText})${plus}`;
  }

  function effectConfigForName(effectName) {
    const key = normKey(effectName);
    const direct = EFFECTS_CONFIG[key];
    if (direct) return direct;

    // Try exact raw key fallback (in case user stores original capitalization)
    for (const [k,v] of Object.entries(EFFECTS_CONFIG)) {
      if (normKey(k) === key) return v;
    }
    return null;
  }

  function valueForEffectAtRarity(effectName, rarityTierStr) {
    const cfg = effectConfigForName(effectName);
    const tier = normKey(rarityTierStr);
    const fallback = { gp:0, sp:0, cp:0 };
    const c = cfg?.valueByRarity?.[tier];
    return c ? normalizeCoins(c) : fallback;
  }

  function baseNoteForEffectAtRarity(effectName, rarityTierStr) {
    const cfg = effectConfigForName(effectName);
    const tier = normKey(rarityTierStr);
    return cfg?.baseNoteByRarity?.[tier] || "";
  }

  function bonusDiceForEffectAtRarity(effectName, rarityTierStr) {
    const cfg = effectConfigForName(effectName);
    const tier = normKey(rarityTierStr);
    return cfg?.bonusDiceByRarity?.[tier] || "";
  }

  function kindForEffect(effectName) {
    const cfg = effectConfigForName(effectName);
    const t = normKey(cfg?.type || "numeric");
    return (t === "non_numeric") ? "non_numeric" : "numeric";
  }

  function openBrewOverlay(payload) {
    pendingBrew = payload;
    const overlay = el("brewOverlay");
    const grid = el("overlayGrid");

    const rarityText = payload.rarity.charAt(0).toUpperCase() + payload.rarity.slice(1);
    const coinText = formatCoins(payload.price);
    el("overlaySub").textContent =
      `Quality: ${rarityText}. Value (rarity-only): ${coinText}. Enter the BONUS roll for each shared property.`;

    grid.innerHTML = "";

    for (const eff of payload.effects) {
      const row = document.createElement("div");
      row.className = "overlayRow";

      const top = document.createElement("div");
      top.className = "overlayRowTop";

      const left = document.createElement("div");
      const name = document.createElement("div");
      name.className = "overlayEffectName";
      name.textContent = eff.name;

      const pills = document.createElement("div");
      pills.style.display = "flex";
      pills.style.gap = "6px";
      pills.style.flexWrap = "wrap";

      const kindP = document.createElement("div");
      kindP.className = "pillMini";
      kindP.textContent = (eff.kind === "non_numeric") ? "Non-numeric" : "Numeric";

      const baseP = document.createElement("div");
      baseP.className = "pillMini";
      baseP.textContent = eff.baseNote ? `Base ${eff.baseNote}` : "Base (none)";

      const bonusP = document.createElement("div");
      bonusP.className = "pillMini";
      bonusP.textContent = eff.bonusDice ? `Bonus ${eff.bonusDice}` : "Bonus (none)";

      pills.appendChild(kindP);
      pills.appendChild(baseP);
      pills.appendChild(bonusP);

      left.appendChild(name);
      left.appendChild(pills);

      const right = document.createElement("div");
      right.className = "overlayHint";
      right.textContent = (eff.kind === "non_numeric")
        ? "Later: non-numeric. For now, you may leave blank."
        : "Enter the bonus result you rolled.";

      top.appendChild(left);
      top.appendChild(right);

      const inputRow = document.createElement("div");
      inputRow.className = "overlayInputRow";

      const input = document.createElement("input");
      input.inputMode = "numeric";
      input.placeholder = (eff.kind === "non_numeric") ? "Bonus (optional)" : "Bonus roll result";
      input.dataset.effectKey = eff.key;
      inputRow.appendChild(input);

      row.appendChild(top);
      row.appendChild(inputRow);

      grid.appendChild(row);
    }

    overlay.style.display = "flex";
  }

  function closeBrewOverlay() {
    pendingBrew = null;
    const overlay = el("brewOverlay");
    overlay.style.display = "none";
    el("overlayGrid").innerHTML = "";
  }

  function gatherOverlayInputs() {
    const grid = el("overlayGrid");
    const inputs = grid.querySelectorAll("input[data-effect-key]");
    const map = {};
    inputs.forEach(i => {
      const k = String(i.dataset.effectKey || "");
      const raw = String(i.value || "").trim();
      if (!raw) {
        map[k] = null;
        return;
      }
      const n = Number(raw);
      map[k] = Number.isFinite(n) ? Math.floor(n) : null;
    });
    return map;
  }

  function brewFailure() {
    const ids = selectedBrewIds();
    if (ids.length < 2) {
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      return;
    }

    if (!canSpend(ids)) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">Not enough in the Inventory.</div>
        <div class="muted" style="margin-top:6px;">You are missing one of the chosen ingredients.</div>
      `;
      toast("Not enough in the Inventory.", "bad");
      return;
    }

    spend(ids);
    renderIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    renderBrewDiscovered();
    fillConcentrateCraftChoices();
    updateBrewDcDisplay();

    el("mixResult").innerHTML = `
      <div style="color:rgba(255,190,120,0.95); font-weight:1000;">The brew fails.</div>
      <div class="muted" style="margin-top:6px;">Ingredients were consumed.</div>
    `;
    toast("Failed, ingredients consumed.", "bad");
  }

  function brewSuccess() {
    const ids = selectedBrewIds();
    const useThird = el("useThird").checked;

    if (ids.length < 2) {
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      return;
    }

    // UI already prevents duplicates, keep guards
    if (ids.length >= 2 && ids[0] === ids[1]) {
      toast("Choose two different ingredients.", "bad");
      el("mixResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Choose two different ingredients.</div>`;
      enforceDistinctMixing();
      return;
    }
    if (useThird && ids.length === 3) {
      if (ids[2] === ids[0] || ids[2] === ids[1]) {
        toast("Each ingredient must be different.", "bad");
        el("mixResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Each ingredient must be different.</div>`;
        enforceDistinctMixing();
        return;
      }
    }

    if (!canSpend(ids)) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">Not enough in the Inventory.</div>
        <div class="muted" style="margin-top:6px;">You are missing one of the chosen ingredients.</div>
      `;
      toast("Not enough in the Inventory.", "bad");
      return;
    }

    const shared = computeShared(ids);
    const rarity = brewRarityTierFromIds(ids);

    // Consume ingredients on success press
    spend(ids);
    renderIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    renderBrewDiscovered();
    fillConcentrateCraftChoices();
    updateBrewDcDisplay();

    if (shared.length === 0) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">The mixture fizzles.</div>
        <div class="muted" style="margin-top:6px;">Nothing in common, nothing takes hold.</div>
      `;
      toast("Fizzled.", "bad");
      return;
    }

    // Learn the shared properties (reveals)
    revealSharedAutomatically(ids, shared);
    recordRecipe(ids, shared);

    // Build overlay payload
    const effects = shared.map(name => {
      const kind = kindForEffect(name);
      const baseNote = baseNoteForEffectAtRarity(name, rarity);
      const bonusDice = bonusDiceForEffectAtRarity(name, rarity);
      const key = normKey(name);
      return { name, key, kind, baseNote, bonusDice };
    });

    // Price is sum of effect values at potion rarity
    let price = { gp:0, sp:0, cp:0 };
    for (const name of shared) {
      price = addCoins(price, valueForEffectAtRarity(name, rarity));
    }
    price = normalizeCoins(price);

    pendingBrew = {
      type: "concoction",
      rarity,
      effects,
      price
    };

    el("mixResult").innerHTML = `
      <div style="color:rgba(120,255,170,0.95); font-weight:1000;">Concoction possible.</div>
      <div class="muted" style="margin-top:6px;">Record your bonus rolls to store it in the bag.</div>
    `;
    toast("Success, record the result.", "good");

    openBrewOverlay(pendingBrew);
  }

  function saveOverlayToBag() {
    if (!pendingBrew) {
      closeBrewOverlay();
      return;
    }

    const inputs = gatherOverlayInputs();

    const effectsWithValues = pendingBrew.effects.map(e => {
      const bonus = inputs[e.key];
      return {
        name: e.name,
        kind: e.kind,
        bonus: (e.kind === "numeric") ? bonus : bonus, // placeholder, non-numeric later
        baseNote: e.baseNote || null,
        bonusDice: e.bonusDice || null
      };
    });

    addPotion({
      type: pendingBrew.type,
      rarity: pendingBrew.rarity,
      effects: effectsWithValues,
      price: pendingBrew.price
    }, 1);

    playSfx("sfxSuccess");

    const effText = effectsWithValues.map(x => x.name).join(", ");
    el("mixResult").innerHTML = `
      <div style="color:rgba(120,255,170,0.95); font-weight:1000;">Stored: Concoction of ${escapeHtml(effText)}</div>
      <div class="muted" style="margin-top:6px;">Added to Bag. Value: ${escapeHtml(formatCoins(pendingBrew.price))}</div>
    `;

    closeBrewOverlay();
    toast("Added to bag.", "good");
  }

  function exportNotes() {
    el("saveBox").value = JSON.stringify(
      { reveals: REVEALS, index: INDEX, recipes: RECIPES, concentrates: CONCENTRATES, potions: POTIONS },
      null,
      2
    );
    toast("Copied to the box.", "good");
  }

  function importNotes() {
    try {
      const parsed = JSON.parse(el("saveBox").value);
      if (!parsed || typeof parsed !== "object") throw new Error("bad");
      REVEALS = (parsed.reveals && typeof parsed.reveals === "object") ? parsed.reveals : {};

      const idx = (parsed.index && typeof parsed.index === "object") ? parsed.index : {};
      const clean = {};
      for (const [k,v] of Object.entries(idx)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) clean[String(k)] = Math.floor(n);
      }
      INDEX = clean;

      RECIPES = Array.isArray(parsed.recipes) ? parsed.recipes : [];

      const concs = (parsed.concentrates && typeof parsed.concentrates === "object") ? parsed.concentrates : {};
      const cleanConcs = {};
      for (const [k,v] of Object.entries(concs)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanConcs[String(k)] = Math.floor(n);
      }
      CONCENTRATES = cleanConcs;

      const pots = (parsed.potions && typeof parsed.potions === "object") ? parsed.potions : {};
      const cleanPots = {};
      for (const [k,v] of Object.entries(pots)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanPots[String(k)] = Math.floor(n);
      }
      POTIONS = cleanPots;

      saveLocal();
      renderIndex();
      fillBrewChoices();
      enforceDistinctMixing();
      renderBrewDiscovered();
      renderConcentratesInventory();
      fillConcentrateCraftChoices();
      renderBag();
      updateBrewDcDisplay();
      toast("Restored.", "good");
    } catch {
      toast("Those notes do not make sense.", "bad");
    }
  }

  function burnAll() {
    if (!confirm("Burn all notes on this device?")) return;
    REVEALS = {};
    INDEX = {};
    RECIPES = [];
    CONCENTRATES = {};
    POTIONS = {};
    saveLocal();
    renderIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    renderBrewDiscovered();
    renderConcentratesInventory();
    fillConcentrateCraftChoices();
    renderBag();
    updateBrewDcDisplay();
    showOnly("main");
    toast("Ashes and silence.", "bad");
  }

  /* Events */
  el("refreshBtn").addEventListener("click", fetchAllIngredients);

  el("openBookBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    showOnly("book");
    showBookSpread("index");
    renderIndex();
    renderConcentratesInventory();
  });

  el("openBrewBtn").addEventListener("click", () => {
    showOnly("brew");
    fillBrewChoices();
    enforceDistinctMixing();
    renderBrewDiscovered();
    fillConcentrateCraftChoices();
    updateBrewDcDisplay();
  });

  el("openBagBtn").addEventListener("click", () => {
    showOnly("bag");
    renderBag();
  });

  el("closeBookBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    showOnly("main");
  });

  el("backToIndexTopBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    currentIngredientId = null;
    showBookSpread("index");
    renderIndex();
    renderConcentratesInventory();
  });

  el("backFromBrewBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("backFromBagBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("recordBtn").addEventListener("click", () => {
    recordIngredientFromMark(el("markInput").value);
  });

  el("markInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") recordIngredientFromMark(el("markInput").value);
  });

  el("themeToggleBtn").addEventListener("click", () => {
    setTheme(theme === "wilderness" ? "town" : "wilderness");
  });

  el("useThird").addEventListener("change", () => {
    const on = el("useThird").checked;
    el("thirdSlot").classList.toggle("hidden", !on);
    fillBrewChoices();
    enforceDistinctMixing();
    updateBrewDcDisplay();
  });

  el("mixA").addEventListener("change", () => { enforceDistinctMixing(); fillBrewChoices(); });
  el("mixB").addEventListener("change", () => { enforceDistinctMixing(); fillBrewChoices(); });
  el("mixC").addEventListener("change", () => { enforceDistinctMixing(); fillBrewChoices(); });

  el("brewSuccessBtn").addEventListener("click", brewSuccess);
  el("brewFailBtn").addEventListener("click", brewFailure);

  el("exportBtn").addEventListener("click", exportNotes);
  el("importBtn").addEventListener("click", importNotes);
  el("wipeBtn").addEventListener("click", burnAll);

  el("concBaseSelect").addEventListener("change", fillConcentrateCraftChoices);
  el("concEffectSelect").addEventListener("change", fillConcentrateCraftChoices);
  el("concCraftBtn").addEventListener("click", craftConcentrate);

  // Overlay buttons
  el("overlayCancelBtn").addEventListener("click", () => {
    closeBrewOverlay();
    toast("Canceled recording.", "bad");
  });
  el("overlaySaveBtn").addEventListener("click", saveOverlayToBag);

  // Clicking outside closes overlay
  el("brewOverlay").addEventListener("click", (e) => {
    if (e.target === el("brewOverlay")) closeBrewOverlay();
  });

  setTheme("wilderness");
  showOnly("main");

  /* =========================================================
     POTION EFFECT CONFIG (EDIT ME)
     - Add new effects by copying the template below.
     - Keys are normalized internally (trim, collapse spaces,
       lowercase), so "restore health" matches "Restore Health".
     ========================================================= */

  /*
  TEMPLATE:

  "Effect Name Here": {
    type: "numeric", // "numeric" | "non_numeric"
    bonusDiceByRarity: {
      common: "1d6",
      uncommon: "1d8",
      rare: "1d12",
      legendary: "2d20"
    },
    baseNoteByRarity: {           // shown as reminder text only
      common: "2d4",
      uncommon: "4d4",
      rare: "8d4",
      legendary: "10d4"
    },
    valueByRarity: {              // rarity-only value for this effect
      common:    { gp: 0, sp: 5,  cp: 0 },
      uncommon:  { gp: 1, sp: 0,  cp: 0 },
      rare:      { gp: 5, sp: 0,  cp: 0 },
      legendary: { gp: 25, sp: 0, cp: 0 }
    }
  },
  */

  const EFFECTS_CONFIG = (() => {
    const cfg = {
      "Restore Health": {
        type: "numeric",
        bonusDiceByRarity: {
          common: "1d6",
          uncommon: "1d8",
          rare: "1d12",
          legendary: "2d20"
        },
        baseNoteByRarity: {
          common: "2d4",
          uncommon: "4d4",
          rare: "8d4",
          legendary: "10d4"
        },
        valueByRarity: {
          common:    { gp: 0, sp: 5,  cp: 0 },
          uncommon:  { gp: 1, sp: 0,  cp: 0 },
          rare:      { gp: 5, sp: 0,  cp: 0 },
          legendary: { gp: 25, sp: 0, cp: 0 }
        }
      }
    };

    // Normalize keys into a lookup table
    const out = {};
    for (const [k,v] of Object.entries(cfg)) out[normKey(k)] = v;
    return out;
  })();

  // Start after config is ready
  fetchAllIngredients();
</script>
</body>
</html>
