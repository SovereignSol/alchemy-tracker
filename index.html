<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Field Notes</title>

  <style>
    * { box-sizing: border-box; }

    :root{
      --ink:#000000;

      /* Dark app theme */
      --app-bg-1:#0a1020;
      --app-bg-2:#05070d;
      --panel-bg: rgba(26, 30, 40, 0.72);
      --panel-border: rgba(120, 130, 155, 0.38);
      --scene-bg: rgba(22, 26, 36, 0.70);
      --scene-border: rgba(120, 130, 155, 0.34);

      --edge:#d9c8aa;
      --good:#1f7a3a;
      --warn:#8a5a00;
      --bad:#8b1d2c;
      --shadow: 0 16px 40px rgba(0,0,0,0.38);
      --shadow2: 0 10px 24px rgba(0,0,0,0.32);

      --base: 13px;
      --small: 12px;
      --h1: 18px;

      /* Book UI scale */
      --book-ui: 0.84;

      /* Book overlay placement */
      --book-top: 19.8%;
      --book-bottom: 10%;
      --book-left: 3.6%;
      --book-right: 15.5%;
      --book-gap: 2.4%;
      --book-pad: 8px;

      /* Width control inside pages */
      --page-content-width: 78%;
      --line-width: 78%;
      --right-box-width: 96%;

      /* Right page shift: moves right-page content left without touching Index page */
      --right-page-shift: 150px;

      /* Right-page note box width */
      --right-notebox-width: 84%;

      --brew-maxw: 1000px;

      /* Bag */
      --bag-grid-cols: 5;
      --bag-tile: 120px;
      --bag-gap: 10px;

      /* Rarity colors */
      --rar-common: #1f7a3a;
      --rar-uncommon: #1e6bd6;
      --rar-rare: #7b3fe4;
      --rar-legendary: #d07a00;

      /* Currency colors */
      --c-gp: #d3b03b;
      --c-sp: #a8b0bb;
      --c-cp: #b86a3a;
    }

    html, body { height: 100%; width: 100%; margin: 0; padding: 0; }

    body{
      color: #e9edf6;
      background:
        radial-gradient(1100px 640px at 12% 0%, rgba(90,120,255,0.10), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(0,255,200,0.06), transparent 60%),
        linear-gradient(180deg, var(--app-bg-1), var(--app-bg-2));
      font-family: "Segoe Print","Bradley Hand","Comic Sans MS",cursive,system-ui;
      letter-spacing: 0.12px;
      font-size: var(--base);
      line-height: 1.15;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -webkit-touch-callout: none;
    }

    .wrap{ max-width: 1000px; margin: 0 auto; padding: 12px; }
    .hidden{ display:none !important; }

    button, input, select, textarea{
      font-size: var(--base);
      padding: 8px 9px;
      border-radius: 14px;
      border: 1px solid rgba(217,200,170,0.35);
      background: rgba(255,255,255,0.84);
      color: #000;
      outline: none;
      box-shadow: 0 2px 0 rgba(0,0,0,0.04) inset;
      font-family: inherit;
      line-height: 1.1;
      transition: all 120ms ease;
    }
    button:hover:not(:disabled){ transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.12); }
    button:active:not(:disabled){ transform: translateY(1px); box-shadow: 0 2px 0 rgba(0,0,0,0.04) inset; }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }
    input::placeholder, textarea::placeholder{ color: rgba(0,0,0,0.45); }

    .btn-primary{
      background: linear-gradient(180deg, rgba(122,62,31,0.92), rgba(122,62,31,0.78));
      color: #fff7ee;
      border-color: rgba(122,62,31,0.45);
      box-shadow: 0 10px 22px rgba(0,0,0,0.28);
      font-weight: 900;
    }
    .btn-primary:hover:not(:disabled){ box-shadow: 0 14px 28px rgba(0,0,0,0.32); }
    .btn-quiet{ background: rgba(255,255,255,0.70); color: #000; font-weight: 900; }
    input:focus, select:focus, textarea:focus{
      border-color: rgba(122,62,31,0.6);
      box-shadow: 0 0 0 3px rgba(122,62,31,0.15) inset;
    }

    .muted{ color: rgba(233,237,246,0.78); font-size: var(--small); }
    .title{
      display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin-bottom:10px; flex-wrap: wrap;
    }
    h1{
      margin:0; font-size: var(--h1); line-height:1.05;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-weight: 900; color: #f2f6ff;
    }
    .sub{ margin-top:4px; color: rgba(233,237,246,0.78); font-size: var(--small); }

    /* Main screen */
    .main-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: stretch;
    }
    @media (min-width: 860px){
      .main-grid{ grid-template-columns: 1fr 1fr; }
    }

    .panel{
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      box-shadow: var(--shadow2);
      overflow:hidden;
      min-height: 220px;
      position: relative;
      transition: transform 200ms ease, box-shadow 200ms ease;
    }
    .panel:hover{ transform: translateY(-2px); box-shadow: var(--shadow); }
    .panel button.overlayBtn{
      all: unset;
      cursor: pointer;
      display:block;
      width:100%;
      height:100%;
    }
    .panel img.coverArt{
      width:100%;
      height:100%;
      object-fit: contain;
      display:block;
      background: rgba(0,0,0,0.10);
      filter: saturate(1.02);
    }
    .panel .hint{
      position:absolute;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(20,22,30,0.88);
      box-shadow: 0 10px 20px rgba(0,0,0,0.32);
      font-weight: 900;
      color: #f2f6ff;
      font-size: var(--small);
      pointer-events: none;
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse{ 0%,100%{ opacity:0.8; } 50%{ opacity:1; } }

    /* Scene wrapper */
    .scene{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: var(--scene-bg);
      box-shadow: var(--shadow2);
      overflow:hidden;
      position: relative;
    }
    .sceneTopBar{
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px; padding: 9px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,18,26,0.62);
      flex-wrap: wrap;
    }
    .topLeftBtns{ display:flex; gap: 8px; align-items:center; flex-wrap: wrap; }

    .backBtn{
      display:flex; align-items:center; gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.72);
      box-shadow: 0 8px 16px rgba(0,0,0,0.32);
      font-weight: 900;
      color: #f2f6ff;
      font-size: var(--small);
      cursor: pointer;
    }
    .backBtn:hover{
      background: rgba(30,35,50,0.82);
      box-shadow: 0 10px 20px rgba(0,0,0,0.40);
    }
    .backBtn img{ width: 16px; height: 16px; opacity: 0.92; filter: brightness(1.2); }

    /* Book layout */
    .bookWrap{
      position: relative;
      width:100%;
      height: min(86vh, 800px);
      min-height: 560px;
      background: rgba(0,0,0,0.10);
    }
    .bookBg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: contain;
      opacity: 0.98;
      pointer-events:none;
      user-select:none;
      background: rgba(0,0,0,0.05);
    }

    .bookPages{
      position:absolute;
      top: var(--book-top);
      bottom: var(--book-bottom);
      left: var(--book-left);
      right: var(--book-right);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--book-gap);
      align-items: stretch;
      box-sizing: border-box;
      z-index: 2;

      transform: scale(var(--book-ui));
      transform-origin: top left;
      width: calc(100% / var(--book-ui));
      height: calc(100% / var(--book-ui));
    }

    /* Force all book text black */
    .bookPages, .bookPages *{
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }
    .bookPages .muted{
      opacity: 1 !important;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }

    @media (max-width: 760px){
      :root{
        --book-top: 21.5%;
        --book-bottom: 12%;
        --book-left: 4.5%;
        --book-right: 10%;
        --book-gap: 10px;
        --book-ui: 0.88;
        --page-content-width: 90%;
        --line-width: 90%;
        --right-box-width: 98%;
        --right-page-shift: 0px;
        --right-notebox-width: 96%;

        --bag-grid-cols: 3;
        --bag-tile: 108px;
      }
      .bookWrap{ height: auto; min-height: 920px; }
      .bookPages{ grid-template-columns: 1fr; gap: 12px; }
    }

    /* Page alignment */
    .page{
      border-radius: 14px;
      padding: var(--book-pad);
      background: rgba(255,255,255,0.00);
      overflow: hidden;
      min-height: 0;
      display:flex;
      justify-content:flex-start;
      flex-direction: column;
      align-items: stretch;
    }
    .pageInner{
      height: 100%;
      overflow:auto;
      padding-right: 6px;
      width: var(--page-content-width);
      max-width: var(--page-content-width);
      margin-left: 0;
      margin-right: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(0,0,0,0.2) transparent;
    }
    .pageInner::-webkit-scrollbar{ width: 4px; }
    .pageInner::-webkit-scrollbar-track{ background: transparent; }
    .pageInner::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.2); border-radius: 2px; }

    .pageRight{
      justify-content: center;
      align-items: flex-start;
      overflow: visible;
    }
    .pageRight .pageInner{
      width: var(--right-box-width);
      max-width: var(--right-box-width);
      margin-left: 0;
      margin-right: auto;
      padding-right: 10px;
      transform: translateX(calc(-1 * var(--right-page-shift)));
      display:flex;
      flex-direction: column;
      height: 100%;
    }

    .pageRight .noteBox{
      width: var(--right-notebox-width);
      margin-left: 0;
      margin-right: auto;
      flex: 1 1 auto;
      max-height: none;
      min-height: 360px;
    }
    .pageRight #recipesList.noteBox{ max-height: none !important; }

    .leftCentered{ width: var(--line-width); margin-left: auto; margin-right: auto; }

    .page h2{ margin: 0 0 6px 0; font-size: 13.5px; font-weight: 950; width: 100%; }
    .page h3{ margin: 10px 0 6px 0; font-size: 12px; font-weight: 950; width: 100%; }
    .hr{ height:1px; background: rgba(0,0,0,0.35); margin: 9px auto; width: var(--line-width); }

    .bookPages button, .bookPages input, .bookPages select, .bookPages textarea{
      font-size: var(--small);
      padding: 7px 8px;
      border-radius: 12px;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }
    .bookPages textarea::placeholder, .bookPages input::placeholder{
      opacity: 0.55 !important;
      -webkit-text-fill-color: rgba(0,0,0,0.55) !important;
    }
    .bookPages .btn-quiet, .bookPages button.backBtn, .bookPages button.smallBtn, .bookPages button.qtyBtn, .bookPages button#revealRandomBtn, .bookPages button#resetRevealsBtn{
      background: rgba(255,255,255,0.20);
      box-shadow: none;
      border: 1px solid rgba(0,0,0,0.18);
    }

    /* Index rows */
    .indexRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items:center;
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      box-shadow: none;
      margin: 0 auto 6px auto;
      width: var(--line-width);
      transition: background 150ms ease;
    }
    .indexRow:hover{ background: rgba(0,0,0,0.04); }
    @media (max-width: 420px){
      .indexRow{ grid-template-columns: 1fr; width: 100%; }
      .inventoryBox{ justify-content:flex-start; }
      .hr{ width: 100%; }
    }

    .ingNameBtn{
      all: unset;
      cursor:pointer;
      font-weight: 950;
      padding: 2px 3px;
      font-size: 12.5px;
      transition: opacity 120ms ease;
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
      opacity: 0.85;
    }
    .ingNameBtn:hover{ opacity: 1; }

    .inventoryBox{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 4px;
      flex-wrap: nowrap;
    }
    .count{
      min-width: 28px;
      text-align:center;
      font-weight: 950;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      font-size: var(--small);
    }
    .qtyBtn{
      padding: 4px 6px;
      border-radius: 10px;
      font-weight: 950;
      min-width: 28px;
      background: rgba(255,255,255,0.00);
      box-shadow:none;
      border: 1px solid rgba(0,0,0,0.22);
      font-size: var(--small);
    }

    /* Note box */
    .noteBox{
      border-radius: 12px;
      border: 1px dashed rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.18);
      padding: 8px 9px;
      font-size: var(--small);
      line-height: 1.2;
      white-space: pre-wrap;
      word-break: break-word;
      width: 100%;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Ingredient */
    .plantImg{
      width:100%;
      max-width: 250px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.12);
      box-shadow: none;
      display:block;
      margin: 0 auto;
    }
    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      font-size: var(--small);
      font-weight: 950;
      box-shadow:none;
    }
    .pill-rare{ border-color: rgba(31,122,58,0.40); }
    .pill-common{ border-color: rgba(122,62,31,0.40); }
    .pill-unknown{ border-color: rgba(0,0,0,0.22); }

    .effects{
      display:grid;
      gap: 7px;
      margin-top: 9px;
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }
    .effect-line{ display:grid; grid-template-columns: auto 1fr auto; gap: 6px; align-items: stretch; }
    .effect-text{
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px dashed rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.18);
      box-shadow: none;
      min-height: 16px;
      display:flex;
      align-items:center;
      font-size: var(--small);
      line-height: 1.15;
      word-break: break-word;
    }
    .effect-hidden{
      color: transparent !important;
      -webkit-text-fill-color: transparent !important;
      text-shadow: 0 0 10px rgba(0,0,0,0.55);
      user-select: none;
    }
    .smallBtn{
      padding: 4px 8px;
      font-size: var(--small);
      border-radius: 10px;
      font-weight: 950;
      background: rgba(255,255,255,0.00);
      box-shadow:none;
      border: 1px solid rgba(0,0,0,0.22);
      white-space: nowrap;
    }

    /* Brewing UI */
    .brewPage{
      max-width: var(--brew-maxw);
      margin: 0 auto;
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .brewImageFrame{
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid var(--scene-border);
      background: rgba(0,0,0,0.15);
      box-shadow: var(--shadow2);
    }
    .brewBgImg{
      width:100%;
      height: min(52vh, 520px);
      min-height: 300px;
      object-fit: contain;
      background: rgba(0,0,0,0.10);
      display:block;
    }
    .brewControls{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: rgba(18, 22, 30, 0.72);
      box-shadow: var(--shadow);
      padding: 12px;
      color:#f2f6ff;
    }
    .brewControls .muted{ color: rgba(233,237,246,0.78); }

    .brewTopRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .themeBtn{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.72);
      box-shadow: 0 8px 16px rgba(0,0,0,0.32);
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
      cursor: pointer;
    }
    .themeBtn:hover{
      background: rgba(30,35,50,0.82);
      box-shadow: 0 10px 20px rgba(0,0,0,0.40);
    }
    .themeBtn img{ width: 16px; height: 16px; opacity: 0.92; filter: brightness(1.2); }

    .brewGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 760px){
      .brewGrid{ grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    }
    .slotTitle{ font-weight: 950; margin-bottom: 6px; font-size: var(--small); color:#f2f6ff; }
    .slotBox{
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,0.20);
      background: rgba(255,255,255,0.06);
      padding: 10px;
    }
    .slotBox select{ width: 100%; }

    .discoveredList{ margin-top: 8px; display:flex; flex-wrap: wrap; gap: 6px; }
    .discoveredPill{
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      padding: 4px 8px;
      background: rgba(255,255,255,0.10);
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
    }

    .resultBox{
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      padding: 10px;
      font-size: var(--small);
      line-height: 1.2;
      color: #f2f6ff;
      min-height: 40px;
      display:flex;
      align-items:center;
    }
    select{
      background: rgba(255,255,255,0.86);
      color:#000;
      border: 1px solid rgba(255,255,255,0.25);
    }

    /* Bag UI */
    .bagWrap{
      position: relative;
      width:100%;
      height: min(86vh, 820px);
      min-height: 560px;
      background: rgba(0,0,0,0.10);
    }
    .bagBg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: contain;
      opacity: 0.98;
      pointer-events:none;
      user-select:none;
      background: rgba(0,0,0,0.05);
    }
    .bagGridArea{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 2;
    }
    .bagInner{
      width: min(900px, 96%);
      height: min(680px, 78vh);
      border-radius: 18px;
      border: 1px solid rgba(217,200,170,0.22);
      background: rgba(20,22,30,0.35);
      box-shadow: var(--shadow2);
      overflow:hidden;
      position: relative;
    }
    .bagHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(15,18,26,0.55);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .bagHeader h2{
      margin:0;
      font-size: 14px;
      font-weight: 1000;
      color: #f2f6ff;
    }
    .bagBody{
      padding: 12px;
      overflow:auto;
      height: calc(100% - 46px);
    }
    .bagGrid{
      display:grid;
      grid-template-columns: repeat(var(--bag-grid-cols), minmax(0, 1fr));
      gap: var(--bag-gap);
      align-items: start;
    }
    .bagTile{
      border-radius: 14px;
      border: 1px solid rgba(217,200,170,0.25);
      background: rgba(255,255,255,0.06);
      box-shadow: 0 10px 20px rgba(0,0,0,0.22);
      padding: 8px;
      min-height: var(--bag-tile);
      display:flex;
      flex-direction: column;
      gap: 6px;
    }
    .bagIconRow{
      display:flex;
      align-items:center;
      justify-content:center;
      height: 56px;
    }
    .bagIcon{
      width: 44px;
      height: 44px;
      object-fit: contain;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.35));
    }
    .bagText{
      text-align:center;
      display:flex;
      flex-direction: column;
      gap: 2px;
      padding: 0 2px;
    }
    .bagLineType{
      font-weight: 1000;
      color: #f2f6ff;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .bagLineEffect{
      font-weight: 1000;
      color: #f2f6ff;
      font-size: 12px;
      line-height: 1.05;
    }
    .bagLineRarity{
      font-size: 11px;
      font-weight: 1000;
      opacity: 0.95;
      text-transform: uppercase;
      letter-spacing: 0.35px;
    }
    .bagLineDice{
      font-size: 11px;
      font-weight: 950;
      opacity: 0.95;
    }
    .bagLineValue{
      font-size: 11px;
      font-weight: 950;
      opacity: 0.95;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .bagQtyRow{
      margin-top: auto;
      display:flex;
      gap: 6px;
      align-items:center;
      justify-content:center;
    }
    .bagQtyBtn{
      padding: 4px 7px;
      border-radius: 10px;
      font-weight: 1000;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: #f2f6ff;
      font-size: 12px;
      box-shadow: none;
    }
    .bagQty{
      min-width: 28px;
      text-align:center;
      font-weight: 1000;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #f2f6ff;
      font-size: 12px;
    }

    .rar-common{ color: var(--rar-common); }
    .rar-uncommon{ color: var(--rar-uncommon); }
    .rar-rare{ color: var(--rar-rare); }
    .rar-legendary{ color: var(--rar-legendary); }

    .gp{ color: var(--c-gp); font-weight: 1000; }
    .sp{ color: var(--c-sp); font-weight: 1000; }
    .cp{ color: var(--c-cp); font-weight: 1000; }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(20,22,30,0.95);
      border: 1px solid rgba(255,255,255,0.18);
      color: #f2f6ff;
      border-radius: 999px;
      padding: 9px 12px;
      box-shadow: var(--shadow);
      max-width: calc(100vw - 32px);
      display:none;
      z-index: 50;
      font-size: var(--small);
      font-weight: 950;
    }
    .toast.good{ border-color: rgba(31,122,58,0.40); }
    .toast.bad{ border-color: rgba(139,29,44,0.45); }

    /* Loading dot */
    .loading{
      display:inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #f2f6ff;
      animation: spin 800ms linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    /* Collapsible */
    details{
      border: 1px dashed rgba(0,0,0,0.25);
      border-radius: 14px;
      background: rgba(255,255,255,0.12);
      padding: 10px;
      margin-top: 12px;
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }
    details summary{
      cursor: pointer;
      font-weight: 950;
      list-style: none;
      font-size: var(--small);
    }
    details summary::-webkit-details-marker{ display:none; }
    .sigil{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      letter-spacing: 0.4px;
      font-size: 10px;
      opacity: 0.7;
    }

    /* Roll overlay */
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.62);
      display:none;
      align-items: center;
      justify-content: center;
      z-index: 80;
      padding: 14px;
    }
    .overlayCard{
      width: min(640px, 96vw);
      border-radius: 18px;
      border: 1px solid rgba(217,200,170,0.22);
      background: rgba(20,22,30,0.96);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .overlayHead{
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(15,18,26,0.72);
    }
    .overlayHead h2{
      margin:0;
      font-size: 14px;
      font-weight: 1000;
      color:#f2f6ff;
    }
    .overlayBody{
      padding: 12px;
      color:#f2f6ff;
    }
    .overlayBody .muted{ color: rgba(233,237,246,0.78); }
    .rollRows{
      margin-top: 10px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }
    .rollRow{
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      padding: 10px;
    }
    .rollRowTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .rollEffectName{
      font-weight: 1000;
      font-size: 13px;
    }
    .rollHint{
      font-size: 12px;
      opacity: 0.9;
      font-weight: 950;
    }
    .rollInputRow{
      margin-top: 8px;
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .rollInputRow input{
      width: 120px;
    }
    .overlayFoot{
      padding: 10px 12px;
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(15,18,26,0.72);
      flex-wrap: wrap;
    }

    @media (max-width: 480px){
      .title{ flex-direction: column; align-items: flex-start; }
      :root{ --bag-grid-cols: 3; --bag-tile: 106px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>Field Notes</h1>
        <div class="sub">A travel-worn record of leaves, powders, and quiet discoveries.</div>
      </div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button class="btn-quiet" id="refreshBtn" title="Pulls in any prepared ingredients.">
          <span id="refreshText">Update Notes</span>
        </button>
      </div>
    </div>

    <!-- MAIN -->
    <section id="viewMain">
      <div class="main-grid">
        <div class="panel" title="Open Field Notes">
          <button class="overlayBtn" id="openBookBtn" aria-label="Open Field Notes">
            <img class="coverArt" src="assets/ui/cover_closed.webp" alt="Field Notes cover" />
            <div class="hint">Tap to open</div>
          </button>
        </div>

        <div class="panel" title="Brewing">
          <button class="overlayBtn" id="openBrewBtn" aria-label="Open brewing">
            <img class="coverArt" src="assets/ui/cauldron_main.webp" alt="Brewing cauldron" />
            <div class="hint">Brewing</div>
          </button>
        </div>

        <div class="panel" title="Mixing">
          <button class="overlayBtn" id="openMixBtn" aria-label="Open mixing">
            <img class="coverArt" src="assets/ui/Mixer.webp" alt="Mixing kit" />
            <div class="hint">Mixing</div>
          </button>
        </div>

        <div class="panel" title="Bag">
          <button class="overlayBtn" id="openBagBtn" aria-label="Open bag">
            <img class="coverArt" src="assets/ui/Backpack.webp" alt="Backpack" />
            <div class="hint">Bag</div>
          </button>
        </div>
      </div>

      <div class="muted" style="margin-top:12px;">
        Your discoveries stay on this device.
      </div>
    </section>

    <!-- BOOK -->
    <section id="viewBook" class="scene hidden">
      <div class="sceneTopBar">
        <div class="topLeftBtns">
          <button class="backBtn" id="closeBookBtn" type="button" aria-label="Close book">
            <img src="assets/icons/arrow_back.webp" alt="" />
            Close
          </button>

          <button class="backBtn hidden" id="backToIndexTopBtn" type="button" aria-label="Back to Index">
            <img src="assets/icons/arrow_back.webp" alt="" />
            Index
          </button>
        </div>

        <div class="muted" id="bookStatus">Ready.</div>
      </div>

      <div class="bookWrap">
        <img class="bookBg" src="assets/ui/book_open.webp" alt="" />

        <!-- BOOK: INDEX SPREAD -->
        <div class="bookPages" id="spreadIndex">
          <div class="page">
            <div class="pageInner">
              <div class="leftCentered">
                <h2 style="text-align:center;">Index</h2>
                <div class="muted" style="text-align:center; margin-bottom:8px;">Tap a name to open its page.</div>
              </div>

              <div class="hr"></div>

              <div class="leftCentered">
                <h3>Record Ingredient</h3>
                <div class="muted">Write the mark you were given.</div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; width:100%;">
                  <input id="markInput" inputmode="numeric" placeholder="Mark" aria-label="Mark" />
                  <button class="btn-primary" id="recordBtn" type="button">Record</button>
                </div>
              </div>

              <div class="hr"></div>

              <div class="leftCentered">
                <h3 style="text-align:center;">Inventory</h3>
              </div>

              <div id="indexList"></div>

              <details>
                <summary>üìã Keep Safe</summary>
                <div class="muted" style="margin-top:8px;">
                  If you change devices, export your notes first.
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:9px;">
                  <button id="exportBtn" type="button">Export Notes</button>
                  <button id="importBtn" type="button">Import Notes</button>
                  <button id="wipeBtn" type="button">Burn All Notes</button>
                </div>
                <textarea id="saveBox" rows="6" style="width:100%; margin-top:9px;" placeholder="Notes appear here for export or import."></textarea>
                <div class="muted sigil" style="margin-top:8px;">
                  This page never sends your discoveries anywhere, unless you export them.
                </div>
              </details>
            </div>
          </div>

          <!-- RIGHT PAGE: Concentrates inventory -->
          <div class="page pageRight">
            <div class="pageInner">
              <h2>Concentrates</h2>
              <div class="muted">Honor inventory. Adjust as needed.</div>
              <div class="hr" style="width:100%;"></div>
              <div id="concentratesList" class="noteBox" style="max-height: 520px;"></div>
            </div>
          </div>
        </div>

        <!-- BOOK: INGREDIENT SPREAD -->
        <div class="bookPages hidden" id="spreadIngredient">
          <div class="page">
            <div class="pageInner">
              <div style="width:var(--line-width); margin: 0 auto;">
                <h2 id="ingName" style="margin:0;">Ingredient</h2>
              </div>

              <div style="margin-top:8px; width:var(--line-width); margin-left:auto; margin-right:auto; text-align:center;">
                <span class="pill" id="rarityPill">Unknown</span>
              </div>

              <div style="margin-top:8px; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <img class="plantImg" id="ingImage" alt="Ingredient" />
              </div>

              <div style="margin-top:9px; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <h3 style="margin:0 0 6px 0;">Description</h3>
                <div class="noteBox" id="ingNotes"></div>
              </div>

              <div style="margin-top:9px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <button id="revealRandomBtn" type="button">Reveal a Property</button>
                <button id="resetRevealsBtn" type="button" class="btn-quiet">Forget Properties</button>
              </div>

              <div class="effects" id="effectsList"></div>
            </div>
          </div>

          <div class="page pageRight">
            <div class="pageInner">
              <h2>Known Recipes</h2>
              <div class="muted">What you have learned so far.</div>
              <div class="hr" style="width:100%;"></div>
              <div id="recipesList" class="noteBox" style="max-height: 320px;"></div>
            </div>
          </div>
        </div>

      </div>
    </section>

    <!-- BREW -->
    <section id="viewBrew" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromBrewBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="brewStatus">Choose your ingredients.</div>
      </div>

      <div class="brewPage">
        <div class="brewImageFrame">
          <img class="brewBgImg" id="brewBg" src="assets/themes/wilderness_bg.webp" alt="" />
        </div>

        <div class="brewControls">
          <div class="brewTopRow">
            <button class="themeBtn" id="themeToggleBtn" type="button" aria-label="Switch theme">
              <img id="themeIcon" src="assets/icons/theme_wilderness.webp" alt="" />
              <span id="themeLabel">Wilderness</span>
            </button>

            <label style="display:flex; align-items:center; gap:7px; font-weight:950; color:#f2f6ff; font-size:var(--small); cursor:pointer;">
              <input type="checkbox" id="useThird" />
              Third ingredient (optional)
            </label>
          </div>

          <div class="brewGrid">
            <div class="slotBox">
              <div class="slotTitle">First ingredient</div>
              <select id="mixA"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discA"></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Second ingredient</div>
              <select id="mixB"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discB"></div>
            </div>

            <div class="slotBox hidden" id="thirdSlot">
              <div class="slotTitle">Third ingredient</div>
              <select id="mixC"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discC"></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Concoction DC</div>
              <div class="resultBox" id="dcBox" style="margin-top:0;">
                <div class="muted">Select ingredients to see DC.</div>
              </div>
              <div class="muted" style="margin-top:8px;">Success makes a concoction, failure still consumes.</div>

              <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
                <button class="btn-primary" id="brewSuccessBtn" type="button" style="flex:1 1 140px;">Brew (Success)</button>
                <button id="brewFailBtn" type="button" style="flex:1 1 140px;">Fail</button>
              </div>

              <div class="resultBox" id="mixResult" style="margin-top:10px;">
                <div class="muted">No mixture yet.</div>
              </div>
            </div>
          </div>

          <div class="hr" style="margin-top:12px; margin-bottom:12px; background: rgba(255,255,255,0.18); width: 100%;"></div>

          <div class="slotBox">
            <div class="slotTitle">Make Concentrate (costs 4 of an ingredient)</div>
            <div class="muted">Requires the property to be discovered on that ingredient.</div>

            <div style="display:grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-top:10px;">
              <div>
                <div class="muted" style="margin-bottom:6px;">Ingredient</div>
                <select id="concIng"></select>
              </div>
              <div>
                <div class="muted" style="margin-bottom:6px;">Property</div>
                <select id="concEffect"></select>
              </div>
              <div style="display:flex; align-items:flex-end;">
                <button class="btn-primary" id="makeConcBtn" type="button" style="width:100%;">Make</button>
              </div>
            </div>

            <div class="muted" style="margin-top:10px;">
              Concentrates go to your Bag and appear on the right page of the Index for tracking.
            </div>
          </div>

          <div class="muted" style="margin-top:12px;">
            Brewing draws from your Inventory. If you lack an ingredient, the attempt is refused.
          </div>
        </div>
      </div>
    </section>

    <!-- MIX -->
    <section id="viewMix" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromMixBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="mixStatus">Choose items to mix.</div>
      </div>

      <div class="brewPage">
        <div class="brewImageFrame">
          <img class="brewBgImg" id="mixBg" src="assets/ui/Mixer.webp" alt="" />
        </div>

        <div class="brewControls">
          <div class="brewTopRow">
            <div class="muted" style="font-weight:1000;">Mix potions and concentrates (cap 3 effects).</div>
          </div>

          <div class="brewGrid">
            <div class="slotBox">
              <div class="slotTitle">First item</div>
              <select id="mixItemA"></select>
              <div class="muted" style="margin-top:7px;">Details</div>
              <div class="resultBox" id="mixItemADetail" style="margin-top:7px;">
                <div class="muted">Select an item.</div>
              </div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Second item</div>
              <select id="mixItemB"></select>
              <div class="muted" style="margin-top:7px;">Details</div>
              <div class="resultBox" id="mixItemBDetail" style="margin-top:7px;">
                <div class="muted">Select an item.</div>
              </div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Mixing DC</div>
              <div class="resultBox" id="mixDcBox" style="margin-top:0;">
                <div class="muted">Select items to see DC.</div>
              </div>

              <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
                <button class="btn-primary" id="mixSuccessBtn" type="button" style="flex:1 1 140px;">Mix (Success)</button>
                <button id="mixFailBtn" type="button" style="flex:1 1 140px;">Fail</button>
              </div>

              <div class="resultBox" id="mixCombineResult" style="margin-top:10px;">
                <div class="muted">No mixture yet.</div>
              </div>
            </div>
          </div>

          <div class="muted" style="margin-top:12px;">
            Rules: no concentrate + concentrate, no potion + identical potion, and you cannot mix any potion marked as ‚Äúmixed‚Äù.
          </div>
        </div>
      </div>
    </section>

    <!-- BAG -->
    <section id="viewBag" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromBagBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="bagStatus">Packed.</div>
      </div>

      <div class="bagWrap">
        <img class="bagBg" src="assets/ui/Backpack_UI.webp" alt="" />
        <div class="bagGridArea">
          <div class="bagInner">
            <div class="bagHeader">
              <h2>Bag</h2>
              <div class="muted" id="bagCountText">0 items</div>
            </div>
            <div class="bagBody">
              <div class="bagGrid" id="bagGrid"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

  </div>

  <div class="toast" id="toast"></div>

  <div class="overlay" id="rollOverlay" role="dialog" aria-modal="true" aria-label="Roll overlay">
    <div class="overlayCard">
      <div class="overlayHead">
        <h2 id="rollTitle">Record Rolls</h2>
        <button class="btn-quiet" id="rollCancelBtn" type="button">Cancel</button>
      </div>
      <div class="overlayBody">
        <div class="muted" id="rollSubtitle">Roll the bonus dice for each effect, enter the result.</div>
        <div class="rollRows" id="rollRows"></div>
      </div>
      <div class="overlayFoot">
        <button class="btn-primary" id="rollConfirmBtn" type="button">Confirm</button>
      </div>
    </div>
  </div>

  <audio id="sfxPage" src="assets/sfx/page_turn.mp3" preload="auto"></audio>
  <audio id="sfxSuccess" src="assets/sfx/brew_success.mp3" preload="auto"></audio>

<script>
  const SUPABASE_URL = "https://yjelzojkirlzdnwftupz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqZWx6b2praXJsemRud2Z0dXB6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAzNTk0MTEsImV4cCI6MjA4NTkzNTQxMX0.5TCIyj5cAUlCAmNc2yBOIdpfNoN4NLqOOfcnBVbCzZA";

  const REST_BASE = `${SUPABASE_URL}/rest/v1`;
  const INGREDIENTS_ENDPOINT = `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&order=id.asc`;
  const INGREDIENT_BY_MARK = (mark) => `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&id=eq.${encodeURIComponent(mark)}&limit=1`;
  const PUBLIC_STORAGE_BASE = `${SUPABASE_URL}/storage/v1/object/public/`;

  const LOCAL_KEY = "field_notes_v2";
  let LOCAL = loadLocal();
  let REVEALS = LOCAL.reveals;
  let INDEX = LOCAL.index;
  let RECIPES = LOCAL.recipes;
  let BAG = LOCAL.bag;

  let ING_BY_ID = {};
  let currentIngredientId = null;
  let theme = "wilderness";
  let isFetching = false;

  const viewMain = document.getElementById("viewMain");
  const viewBook = document.getElementById("viewBook");
  const viewBrew = document.getElementById("viewBrew");
  const viewBag = document.getElementById("viewBag");
  const viewMix = document.getElementById("viewMix");

  const spreadIndex = document.getElementById("spreadIndex");
  const spreadIngredient = document.getElementById("spreadIngredient");

  const el = (id) => document.getElementById(id);

  const GENERIC_POTION_ICON = "assets/icons/Generic_Potion.webp";
  const GENERIC_CONC_ICON = "assets/icons/Generic_Concentrate.webp";

  function headers() {
    return { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${SUPABASE_ANON_KEY}` };
  }

  function saveLocal() {
    LOCAL = { reveals: REVEALS, index: INDEX, recipes: RECIPES, bag: BAG };
    localStorage.setItem(LOCAL_KEY, JSON.stringify(LOCAL));
  }

  function loadLocal() {
    const raw = localStorage.getItem(LOCAL_KEY);
    if (!raw) return { reveals: {}, index: {}, recipes: [], bag: {} };
    try {
      const parsed = JSON.parse(raw);
      const reveals = (parsed && typeof parsed.reveals === "object" && parsed.reveals) ? parsed.reveals : {};
      const index = (parsed && typeof parsed.index === "object" && parsed.index) ? parsed.index : {};
      const recipes = Array.isArray(parsed?.recipes) ? parsed.recipes : [];
      const bag = (parsed && typeof parsed.bag === "object" && parsed.bag) ? parsed.bag : {};
      const cleanIndex = {};
      for (const [k,v] of Object.entries(index)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanIndex[String(k)] = Math.floor(n);
      }
      const cleanBag = {};
      for (const [k,v] of Object.entries(bag)) {
        if (!v || typeof v !== "object") continue;
        const qty = Math.max(0, Math.floor(Number(v.qty) || 0));
        if (qty <= 0) continue;
        cleanBag[String(k)] = { ...v, qty };
      }
      return { reveals, index: cleanIndex, recipes, bag: cleanBag };
    } catch {
      return { reveals: {}, index: {}, recipes: [], bag: {} };
    }
  }

  function toast(msg, kind) {
    const t = el("toast");
    t.className = "toast";
    if (kind === "good") t.classList.add("good");
    if (kind === "bad") t.classList.add("bad");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => { t.style.display = "none"; }, 2200);
  }

  function playSfx(audioId) {
    const a = document.getElementById(audioId);
    if (!a) return;
    a.currentTime = 0;
    a.play().catch(() => {});
  }

  function showOnly(which) {
    viewMain.classList.add("hidden");
    viewBook.classList.add("hidden");
    viewBrew.classList.add("hidden");
    viewBag.classList.add("hidden");
    viewMix.classList.add("hidden");

    if (which === "main") viewMain.classList.remove("hidden");
    if (which === "book") viewBook.classList.remove("hidden");
    if (which === "brew") viewBrew.classList.remove("hidden");
    if (which === "bag") viewBag.classList.remove("hidden");
    if (which === "mix") viewMix.classList.remove("hidden");
  }

  function showBookSpread(which) {
    spreadIndex.classList.add("hidden");
    spreadIngredient.classList.add("hidden");
    el("backToIndexTopBtn").classList.toggle("hidden", which !== "ingredient");
    if (which === "index") spreadIndex.classList.remove("hidden");
    if (which === "ingredient") spreadIngredient.classList.remove("hidden");
  }

  function getImageUrl(image_path) {
    if (!image_path) return "";
    return `${PUBLIC_STORAGE_BASE}${image_path}?t=${Date.now()}`;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\"": "&quot;",
      "'": "&#39;"
    }[c]));
  }

  function placeholderImageDataUri(label) {
    const svg =
      `<svg xmlns='http://www.w3.org/2000/svg' width='800' height='800'>` +
      `<rect width='100%' height='100%' fill='%23ffffff'/>` +
      `<rect x='20' y='20' width='760' height='760' rx='38' ry='38' fill='%23f6f0e3' stroke='%23d9c8aa' stroke-width='6'/>` +
      `<text x='50%' y='52%' dominant-baseline='middle' text-anchor='middle' fill='%23000' font-size='42' font-family='Segoe Print,Bradley Hand,cursive'>${escapeHtml(label)}</text>` +
      `</svg>`;
    return "data:image/svg+xml," + encodeURIComponent(svg);
  }

  function rarityClass(r) {
    const v = String(r || "").trim().toLowerCase();
    if (!v) return "pill-unknown";
    if (v.includes("legend")) return "pill-rare";
    if (v.includes("rare") || v.includes("uncommon")) return "pill-rare";
    return "pill-common";
  }

  function rarityLabel(r) {
    const v = String(r || "").trim();
    return v ? v : "Unknown";
  }

  function normKey(s) {
    return String(s || "").trim().toLowerCase().replace(/\s+/g, " ");
  }

  function rarityKeyFromIngredient(r) {
    const v = String(r || "").trim().toLowerCase();
    if (v.includes("legend")) return "legendary";
    if (v.includes("rare")) return "rare";
    if (v.includes("uncommon")) return "uncommon";
    return "common";
  }

  function rarityRank(rk){
    return rk === "legendary" ? 4 : rk === "rare" ? 3 : rk === "uncommon" ? 2 : 1;
  }

  function maxRarityKey(keys){
    let best = "common";
    for (const k of keys){
      if (rarityRank(k) > rarityRank(best)) best = k;
    }
    return best;
  }

  function dcForRarity(rk){
    if (rk === "legendary") return 18;
    if (rk === "rare") return 15;
    if (rk === "uncommon") return 12;
    return 10;
  }

  function rarityCssClass(rk){
    return rk === "legendary" ? "rar-legendary" : rk === "rare" ? "rar-rare" : rk === "uncommon" ? "rar-uncommon" : "rar-common";
  }

  function rarityDisplay(rk){
    return rk === "legendary" ? "Legendary" : rk === "rare" ? "Rare" : rk === "uncommon" ? "Uncommon" : "Common";
  }

  function fmtCoins(v){
    const gp = Number(v?.gp)||0, sp = Number(v?.sp)||0, cp = Number(v?.cp)||0;
    const parts = [];
    if (gp) parts.push(`<span class="gp">${gp}gp</span>`);
    if (sp) parts.push(`<span class="sp">${sp}sp</span>`);
    if (cp) parts.push(`<span class="cp">${cp}cp</span>`);
    return parts.length ? parts.join(" ") : `<span class="muted">0gp</span>`;
  }

  function addCoins(a,b){
    return {
      gp: (Number(a?.gp)||0) + (Number(b?.gp)||0),
      sp: (Number(a?.sp)||0) + (Number(b?.sp)||0),
      cp: (Number(a?.cp)||0) + (Number(b?.cp)||0),
    };
  }

  function effectCfg(effectName){
    const k = normKey(effectName);
    return EFFECTS_CONFIG[k] || null;
  }

  function getEffectValue(effectName, rarityKey, kind){
    const cfg = effectCfg(effectName);
    if (!cfg) return { gp:0, sp:0, cp:0 };

    if (kind === "concentrate"){
      const map = cfg.concentrateValueByRarity || cfg.valueByRarity || {};
      return map[rarityKey] || { gp:0, sp:0, cp:0 };
    }

    const map = cfg.valueByRarity || {};
    return map[rarityKey] || { gp:0, sp:0, cp:0 };
  }

  function getBaseNote(effectName, rarityKey, kind){
    const cfg = effectCfg(effectName);
    const fallback = "2d4";
    if (!cfg) return fallback;

    if (kind === "concentrate"){
      const map = cfg.concentrateBaseNoteByRarity || {};
      return map[rarityKey] || fallback;
    }

    const map = cfg.baseNoteByRarity || {};
    return map[rarityKey] || fallback;
  }

  function getBonusDice(effectName, rarityKey, kind){
    const cfg = effectCfg(effectName);
    const fallback = "1d6";
    if (!cfg) return fallback;

    if (kind === "concentrate"){
      const map = cfg.concentrateBonusDiceByRarity || {};
      return map[rarityKey] || fallback;
    }

    const map = cfg.bonusDiceByRarity || {};
    return map[rarityKey] || fallback;
  }

  function getIconPath(effectName, kind){
    const cfg = effectCfg(effectName);
    if (!cfg){
      return kind === "concentrate" ? GENERIC_CONC_ICON : GENERIC_POTION_ICON;
    }
    const p = (kind === "concentrate") ? cfg.concentrateIconPath : cfg.potionIconPath;
    return p || (kind === "concentrate" ? GENERIC_CONC_ICON : GENERIC_POTION_ICON);
  }

  function bagKeyFor(item){
    // stable key for stacking by exact roll string and effects ordering
    const kind = item.kind;
    const rarityKey = item.rarityKey || "common";
    const effs = (item.effects || []).map(String);
    const dicePairs = [];
    if (item.diceByEffect && typeof item.diceByEffect === "object"){
      for (const e of effs){
        if (item.diceByEffect[e]) dicePairs.push(`${e}=${item.diceByEffect[e]}`);
      }
    }
    return [
      kind,
      rarityKey,
      effs.join("|"),
      dicePairs.join("|"),
      item.mixed ? "mixed" : "pure"
    ].join("::");
  }

  function bagSetQty(key, qty){
    const q = Math.max(0, Math.floor(Number(qty)||0));
    if (!BAG[key]){
      if (q <= 0) return;
      toast("That item is missing.", "bad");
      return;
    }
    if (q <= 0){
      delete BAG[key];
    } else {
      BAG[key].qty = q;
    }
    saveLocal();
  }

  function bagAdd(item, qtyAdd){
    const key = bagKeyFor(item);
    if (BAG[key]){
      BAG[key].qty = Math.max(0, Math.floor((Number(BAG[key].qty)||0) + (Number(qtyAdd)||0)));
    } else {
      BAG[key] = { ...item, qty: Math.max(0, Math.floor(Number(qtyAdd)||0)) };
    }
    if (BAG[key].qty <= 0) delete BAG[key];
    saveLocal();
    renderBag();
    renderConcentratesRightPage();
    fillMixChoices();
  }

  function bagSpendKey(key){
    const it = BAG[key];
    if (!it) return false;
    const q = Math.max(0, Math.floor(Number(it.qty)||0));
    if (q <= 0) return false;
    if (q === 1) delete BAG[key];
    else it.qty = q - 1;
    saveLocal();
    return true;
  }

  function listBagKeys(){
    const keys = Object.keys(BAG);
    keys.sort((a,b) => {
      const A = BAG[a], B = BAG[b];
      const r = rarityRank(A?.rarityKey) - rarityRank(B?.rarityKey);
      if (r !== 0) return r;
      const ta = (A?.kind||"").localeCompare(B?.kind||"");
      if (ta !== 0) return ta;
      const ea = (A?.effects||[]).join("|");
      const eb = (B?.effects||[]).join("|");
      return ea.localeCompare(eb);
    });
    return keys;
  }

  function renderBag(){
    const grid = el("bagGrid");
    grid.innerHTML = "";
    const keys = listBagKeys();
    el("bagCountText").textContent = `${keys.length} item${keys.length===1?"":"s"}`;

    if (!keys.length){
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No potions or concentrates yet.";
      grid.appendChild(d);
      return;
    }

    for (const key of keys){
      const it = BAG[key];
      const kind = it.kind; // "potion" or "concentrate"
      const rarityKey = it.rarityKey || "common";
      const effs = Array.isArray(it.effects) ? it.effects : [];
      const qty = Number(it.qty)||0;

      const firstEffect = effs[0] || "Unknown";
      const icon = it.iconPath || getIconPath(firstEffect, kind);

      const tile = document.createElement("div");
      tile.className = "bagTile";

      const iconRow = document.createElement("div");
      iconRow.className = "bagIconRow";
      const img = document.createElement("img");
      img.className = "bagIcon";
      img.src = icon + "?t=" + Date.now();
      img.alt = "";
      img.onerror = () => { img.src = (kind === "concentrate" ? GENERIC_CONC_ICON : GENERIC_POTION_ICON) + "?t=" + Date.now(); };
      iconRow.appendChild(img);

      const text = document.createElement("div");
      text.className = "bagText";

      const lineType = document.createElement("div");
      lineType.className = "bagLineType";
      lineType.textContent = kind === "concentrate" ? "Concentrate" : "Concoction";

      const lineEffect = document.createElement("div");
      lineEffect.className = "bagLineEffect";
      lineEffect.textContent = effs.length ? firstEffect : "Unknown";

      const lineRarity = document.createElement("div");
      lineRarity.className = "bagLineRarity " + rarityCssClass(rarityKey);
      lineRarity.textContent = rarityDisplay(rarityKey);

      const lineDice = document.createElement("div");
      lineDice.className = "bagLineDice";
      if (kind === "concentrate"){
        lineDice.textContent = "‚Äî";
      } else {
        const diceBy = it.diceByEffect && typeof it.diceByEffect === "object" ? it.diceByEffect : {};
        const diceStr = diceBy[firstEffect] || "‚Äî";
        lineDice.textContent = diceStr;
      }

      const lineValue = document.createElement("div");
      lineValue.className = "bagLineValue";
      lineValue.innerHTML = fmtCoins(it.value || {gp:0,sp:0,cp:0});

      text.appendChild(lineType);
      text.appendChild(lineEffect);
      text.appendChild(lineRarity);
      text.appendChild(lineDice);
      text.appendChild(lineValue);

      const qtyRow = document.createElement("div");
      qtyRow.className = "bagQtyRow";

      const minus = document.createElement("button");
      minus.className = "bagQtyBtn";
      minus.type = "button";
      minus.textContent = "‚àí";
      minus.addEventListener("click", () => {
        bagSetQty(key, qty - 1);
        renderBag();
        renderConcentratesRightPage();
        fillMixChoices();
      });

      const q = document.createElement("div");
      q.className = "bagQty";
      q.textContent = String(qty);

      const plus = document.createElement("button");
      plus.className = "bagQtyBtn";
      plus.type = "button";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        bagSetQty(key, qty + 1);
        renderBag();
        renderConcentratesRightPage();
        fillMixChoices();
      });

      qtyRow.appendChild(minus);
      qtyRow.appendChild(q);
      qtyRow.appendChild(plus);

      tile.appendChild(iconRow);
      tile.appendChild(text);
      tile.appendChild(qtyRow);

      grid.appendChild(tile);
    }
  }

  function renderConcentratesRightPage(){
    const box = el("concentratesList");
    const concKeys = listBagKeys().filter(k => BAG[k]?.kind === "concentrate");
    if (!concKeys.length){
      box.textContent = "No concentrates yet.";
      return;
    }

    // Render as rows in the note box so it stays sized and doesn't affect layout
    // We will render lightweight HTML as plain text-style block using innerHTML.
    const lines = concKeys.map((k) => {
      const it = BAG[k];
      const eff = (it.effects && it.effects[0]) ? it.effects[0] : "Unknown";
      const rk = it.rarityKey || "common";
      const qty = Number(it.qty)||0;
      return { k, eff, rk, qty };
    });

    // Build DOM for +/- inside noteBox (still within current layout)
    box.innerHTML = "";
    for (const row of lines){
      const line = document.createElement("div");
      line.style.display = "grid";
      line.style.gridTemplateColumns = "1fr auto";
      line.style.gap = "8px";
      line.style.alignItems = "center";
      line.style.padding = "7px 8px";
      line.style.borderRadius = "12px";
      line.style.border = "1px solid rgba(0,0,0,0.22)";
      line.style.background = "rgba(255,255,255,0.00)";
      line.style.marginBottom = "6px";

      const left = document.createElement("div");
      left.style.fontWeight = "950";
      left.style.fontSize = "12.5px";
      left.innerHTML = `Concentrate of ${escapeHtml(row.eff)} <span style="margin-left:6px;" class="${rarityCssClass(row.rk)}">${escapeHtml(rarityDisplay(row.rk))}</span>`;

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.alignItems = "center";
      right.style.justifyContent = "flex-end";
      right.style.gap = "4px";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "‚àí";
      minus.addEventListener("click", () => {
        bagSetQty(row.k, row.qty - 1);
        renderConcentratesRightPage();
        renderBag();
        fillMixChoices();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(row.qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        bagSetQty(row.k, row.qty + 1);
        renderConcentratesRightPage();
        renderBag();
        fillMixChoices();
      });

      right.appendChild(minus);
      right.appendChild(count);
      right.appendChild(plus);

      line.appendChild(left);
      line.appendChild(right);
      box.appendChild(line);
    }
  }

  async function fetchAllIngredients() {
    if (isFetching) return;
    isFetching = true;

    el("refreshBtn").disabled = true;
    el("refreshText").innerHTML = '<span class="loading"></span>';

    el("bookStatus").textContent = "Turning pages...";
    el("brewStatus").textContent = "Stirring embers...";

    try {
      const res = await fetch(INGREDIENTS_ENDPOINT, { headers: headers() });
      if (!res.ok) throw new Error(await res.text());
      const rows = await res.json();

      ING_BY_ID = {};
      for (const r of rows) {
        const idStr = String(r.id);
        ING_BY_ID[idStr] = r;
        if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
      }

      for (const idStr of Object.keys(INDEX)) {
        if (!ING_BY_ID[idStr]) delete INDEX[idStr];
      }

      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateChoices();

      renderBag();
      renderConcentratesRightPage();
      fillMixChoices();

      el("bookStatus").textContent = "Ready.";
      el("brewStatus").textContent = "Choose your ingredients.";
      toast("Notes updated.", "good");
    } catch (e) {
      el("bookStatus").textContent = "Could not update.";
      el("brewStatus").textContent = "Could not update.";
      toast("The ink smudged. Try again.", "bad");
      console.error(e);
    } finally {
      isFetching = false;
      el("refreshBtn").disabled = false;
      el("refreshText").textContent = "Update Notes";
    }
  }

  async function fetchOne(mark) {
    const res = await fetch(INGREDIENT_BY_MARK(mark), { headers: headers() });
    if (!res.ok) throw new Error(await res.text());
    const rows = await res.json();
    return rows?.[0] || null;
  }

  function sortedIndexIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id]);
    ids.sort((a,b) => Number(a) - Number(b));
    return ids;
  }

  function setQty(idStr, qty) {
    const q = Math.max(0, Math.floor(Number(qty) || 0));
    INDEX[String(idStr)] = q;
    saveLocal();
  }

  function renderIndex() {
    const wrap = el("indexList");
    wrap.innerHTML = "";

    const ids = sortedIndexIds();
    if (ids.length === 0) {
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No entries yet.";
      wrap.appendChild(d);
      return;
    }

    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      const name = row?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;

      const line = document.createElement("div");
      line.className = "indexRow";

      const left = document.createElement("div");
      const nameBtn = document.createElement("button");
      nameBtn.type = "button";
      nameBtn.className = "ingNameBtn";
      nameBtn.textContent = name;
      nameBtn.addEventListener("click", () => {
        playSfx("sfxPage");
        openIngredient(idStr);
      });
      left.appendChild(nameBtn);

      const right = document.createElement("div");
      right.className = "inventoryBox";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "‚àí";
      minus.addEventListener("click", () => {
        setQty(idStr, qty - 1);
        renderIndex();
        fillBrewChoices();
        renderBrewDiscovered();
        fillConcentrateChoices();
        updateDcDisplay();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        setQty(idStr, qty + 1);
        renderIndex();
        fillBrewChoices();
        renderBrewDiscovered();
        fillConcentrateChoices();
        updateDcDisplay();
      });

      right.appendChild(minus);
      right.appendChild(count);
      right.appendChild(plus);

      line.appendChild(left);
      line.appendChild(right);
      wrap.appendChild(line);
    }
  }

  async function recordIngredientFromMark(mark) {
    const clean = String(mark || "").replace(/\D/g, "");
    if (!clean) {
      toast("Enter a mark.", "bad");
      return;
    }

    if (ING_BY_ID[clean]) {
      if (INDEX[clean] === undefined) INDEX[clean] = 0;
      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateChoices();
      toast("Recorded.", "good");
      el("markInput").value = "";
      return;
    }

    try {
      el("recordBtn").disabled = true;
      const row = await fetchOne(clean);
      if (!row) {
        toast("That mark is unknown.", "bad");
        el("recordBtn").disabled = false;
        return;
      }
      ING_BY_ID[clean] = row;
      if (!REVEALS[clean]) REVEALS[clean] = [false,false,false,false];
      if (INDEX[clean] === undefined) INDEX[clean] = 0;
      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateChoices();
      toast("Recorded.", "good");
      el("markInput").value = "";
      el("recordBtn").disabled = false;
    } catch {
      toast("Could not read that mark.", "bad");
      el("recordBtn").disabled = false;
    }
  }

  function openIngredient(idStr) {
    currentIngredientId = idStr;
    showBookSpread("ingredient");
    renderIngredient(idStr);
  }

  function renderIngredient(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) {
      toast("That page is missing.", "bad");
      showBookSpread("index");
      return;
    }

    el("ingName").textContent = row.name || "Unknown Ingredient";
    const pill = el("rarityPill");
    pill.className = "pill " + rarityClass(row?.rarity);
    pill.textContent = rarityLabel(row?.rarity);

    const imgUrl = getImageUrl(row.image_path);
    el("ingImage").src = imgUrl || placeholderImageDataUri("No sketch");
    el("ingImage").onerror = () => {
      el("ingImage").src = placeholderImageDataUri(row.name);
    };

    el("ingNotes").textContent = row.notes ? String(row.notes) : "No notes written yet.";

    const effects = [row.effect_1,row.effect_2,row.effect_3,row.effect_4].map(v => v || "");
    const revealed = REVEALS[idStr] || [false,false,false,false];

    const list = el("effectsList");
    list.innerHTML = "";

    effects.forEach((eff, idx) => {
      const line = document.createElement("div");
      line.className = "effect-line";

      const label = document.createElement("div");
      label.className = "pill";
      label.textContent = `Property ${idx + 1}`;

      const text = document.createElement("div");
      text.className = "effect-text";
      text.textContent = eff || "(blank)";
      if (!revealed[idx]) text.classList.add("effect-hidden");

      const btn = document.createElement("button");
      btn.className = "smallBtn";
      btn.textContent = revealed[idx] ? "Known" : "Reveal";
      btn.disabled = revealed[idx];
      btn.addEventListener("click", () => {
        REVEALS[idStr][idx] = true;
        saveLocal();
        renderIngredient(idStr);
        fillConcentrateChoices();
        toast("Noted.", "good");
      });

      line.appendChild(label);
      line.appendChild(text);
      line.appendChild(btn);
      list.appendChild(line);
    });

    el("revealRandomBtn").onclick = () => {
      const hidden = [];
      for (let i = 0; i < 4; i++) if (!REVEALS[idStr][i]) hidden.push(i);
      if (hidden.length === 0) {
        toast("Nothing more to learn here.", "good");
        return;
      }
      const pick = hidden[Math.floor(Math.random() * hidden.length)];
      REVEALS[idStr][pick] = true;
      saveLocal();
      renderIngredient(idStr);
      fillConcentrateChoices();
      toast("Noted.", "good");
    };

    el("resetRevealsBtn").onclick = () => {
      REVEALS[idStr] = [false,false,false,false];
      saveLocal();
      renderIngredient(idStr);
      fillConcentrateChoices();
      toast("Forgotten.", "bad");
    };

    renderRecipesForIngredient(idStr);
  }

  function renderRecipesForIngredient(idStr) {
    const box = el("recipesList");
    const nameOf = (iid) => ING_BY_ID[iid]?.name || `Ingredient ${iid}`;

    const related = RECIPES.filter(r => Array.isArray(r.ids) && r.ids.includes(idStr));
    if (related.length === 0) {
      box.textContent = "No recipes recorded yet.";
      return;
    }

    const lines = related.map(r => {
      const parts = r.ids.map(x => nameOf(String(x)));
      const effects = Array.isArray(r.effects) ? r.effects : [];
      const effText = effects.length ? effects.join(", ") : "Unknown";
      return `‚Ä¢ ${parts.join(" + ")} = Concoction of ${effText}`;
    });

    box.textContent = lines.join("\n");
  }

  function setTheme(next) {
    theme = next;
    if (theme === "wilderness") {
      el("brewBg").src = "assets/themes/wilderness_bg.webp?t=" + Date.now();
      el("themeIcon").src = "assets/icons/Wilderness_Switch.webp?t=" + Date.now();
      el("themeLabel").textContent = "Wilderness";
    } else {
      el("brewBg").src = "assets/themes/town_bg.webp?t=" + Date.now();
      el("themeIcon").src = "assets/icons/Town_Switch.webp?t=" + Date.now();
      el("themeLabel").textContent = "Town";
    }
  }

  function availableForBrewIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id] && (Number(INDEX[id]) || 0) > 0);
    ids.sort((a,b) => Number(a) - Number(b));
    return ids;
  }

  function fillBrewChoices() {
    const a = el("mixA"), b = el("mixB"), c = el("mixC");
    const ids = availableForBrewIds();

    if (ids.length < 2) {
      a.innerHTML = "";
      b.innerHTML = "";
      c.innerHTML = "";
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      el("dcBox").innerHTML = `<div class="muted">Select ingredients to see DC.</div>`;
      renderBrewDiscovered();
      return;
    }

    const opts = ids.map(idStr => {
      const name = ING_BY_ID[idStr]?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;
      return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
    }).join("");

    const prevA = a.value, prevB = b.value, prevC = c.value;

    a.innerHTML = opts;
    b.innerHTML = opts;
    c.innerHTML = opts;

    a.value = ids.includes(prevA) ? prevA : ids[0];
    const bCandidate = ids.includes(prevB) ? prevB : ids.find(x => x !== a.value);
    b.value = (bCandidate && bCandidate !== a.value) ? bCandidate : (ids.find(x => x !== a.value) || ids[0]);

    const cDefault = ids.find(x => x !== a.value && x !== b.value) || ids[0];
    c.value = ids.includes(prevC) ? prevC : cDefault;
    if (el("useThird").checked && (c.value === a.value || c.value === b.value)) c.value = cDefault;

    renderBrewDiscovered();
    updateDcDisplay();
  }

  function enforceDistinctMixing() {
    const a = el("mixA"), b = el("mixB"), c = el("mixC");
    const ids = availableForBrewIds();

    if (a.value && b.value && a.value === b.value) {
      const next = ids.find(x => x !== a.value);
      if (next) b.value = next;
    }

    if (el("useThird").checked) {
      if (c.value === a.value || c.value === b.value) {
        const nextC = ids.find(x => x !== a.value && x !== b.value);
        if (nextC) c.value = nextC;
      }
      if (a.value === c.value) {
        const nextA = ids.find(x => x !== c.value && x !== b.value);
        if (nextA) a.value = nextA;
      }
      if (b.value === c.value) {
        const nextB = ids.find(x => x !== c.value && x !== a.value);
        if (nextB) b.value = nextB;
      }
    }

    renderBrewDiscovered();
    updateDcDisplay();
  }

  function discoveredEffectsFor(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) return [];
    const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
    const revealed = REVEALS[idStr] || [false,false,false,false];
    const known = [];
    for (let i = 0; i < 4; i++) {
      if (revealed[i] && effs[i]) known.push(String(effs[i]));
    }
    return known;
  }

  function renderDiscoveredInto(containerId, effects) {
    const wrap = el(containerId);
    wrap.innerHTML = "";
    if (!effects.length) {
      const s = document.createElement("div");
      s.className = "muted";
      s.textContent = "None yet.";
      wrap.appendChild(s);
      return;
    }
    effects.forEach(e => {
      const p = document.createElement("div");
      p.className = "discoveredPill";
      p.textContent = e;
      wrap.appendChild(p);
    });
  }

  function renderBrewDiscovered() {
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    renderDiscoveredInto("discA", aId ? discoveredEffectsFor(aId) : []);
    renderDiscoveredInto("discB", bId ? discoveredEffectsFor(bId) : []);
    if (useThird) renderDiscoveredInto("discC", cId ? discoveredEffectsFor(cId) : []);
  }

  function computeShared(ids) {
    const rows = ids.map(id => ING_BY_ID[id]).filter(Boolean);
    if (rows.length < 2) return [];
    const sets = rows.map(r => new Set([r.effect_1,r.effect_2,r.effect_3,r.effect_4].filter(Boolean)));
    let shared = sets[0];
    for (let i = 1; i < sets.length; i++) {
      shared = new Set([...shared].filter(x => sets[i].has(x)));
    }
    return [...shared];
  }

  function canSpend(ids) {
    const needed = {};
    for (const id of ids) needed[id] = (needed[id] || 0) + 1;
    for (const [id, n] of Object.entries(needed)) {
      const have = Number(INDEX[id]) || 0;
      if (have < n) return false;
    }
    return true;
  }

  function spend(ids) {
    const needed = {};
    for (const id of ids) needed[id] = (needed[id] || 0) + 1;
    for (const [id, n] of Object.entries(needed)) {
      setQty(id, (Number(INDEX[id]) || 0) - n);
    }
  }

  function revealSharedAutomatically(ids, shared) {
    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      if (!row) continue;
      const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
      if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
      for (let i = 0; i < 4; i++) {
        if (shared.includes(effs[i])) REVEALS[idStr][i] = true;
      }
    }
    saveLocal();
  }

  function recordRecipe(ids, shared) {
    const norm = ids.map(String).slice().sort((a,b) => Number(a) - Number(b));
    const key = norm.join("+") + "::" + shared.slice().sort().join("|");
    const exists = RECIPES.some(r =>
      (Array.isArray(r.ids) ? r.ids.slice().sort((a,b)=>Number(a)-Number(b)).join("+") : "") +
      "::" +
      (Array.isArray(r.effects)? r.effects.slice().sort().join("|"):"") === key
    );
    if (exists) return;
    RECIPES.push({ ids: norm, effects: shared.slice(), at: Date.now() });
    saveLocal();
  }

  function updateDcDisplay(){
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    const ids = [aId,bId].filter(Boolean);
    if (useThird && cId) ids.push(cId);

    if (ids.length < 2){
      el("dcBox").innerHTML = `<div class="muted">Select ingredients to see DC.</div>`;
      return;
    }
    const rarities = ids.map(id => rarityKeyFromIngredient(ING_BY_ID[id]?.rarity));
    const maxR = maxRarityKey(rarities);
    const base = dcForRarity(maxR);
    const dc = base + (useThird ? 2 : 0);
    el("dcBox").innerHTML = `
      <div style="font-weight:1000;">DC ${dc}</div>
      <div class="muted" style="margin-top:6px;">Base: ${base} (${escapeHtml(rarityDisplay(maxR))})${useThird ? " +2 (three ingredients)" : ""}</div>
    `;
  }

  // Roll overlay
  const overlay = el("rollOverlay");
  let overlayState = null;

  function openRollOverlay({ title, subtitle, effects, rarityKey, kind, onConfirm }){
    // effects: array of { name, mode: "new" | "enhance", existingDice?: "2d4+5" }
    overlayState = { title, subtitle, effects, rarityKey, kind, onConfirm };
    el("rollTitle").textContent = title;
    el("rollSubtitle").textContent = subtitle;

    const rows = el("rollRows");
    rows.innerHTML = "";

    effects.forEach((e, idx) => {
      const base = getBaseNote(e.name, rarityKey, kind);
      const bonusDice = getBonusDice(e.name, rarityKey, kind);
      const row = document.createElement("div");
      row.className = "rollRow";

      const top = document.createElement("div");
      top.className = "rollRowTop";

      const left = document.createElement("div");
      const name = document.createElement("div");
      name.className = "rollEffectName";
      name.textContent = e.name;

      const hint = document.createElement("div");
      hint.className = "rollHint";
      if (e.mode === "enhance"){
        hint.textContent = `Roll bonus (${bonusDice}), add to existing. Stored as ${base}+X.`;
      } else {
        hint.textContent = `Roll bonus (${bonusDice}). Stored as ${base}+X.`;
      }

      left.appendChild(name);
      left.appendChild(hint);

      const right = document.createElement("div");
      right.className = "muted";
      right.style.fontWeight = "950";
      right.textContent = `Base: ${base}`;

      top.appendChild(left);
      top.appendChild(right);

      const inRow = document.createElement("div");
      inRow.className = "rollInputRow";

      const input = document.createElement("input");
      input.inputMode = "numeric";
      input.placeholder = "Bonus result";
      input.setAttribute("data-idx", String(idx));

      const preview = document.createElement("div");
      preview.className = "muted";
      preview.style.fontWeight = "950";
      preview.textContent = e.mode === "enhance" ? `Current: ${e.existingDice || "‚Äî"}` : "";

      inRow.appendChild(input);
      if (e.mode === "enhance") inRow.appendChild(preview);

      row.appendChild(top);
      row.appendChild(inRow);

      rows.appendChild(row);
    });

    overlay.style.display = "flex";
  }

  function closeRollOverlay(){
    overlay.style.display = "none";
    overlayState = null;
  }

  el("rollCancelBtn").addEventListener("click", () => {
    toast("Canceled.", "bad");
    closeRollOverlay();
  });

  el("rollConfirmBtn").addEventListener("click", () => {
    if (!overlayState) return;

    const inputs = overlay.querySelectorAll("input[data-idx]");
    const results = [];
    for (const inp of inputs){
      const raw = String(inp.value||"").trim();
      if (!raw || !/^\d+$/.test(raw)){
        toast("Enter all bonus results.", "bad");
        return;
      }
      results.push(Number(raw));
    }

    try {
      overlayState.onConfirm(results);
      closeRollOverlay();
    } catch (e){
      console.error(e);
      toast("Could not record.", "bad");
    }
  });

  // Brewing (success/fail)
  function brewAttempt(isSuccess){
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    if (aId && bId && aId === bId) {
      toast("Choose two different ingredients.", "bad");
      el("mixResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Choose two different ingredients.</div>`;
      enforceDistinctMixing();
      return;
    }
    if (useThird) {
      if ((aId && cId && aId === cId) || (bId && cId && bId === cId)) {
        toast("Each ingredient must be different.", "bad");
        el("mixResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Each ingredient must be different.</div>`;
        enforceDistinctMixing();
        return;
      }
    }

    const ids = [aId,bId].filter(Boolean);
    if (useThird && cId) ids.push(cId);

    if (ids.length < 2) {
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      return;
    }

    if (!canSpend(ids)) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">Not enough in the Inventory.</div>
        <div class="muted" style="margin-top:6px;">You are missing one of the chosen ingredients.</div>
      `;
      toast("Not enough in the Inventory.", "bad");
      return;
    }

    const shared = computeShared(ids);

    // Always spend on success or fail attempts
    spend(ids);
    renderIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateChoices();

    if (!isSuccess){
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">The brew fails.</div>
        <div class="muted" style="margin-top:6px;">Ingredients were still consumed.</div>
      `;
      toast("Failed.", "bad");
      return;
    }

    if (shared.length === 0) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">The mixture fizzles.</div>
        <div class="muted" style="margin-top:6px;">Nothing in common, nothing takes hold.</div>
      `;
      toast("Fizzled.", "bad");
      return;
    }

    // Concoction rarity = rarest ingredient used (highest rank)
    const maxR = maxRarityKey(ids.map(id => rarityKeyFromIngredient(ING_BY_ID[id]?.rarity)));
    const effects = shared.slice(0,3);

    // compute values (sum of each effect value by rarity)
    let value = { gp:0, sp:0, cp:0 };
    for (const eff of effects){
      value = addCoins(value, getEffectValue(eff, maxR, "potion"));
    }

    // Overlay: ask for bonus results per effect
    openRollOverlay({
      title: "Record Bonus Rolls",
      subtitle: "Roll the bonus dice for each effect, then enter the bonus result. It will be recorded as base+bonus.",
      effects: effects.map(n => ({ name:n, mode:"new" })),
      rarityKey: maxR,
      kind: "potion",
      onConfirm: (bonusNums) => {
        const diceByEffect = {};
        effects.forEach((eff, i) => {
          const base = getBaseNote(eff, maxR, "potion");
          diceByEffect[eff] = `${base}+${bonusNums[i]}`;
        });

        revealSharedAutomatically(ids, effects);
        recordRecipe(ids, effects);

        playSfx("sfxSuccess");

        const iconPath = getIconPath(effects[0] || "Unknown", "potion");
        bagAdd({
          kind: "potion",
          effects: effects,
          rarityKey: maxR,
          diceByEffect,
          value,
          iconPath,
          mixed: false
        }, 1);

        el("mixResult").innerHTML = `
          <div style="color:rgba(120,255,170,0.95); font-weight:1000;">Concoction recorded.</div>
          <div class="muted" style="margin-top:6px;">Added to Bag.</div>
        `;
        toast("A concoction is born.", "good");
      }
    });
  }

  // Concentrates
  function fillConcentrateChoices(){
    const selIng = el("concIng");
    const selEff = el("concEffect");
    const ids = availableForBrewIds().filter(id => (Number(INDEX[id])||0) >= 4);

    if (!ids.length){
      selIng.innerHTML = `<option value="">(Need 4+ of an ingredient)</option>`;
      selEff.innerHTML = `<option value="">(No properties)</option>`;
      el("makeConcBtn").disabled = true;
      return;
    }

    const opts = ids.map(idStr => {
      const name = ING_BY_ID[idStr]?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;
      return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
    }).join("");

    const prev = selIng.value;
    selIng.innerHTML = opts;
    selIng.value = ids.includes(prev) ? prev : ids[0];

    function fillEffectsForSelected(){
      const id = selIng.value;
      const effs = discoveredEffectsFor(id);
      if (!effs.length){
        selEff.innerHTML = `<option value="">(No discovered properties)</option>`;
        el("makeConcBtn").disabled = true;
        return;
      }
      selEff.innerHTML = effs.map(e => `<option value="${escapeHtml(e)}">${escapeHtml(e)}</option>`).join("");
      el("makeConcBtn").disabled = false;
    }

    fillEffectsForSelected();
    selIng.onchange = fillEffectsForSelected;
  }

  function makeConcentrate(){
    const id = el("concIng").value;
    const eff = el("concEffect").value;
    if (!id || !eff){
      toast("Pick an ingredient and property.", "bad");
      return;
    }
    const have = Number(INDEX[id])||0;
    if (have < 4){
      toast("Need 4 of that ingredient.", "bad");
      return;
    }

    // spend 4
    setQty(id, have - 4);
    renderIndex();
    fillBrewChoices();
    renderBrewDiscovered();
    fillConcentrateChoices();
    updateDcDisplay();

    // rarity from ingredient
    const rk = rarityKeyFromIngredient(ING_BY_ID[id]?.rarity);

    // concentrate value: use concentrateValueByRarity if present, otherwise force fallback to valueByRarity
    const value = getEffectValue(eff, rk, "concentrate");

    const iconPath = getIconPath(eff, "concentrate");
    bagAdd({
      kind: "concentrate",
      effects: [eff],
      rarityKey: rk,
      diceByEffect: {},
      value,
      iconPath,
      mixed: false
    }, 1);

    playSfx("sfxSuccess");
    toast("Concentrate made.", "good");
  }

  // Mixing
  function bagOptionLabel(key){
    const it = BAG[key];
    if (!it) return "Unknown";
    const kind = it.kind;
    const rk = it.rarityKey || "common";
    const effs = Array.isArray(it.effects) ? it.effects : [];
    const first = effs[0] || "Unknown";
    const qty = Number(it.qty)||0;

    if (kind === "concentrate"){
      return `Concentrate of ${first} (${rarityDisplay(rk)}) [${qty}]`;
    }
    const dice = (it.diceByEffect && it.diceByEffect[first]) ? it.diceByEffect[first] : "‚Äî";
    return `Concoction of ${first} ${dice} (${rarityDisplay(rk)}) [${qty}]`;
  }

  function fillMixChoices(){
    const a = el("mixItemA");
    const b = el("mixItemB");

    const keys = listBagKeys().filter(k => (Number(BAG[k]?.qty)||0) > 0);
    if (keys.length < 2){
      a.innerHTML = "";
      b.innerHTML = "";
      el("mixCombineResult").innerHTML = `<div class="muted">Add at least two items to your Bag.</div>`;
      el("mixDcBox").innerHTML = `<div class="muted">Select items to see DC.</div>`;
      el("mixItemADetail").innerHTML = `<div class="muted">Select an item.</div>`;
      el("mixItemBDetail").innerHTML = `<div class="muted">Select an item.</div>`;
      return;
    }

    const opts = keys.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(bagOptionLabel(k))}</option>`).join("");
    const prevA = a.value, prevB = b.value;

    a.innerHTML = opts;
    b.innerHTML = opts;

    a.value = keys.includes(prevA) ? prevA : keys[0];
    const bCandidate = keys.includes(prevB) ? prevB : keys.find(x => x !== a.value);
    b.value = (bCandidate && bCandidate !== a.value) ? bCandidate : (keys.find(x => x !== a.value) || keys[0]);

    enforceDistinctMixItems();
  }

  function renderMixItemDetail(which){
    const key = which === "A" ? el("mixItemA").value : el("mixItemB").value;
    const box = which === "A" ? el("mixItemADetail") : el("mixItemBDetail");
    const it = BAG[key];
    if (!it){
      box.innerHTML = `<div class="muted">Select an item.</div>`;
      return;
    }
    const kind = it.kind;
    const rk = it.rarityKey || "common";
    const effs = Array.isArray(it.effects) ? it.effects : [];
    const first = effs[0] || "Unknown";

    let diceLine = "";
    if (kind === "potion"){
      const dice = (it.diceByEffect && it.diceByEffect[first]) ? it.diceByEffect[first] : "‚Äî";
      diceLine = `<div class="muted" style="margin-top:6px;">${escapeHtml(dice)}</div>`;
    } else {
      diceLine = `<div class="muted" style="margin-top:6px;">No roll recorded.</div>`;
    }

    box.innerHTML = `
      <div style="font-weight:1000;">${escapeHtml(kind === "concentrate" ? "Concentrate" : "Concoction")} of ${escapeHtml(first)}</div>
      <div class="muted" style="margin-top:6px;">Rarity: <span class="${rarityCssClass(rk)}" style="font-weight:1000;">${escapeHtml(rarityDisplay(rk))}</span></div>
      ${diceLine}
      <div class="muted" style="margin-top:6px;">Value: ${fmtCoins(it.value || {gp:0,sp:0,cp:0})}</div>
      <div class="muted" style="margin-top:6px;">Effects: ${escapeHtml(effs.join(", ") || "Unknown")}</div>
      ${it.mixed ? `<div class="muted" style="margin-top:6px; color: rgba(255,200,120,0.95); font-weight:1000;">Mixed item</div>` : ``}
    `;
  }

  function enforceDistinctMixItems(){
    const a = el("mixItemA");
    const b = el("mixItemB");
    const keys = listBagKeys().filter(k => (Number(BAG[k]?.qty)||0) > 0);

    if (a.value && b.value && a.value === b.value){
      const next = keys.find(x => x !== a.value);
      if (next) b.value = next;
    }

    renderMixItemDetail("A");
    renderMixItemDetail("B");
    updateMixDcDisplay();
  }

  function updateMixDcDisplay(){
    const aKey = el("mixItemA").value;
    const bKey = el("mixItemB").value;
    const A = BAG[aKey], B = BAG[bKey];
    if (!A || !B || aKey === bKey){
      el("mixDcBox").innerHTML = `<div class="muted">Select items to see DC.</div>`;
      return;
    }
    const maxR = maxRarityKey([A.rarityKey||"common", B.rarityKey||"common"]);
    const dc = dcForRarity(maxR) + 2;

    el("mixDcBox").innerHTML = `
      <div style="font-weight:1000;">DC ${dc}</div>
      <div class="muted" style="margin-top:6px;">Base: ${dcForRarity(maxR)} (${escapeHtml(rarityDisplay(maxR))}) +2 (mixing)</div>
    `;
  }

  function sameEffectSet(aEffs, bEffs){
    const A = (aEffs||[]).map(normKey).sort();
    const B = (bEffs||[]).map(normKey).sort();
    if (A.length !== B.length) return false;
    for (let i=0;i<A.length;i++) if (A[i] !== B[i]) return false;
    return true;
  }

  function mixAttempt(isSuccess){
    const aKey = el("mixItemA").value;
    const bKey = el("mixItemB").value;

    if (!aKey || !bKey || aKey === bKey){
      toast("Choose two different items.", "bad");
      return;
    }
    const A = BAG[aKey], B = BAG[bKey];
    if (!A || !B){
      toast("Missing item.", "bad");
      return;
    }

    // Rule: concentrates cannot be mixed with each other
    if (A.kind === "concentrate" && B.kind === "concentrate"){
      toast("Concentrate + concentrate is not allowed.", "bad");
      el("mixCombineResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Concentrate + concentrate is not allowed.</div>`;
      return;
    }

    // Rule: cannot mix potions that are already mixed
    if (A.kind === "potion" && A.mixed){ toast("That potion is already mixed.", "bad"); return; }
    if (B.kind === "potion" && B.mixed){ toast("That potion is already mixed.", "bad"); return; }

    // Rule: do not allow mixing two potions of the same exact effects
    if (A.kind === "potion" && B.kind === "potion"){
      if (sameEffectSet(A.effects, B.effects)){
        toast("Cannot mix identical potions.", "bad");
        el("mixCombineResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Cannot mix identical potions.</div>`;
        return;
      }
    }

    // Always spend on success or fail
    if (!bagSpendKey(aKey) || !bagSpendKey(bKey)){
      toast("Not enough quantity.", "bad");
      return;
    }

    if (!isSuccess){
      saveLocal();
      renderBag();
      renderConcentratesRightPage();
      fillMixChoices();
      enforceDistinctMixItems();
      el("mixCombineResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">The mix fails.</div>
        <div class="muted" style="margin-top:6px;">Items were still consumed.</div>
      `;
      toast("Failed.", "bad");
      return;
    }

    // Determine resulting potion
    const potion = (A.kind === "potion") ? A : B;
    const other = (A.kind === "potion") ? B : A;

    if (!potion || potion.kind !== "potion"){
      // If neither is a potion (should be impossible due to conc+conc check), treat as blocked
      toast("Need at least one potion.", "bad");
      return;
    }

    const baseEffects = Array.isArray(potion.effects) ? potion.effects.slice() : [];
    const otherEffects = Array.isArray(other.effects) ? other.effects.slice() : [];

    // Union, cap 3
    const union = [];
    const seen = new Set();
    for (const e of baseEffects){ const k = normKey(e); if (!k) continue; if (!seen.has(k)){ seen.add(k); union.push(e); } }
    for (const e of otherEffects){ const k = normKey(e); if (!k) continue; if (!seen.has(k)){ seen.add(k); union.push(e); } }

    if (union.length > 3){
      toast("Cap is 3 effects.", "bad");
      el("mixCombineResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Result would exceed 3 effects.</div>`;
      // Refund spends? honor system, but better to refund automatically:
      // Add back 1 to each item key by re-adding spent items if possible.
      // We can't restore exact keys if removed, but we can re-add minimal using cached data.
      bagAdd(A, 1);
      bagAdd(B, 1);
      return;
    }

    // Rarity: max of the two
    const maxR = maxRarityKey([potion.rarityKey||"common", other.rarityKey||"common"]);

    // Start with potion's dice and value
    const diceByEffect = { ...(potion.diceByEffect || {}) };
    let value = { ...(potion.value || {gp:0,sp:0,cp:0}) };
    value = addCoins(value, other.value || {gp:0,sp:0,cp:0});

    // If other is potion: carry over its dice for its effects
    // If other is concentrate: prompt roll overlay for new effect OR enhance if effect already exists
    if (other.kind === "potion"){
      const od = other.diceByEffect || {};
      for (const e of other.effects || []){
        if (!diceByEffect[e] && od[e]) diceByEffect[e] = od[e];
      }
      // New mixed potion created, mark mixed = true
      finalizeMixedPotion(union, maxR, diceByEffect, value, false);
      return;
    }

    // other is concentrate
    const concEff = (other.effects && other.effects[0]) ? other.effects[0] : "";
    if (!concEff){
      finalizeMixedPotion(union, maxR, diceByEffect, value, false);
      return;
    }

    const alreadyHas = baseEffects.some(e => normKey(e) === normKey(concEff));
    const effectsNeedingInput = [];

    if (alreadyHas){
      effectsNeedingInput.push({ name: findCanonicalEffectName(baseEffects, concEff), mode: "enhance", existingDice: diceByEffect[findCanonicalEffectName(baseEffects, concEff)] || "" });
    } else {
      effectsNeedingInput.push({ name: concEff, mode: "new" });
    }

    openRollOverlay({
      title: "Record Bonus Roll",
      subtitle: "Roll the concentrate bonus dice, enter the bonus result. It will be recorded as base+bonus (or added to the existing bonus).",
      effects: effectsNeedingInput,
      rarityKey: maxR,
      kind: "concentrate",
      onConfirm: (nums) => {
        const bonus = nums[0];

        const effName = effectsNeedingInput[0].name;
        const base = getBaseNote(effName, maxR, "concentrate");
        const addValue = getEffectValue(effName, maxR, "concentrate");
        value = addCoins(value, addValue);

        if (alreadyHas){
          // enhance existing dice string by adding to bonus number
          const cur = diceByEffect[effName] || `${base}+0`;
          const parsed = parseDicePlus(cur);
          const newBonus = (parsed.bonus || 0) + bonus;
          diceByEffect[effName] = `${parsed.base || base}+${newBonus}`;
        } else {
          diceByEffect[effName] = `${base}+${bonus}`;
        }

        playSfx("sfxSuccess");
        finalizeMixedPotion(union, maxR, diceByEffect, value, true);
      }
    });
  }

  function parseDicePlus(s){
    const m = String(s||"").trim().match(/^([^+]+)\+(\d+)$/);
    if (!m) return { base: "", bonus: 0 };
    return { base: m[1].trim(), bonus: Number(m[2])||0 };
  }

  function findCanonicalEffectName(list, target){
    const tk = normKey(target);
    for (const e of list){
      if (normKey(e) === tk) return e;
    }
    return target;
  }

  function finalizeMixedPotion(effects, rarityKey, diceByEffect, value, played){
    const iconPath = getIconPath(effects[0] || "Unknown", "potion");
    bagAdd({
      kind: "potion",
      effects: effects,
      rarityKey,
      diceByEffect,
      value,
      iconPath,
      mixed: true
    }, 1);

    if (!played) playSfx("sfxSuccess");

    renderBag();
    renderConcentratesRightPage();
    fillMixChoices();
    enforceDistinctMixItems();

    el("mixCombineResult").innerHTML = `
      <div style="color:rgba(120,255,170,0.95); font-weight:1000;">Mixture recorded.</div>
      <div class="muted" style="margin-top:6px;">Added to Bag.</div>
    `;
    toast("Mixed.", "good");
  }

  // Wire up UI
  el("refreshBtn").addEventListener("click", fetchAllIngredients);

  el("openBookBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    showOnly("book");
    showBookSpread("index");
    renderIndex();
    renderConcentratesRightPage();
  });

  el("openBrewBtn").addEventListener("click", () => {
    showOnly("brew");
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateChoices();
    updateDcDisplay();
  });

  el("openBagBtn").addEventListener("click", () => {
    showOnly("bag");
    renderBag();
  });

  el("openMixBtn").addEventListener("click", () => {
    showOnly("mix");
    fillMixChoices();
    enforceDistinctMixItems();
  });

  el("closeBookBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    showOnly("main");
  });

  el("backToIndexTopBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    currentIngredientId = null;
    showBookSpread("index");
    renderIndex();
    renderConcentratesRightPage();
  });

  el("backFromBrewBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("backFromBagBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("backFromMixBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("recordBtn").addEventListener("click", () => {
    recordIngredientFromMark(el("markInput").value);
  });

  el("markInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") recordIngredientFromMark(el("markInput").value);
  });

  el("themeToggleBtn").addEventListener("click", () => {
    setTheme(theme === "wilderness" ? "town" : "wilderness");
  });

  el("useThird").addEventListener("change", () => {
    const on = el("useThird").checked;
    el("thirdSlot").classList.toggle("hidden", !on);
    fillBrewChoices();
    enforceDistinctMixing();
  });

  el("mixA").addEventListener("change", enforceDistinctMixing);
  el("mixB").addEventListener("change", enforceDistinctMixing);
  el("mixC").addEventListener("change", enforceDistinctMixing);

  el("brewSuccessBtn").addEventListener("click", () => brewAttempt(true));
  el("brewFailBtn").addEventListener("click", () => brewAttempt(false));

  el("makeConcBtn").addEventListener("click", makeConcentrate);

  el("mixItemA").addEventListener("change", enforceDistinctMixItems);
  el("mixItemB").addEventListener("change", enforceDistinctMixItems);

  el("mixSuccessBtn").addEventListener("click", () => mixAttempt(true));
  el("mixFailBtn").addEventListener("click", () => mixAttempt(false));

  el("exportBtn").addEventListener("click", () => {
    el("saveBox").value = JSON.stringify({ reveals: REVEALS, index: INDEX, recipes: RECIPES, bag: BAG }, null, 2);
    toast("Copied to the box.", "good");
  });

  el("importBtn").addEventListener("click", () => {
    try {
      const parsed = JSON.parse(el("saveBox").value);
      if (!parsed || typeof parsed !== "object") throw new Error("bad");
      REVEALS = (parsed.reveals && typeof parsed.reveals === "object") ? parsed.reveals : {};
      const idx = (parsed.index && typeof parsed.index === "object") ? parsed.index : {};
      const clean = {};
      for (const [k,v] of Object.entries(idx)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) clean[String(k)] = Math.floor(n);
      }
      INDEX = clean;
      RECIPES = Array.isArray(parsed.recipes) ? parsed.recipes : [];
      BAG = (parsed.bag && typeof parsed.bag === "object") ? parsed.bag : {};
      saveLocal();
      renderIndex();
      fillBrewChoices();
      enforceDistinctMixing();
      fillConcentrateChoices();
      updateDcDisplay();

      renderBag();
      renderConcentratesRightPage();
      fillMixChoices();

      toast("Restored.", "good");
    } catch {
      toast("Those notes do not make sense.", "bad");
    }
  });

  el("wipeBtn").addEventListener("click", () => {
    if (!confirm("Burn all notes on this device?")) return;
    REVEALS = {};
    INDEX = {};
    RECIPES = {};
    BAG = {};
    saveLocal();
    renderIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateChoices();
    updateDcDisplay();
    renderBag();
    renderConcentratesRightPage();
    fillMixChoices();
    showOnly("main");
    toast("Ashes and silence.", "bad");
  });

  setTheme("wilderness");
  showOnly("main");
  fetchAllIngredients();

   // -----------------------------
  // EFFECT CONFIG (edit me)
  //
  // ‚úÖ ADD NEW EFFECT ENTRIES ONLY INSIDE THE `cfg = { ... }` OBJECT BELOW.
  //    Copy an existing entry (like "Restore Health") and paste it as another sibling key.
  //
  // ‚ùå DO NOT add anything after the "DO NOT ADD BELOW THIS LINE" marker.
  //    If you add entries below that point, the script can break and the whole app stops working.
  // -----------------------------
  const EFFECTS_CONFIG = (() => {
    const cfg = {
      "Restore Health": {
        bonusDiceByRarity: { common: "1d6", uncommon: "1d8", rare: "1d12", legendary: "2d20" },
        baseNoteByRarity: { common: "2d4", uncommon: "2d4", rare: "2d4", legendary: "2d4" },

        concentrateBonusDiceByRarity: { common: "2d6", uncommon: "2d8", rare: "2d12", legendary: "4d20" },
        concentrateBaseNoteByRarity: { common: "4d4", uncommon: "4d4", rare: "4d4", legendary: "4d4" },

        valueByRarity: {
          common:    { gp: 0, sp: 5,  cp: 0 },
          uncommon:  { gp: 1, sp: 0,  cp: 0 },
          rare:      { gp: 5, sp: 0,  cp: 0 },
          legendary: { gp: 25, sp: 0, cp: 0 }
        },

        potionIconPath: "assets/icons/Red_Potion.webp",
        concentrateIconPath: "assets/icons/Red_Concentrate.webp"
      },

      "Resist Shock": {
        bonusDiceByRarity: { common: "1d6", uncommon: "1d8", rare: "1d12", legendary: "2d20" },
        baseNoteByRarity: { common: "2d4", uncommon: "4d4", rare: "8d4", legendary: "10d4" },

        concentrateBonusDiceByRarity: { common: "2d6", uncommon: "2d8", rare: "2d12", legendary: "4d20" },
        concentrateBaseNoteByRarity: { common: "4d4", uncommon: "8d4", rare: "16d4", legendary: "20d4" },

        valueByRarity: {
          common:    { gp: 0, sp: 5,  cp: 0 },
          uncommon:  { gp: 1, sp: 50, cp: 0 },
          rare:      { gp: 5, sp: 0,  cp: 0 },
          legendary: { gp: 50, sp: 0, cp: 0 }
        },

        potionIconPath: "assets/icons/Yellow_Resistance.webp",
        concentrateIconPath: "assets/icons/Yellow_Concentrate.webp"
      }

      // üëâ ADD NEW EFFECT ENTRIES ABOVE THIS LINE (inside cfg)
    };

    // ============================
    // ‚ùå DO NOT ADD ENTRIES BELOW THIS LINE
    // Only code belongs down here, never new effect blocks.
    // ============================
    const out = {};
    for (const [k, v] of Object.entries(cfg)) out[normKey(k)] = v;
    return out;
  })();

</script>
</body>
</html>
