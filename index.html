<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Alchemy Tracker</title>

  <!--
    NOTE (Sol):
    This is a full, self-contained single-file version you can keep in a separate document and paste from.
    It keeps your core behaviors, plus:
      - Cloud Save (Supabase) Commit + Recall with improved error reporting
      - Hagcraft (hidden tile until admin override), hexing potions, sigil display, click-to-reveal hex effect
      - Concentrate creation uses a roll overlay popup (mixing does NOT)
      - Mixed potions are hidden from mixing menu
      - Bag supports hexed/unhexed as distinct stack keys
  -->

  <style>
    :root{
      --bg1:#0a1020; --bg2:#05070d; --panel:rgba(26,30,40,.72);
      --edge:rgba(255,255,255,.18);
      --txt:#f2f6ff;
      --mut:rgba(233,237,246,.78);
      --good:#2fbf71; --warn:#f0b429; --bad:#ff4d4f;
      --shadow:0 14px 28px rgba(0,0,0,.35);
      --r:18px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      font-family: system-ui, "Segoe Print","Bradley Hand",cursive;
      color:var(--txt);
      background:
        radial-gradient(1100px 640px at 12% 0%, rgba(90,120,255,0.10), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(0,255,200,0.06), transparent 60%),
        linear-gradient(180deg,var(--bg1),var(--bg2));
      overflow-x:hidden;
    }
    .wrap{ max-width:1100px; margin:0 auto; padding:12px; }
    h1{ margin:0 0 8px 0; letter-spacing:.5px; text-transform:uppercase; }
    .muted{ color:var(--mut); font-size:12px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button,input,select,textarea{
      font:inherit;
      padding:9px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.85);
      color:#000;
      outline:none;
    }
    textarea{ border-radius:14px; }
    button{ cursor:pointer; background:rgba(20,22,30,.72); color:var(--txt); box-shadow:0 8px 16px rgba(0,0,0,.28); }
    button:hover{ transform:translateY(-1px); }
    button:disabled{ opacity:.55; cursor:not-allowed; transform:none; }
    .btn-primary{
      background:linear-gradient(180deg, rgba(122,62,31,.92), rgba(122,62,31,.78));
      border-color:rgba(122,62,31,.5);
      font-weight:900;
    }
    .card{
      border:1px solid rgba(255,255,255,.14);
      background:var(--panel);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:12px;
    }
    @media (max-width:900px){ .grid{ grid-template-columns:1fr; } }
    .tile{
      position:relative;
      min-height:180px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:14px;
    }
    .tile img{ width:100%; height:100%; object-fit:contain; opacity:.95; }
    .hint{
      position:absolute; left:10px; bottom:10px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.20);
      background:rgba(10,12,18,.78);
      font-weight:900; font-size:12px;
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px; border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(15,18,26,.62);
    }
    .hidden{ display:none !important; }

    /* Book */
    .bookBody{ padding:12px; display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width:900px){ .bookBody{ grid-template-columns:1fr; } }
    .page{
      border:1px dashed rgba(255,255,255,.18);
      border-radius:16px;
      padding:12px;
      background:rgba(255,255,255,.06);
      min-height:420px;
      overflow:auto;
    }
    .indexRow{
      display:grid; grid-template-columns: 1fr auto;
      gap:10px; align-items:center;
      padding:8px 10px; border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.10);
      margin-bottom:8px;
    }
    .ingBtn{
      all:unset; cursor:pointer;
      font-weight:950; text-decoration:underline; text-underline-offset:3px;
      opacity:.92;
    }
    .invBox{ display:flex; gap:6px; align-items:center; justify-content:flex-end; }
    .qtyBtn{ padding:6px 10px; border-radius:12px; font-weight:950; }
    .count{ min-width:34px; text-align:center; border-radius:999px; padding:6px 10px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.14); }

    .noteBox{
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.18);
      background:rgba(0,0,0,.12);
      padding:10px;
      white-space:pre-wrap;
      word-break:break-word;
      min-height:120px;
    }

    /* Bag */
    .bagGrid{
      display:grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width:1100px){ .bagGrid{ grid-template-columns: repeat(3, minmax(0,1fr)); } }
    @media (max-width:520px){ .bagGrid{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    .bagTile{
      position:relative;
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      background:rgba(255,255,255,.06);
      padding:10px;
      min-height:170px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .bagIconRow{ position:relative; height:44px; display:flex; align-items:center; justify-content:center; margin-top:6px; }
    .bagIcon{ width:34px; height:34px; object-fit:contain; filter: drop-shadow(0 6px 10px rgba(0,0,0,.35)); }
    .badge{
      position:absolute; top:8px; left:8px;
      padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(10,12,18,.55);
      font-size:10px; font-weight:1000;
      text-transform:uppercase;
    }
    .badgeR{ left:auto; right:8px; }
    .bagTitle{ font-weight:1000; text-transform:uppercase; letter-spacing:.4px; font-size:12px; text-align:center; }
    .bagLine{ font-size:12px; font-weight:900; text-align:center; opacity:.95; }
    .bagQtyRow{ margin-top:auto; display:flex; gap:6px; align-items:center; justify-content:center; }

    /* Hex sigil */
    .hexBtn{
      all:unset;
      cursor:pointer;
      position:absolute;
      top:10px;
      right:10px;
      width:22px; height:22px;
      display:flex; align-items:center; justify-content:center;
      border-radius:8px;
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.22);
      box-shadow: 0 8px 16px rgba(0,0,0,.28);
    }
    .hexBtn img{ width:18px; height:18px; object-fit:contain; pointer-events:none; }

    /* Overlay */
    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.62); z-index:100; padding:14px;
    }
    .overlayCard{
      width:min(720px, 96vw);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(20,22,30,.96);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .overlayHead,.overlayFoot{
      padding:10px 12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background:rgba(15,18,26,.72);
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .overlayFoot{ border-bottom:none; border-top:1px solid rgba(255,255,255,.10); justify-content:flex-end; }
    .overlayBody{ padding:12px; }
    .rollRow{
      border:1px dashed rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      border-radius:14px;
      padding:10px;
      margin-top:10px;
    }
    .overlayTextBlock{
      border:1px dashed rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      border-radius:14px;
      padding:10px;
      white-space:pre-wrap;
      word-break:break-word;
      font-size:12px;
      line-height:1.25;
    }

    /* Toast */
    .toast{
      position:fixed; left:50%; bottom:16px; transform:translateX(-50%);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      background:rgba(20,22,30,.95);
      padding:9px 12px;
      box-shadow:var(--shadow);
      display:none;
      font-weight:950;
      max-width:calc(100vw - 32px);
      z-index:120;
      font-size:12px;
    }
    .toast.good{ border-color:rgba(47,191,113,.45); }
    .toast.bad{ border-color:rgba(255,77,79,.45); }

    /* Simple value colors */
    .gp{ color:#d3b03b; font-weight:1000; }
    .sp{ color:#a8b0bb; font-weight:1000; }
    .cp{ color:#b86a3a; font-weight:1000; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Alchemy Tracker</h1>

    <div class="row" style="justify-content:space-between; margin-bottom:10px;">
      <div class="muted">Local-first. Export, or use Cloud Commit if you choose.</div>
      <button id="refreshBtn" type="button">Update Notes</button>
    </div>

    <!-- MAIN -->
    <section id="viewMain" class="card" style="padding:12px;">
      <div class="grid">
        <button class="card tile" id="openBookBtn" type="button" aria-label="Open Field Notes">
          <img src="assets/ui/cover_closed.webp" alt="Field Notes" />
          <div class="hint">Field Notes</div>
        </button>

        <button class="card tile" id="openBrewBtn" type="button" aria-label="Open Brewing">
          <img src="assets/ui/cauldron_main.webp" alt="Brewing" />
          <div class="hint">Brewing</div>
        </button>

        <button class="card tile" id="openMixBtn" type="button" aria-label="Open Mixing">
          <img src="assets/ui/Mixer.webp" alt="Mixing" />
          <div class="hint">Mixing</div>
        </button>

        <button class="card tile" id="openBagBtn" type="button" aria-label="Open Bag">
          <img src="assets/ui/Backpack.webp" alt="Bag" />
          <div class="hint">Bag</div>
        </button>

        <!-- HAGCRAFT tile (hidden until admin override) -->
        <button class="card tile hidden" id="openHagBtn" type="button" aria-label="Open Hagcraft">
          <img src="assets/ui/hagcraft_mat.webp" alt="Hagcraft" />
          <div class="hint">Hagcraft</div>
        </button>
      </div>

      <div class="row" style="margin-top:12px;">
        <span class="muted" style="font-weight:950;">Admin override</span>
        <input id="adminOverrideInput" type="text" autocomplete="off" autocapitalize="none" spellcheck="false" placeholder="Admin override" />
        <button id="adminOverrideBtn" type="button">Apply</button>
      </div>
    </section>

    <!-- BOOK -->
    <section id="viewBook" class="card hidden" style="margin-top:12px;">
      <div class="topbar">
        <div class="row">
          <button id="closeBookBtn" type="button">Close</button>
          <button id="backToIndexBtn" type="button" class="hidden">Index</button>
        </div>
        <div class="muted" id="bookStatus">Ready.</div>
      </div>

      <div class="bookBody">
        <div class="page">
          <h2 style="margin:0 0 8px 0;">Index</h2>

          <div class="row">
            <input id="markInput" inputmode="numeric" placeholder="Mark" />
            <button class="btn-primary" id="recordBtn" type="button">Record</button>
          </div>

          <div style="height:10px;"></div>
          <div id="indexList"></div>

          <details style="margin-top:12px;">
            <summary style="cursor:pointer; font-weight:950;">Keep Safe</summary>
            <div style="height:8px;"></div>

            <div class="row">
              <button id="exportBtn" type="button">Export Notes</button>
              <button id="importBtn" type="button">Import Notes</button>
              <button id="wipeBtn" type="button">Burn All Notes</button>
            </div>

            <div style="height:12px;"></div>
            <div class="muted" style="font-weight:950;">Cloud (Supabase)</div>
            <div class="muted" style="margin-top:6px;">
              Use a Signature to commit and recall one saved set. Each unique Signature maps to its own slot.
            </div>

            <div class="row" style="margin-top:10px;">
              <input id="cloudSignature" type="text" autocomplete="off" autocapitalize="none" spellcheck="false" placeholder="Signature" style="min-width:240px;" />
              <button id="cloudCommitBtn" type="button">Commit to memory</button>
              <button id="cloudRecallBtn" type="button">Recall information</button>
            </div>

            <textarea id="saveBox" rows="8" style="width:100%; margin-top:10px;" placeholder="Notes appear here for export or import."></textarea>
          </details>
        </div>

        <div class="page">
          <h2 style="margin:0 0 8px 0;">Right Page</h2>
          <div id="rightPageBox" class="noteBox">Concentrates appear here while on Index.</div>
        </div>
      </div>
    </section>

    <!-- INGREDIENT PAGE -->
    <section id="viewIngredient" class="card hidden" style="margin-top:12px;">
      <div class="topbar">
        <button id="backFromIngredientBtn" type="button">Index</button>
        <div class="muted" id="ingredientStatus">Reading...</div>
      </div>

      <div class="bookBody">
        <div class="page">
          <h2 id="ingName" style="margin:0 0 8px 0;">Ingredient</h2>
          <img id="ingImage" alt="Ingredient" style="width:100%; max-width:320px; display:block; margin:0 auto; border-radius:16px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.06);" />
          <div style="height:10px;"></div>

          <div class="row" style="justify-content:center;">
            <button id="revealRandomBtn" type="button">Reveal a Property</button>
            <button id="resetRevealsBtn" type="button">Forget Properties</button>
          </div>

          <div id="effectsList" style="margin-top:12px;"></div>
        </div>

        <div class="page">
          <h2 style="margin:0 0 8px 0;">Description</h2>
          <div id="ingNotes" class="noteBox"></div>
        </div>
      </div>
    </section>

    <!-- BREW -->
    <section id="viewBrew" class="card hidden" style="margin-top:12px;">
      <div class="topbar">
        <button id="backFromBrewBtn" type="button">Back</button>
        <div class="muted" id="brewStatus">Choose your ingredients.</div>
      </div>

      <div style="padding:12px;">
        <div class="row" style="justify-content:space-between;">
          <div class="row">
            <button id="themeToggleBtn" type="button">Theme</button>
            <label class="muted" style="display:flex; gap:8px; align-items:center; font-weight:950;">
              <input id="useThird" type="checkbox" />
              Third ingredient (optional)
            </label>
          </div>
          <div id="dcBox" class="muted">Select ingredients to see DC.</div>
        </div>

        <div style="height:10px;"></div>

        <div class="grid" style="grid-template-columns: repeat(3, minmax(0,1fr));">
          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">First ingredient</div>
            <select id="mixA" style="width:100%; margin-top:6px;"></select>
            <div class="muted" style="margin-top:8px;">Discovered effects</div>
            <div id="discA" class="muted" style="margin-top:6px;"></div>
          </div>

          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Second ingredient</div>
            <select id="mixB" style="width:100%; margin-top:6px;"></select>
            <div class="muted" style="margin-top:8px;">Discovered effects</div>
            <div id="discB" class="muted" style="margin-top:6px;"></div>
          </div>

          <div class="card hidden" id="thirdSlot" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Third ingredient</div>
            <select id="mixC" style="width:100%; margin-top:6px;"></select>
            <div class="muted" style="margin-top:8px;">Discovered effects</div>
            <div id="discC" class="muted" style="margin-top:6px;"></div>
          </div>
        </div>

        <div style="height:12px;"></div>

        <div class="row">
          <button class="btn-primary" id="brewSuccessBtn" type="button">Brew (Success)</button>
          <button id="brewFailBtn" type="button">Fail</button>
          <div id="mixResult" class="muted">No mixture yet.</div>
        </div>

        <div style="height:14px;"></div>
        <div class="card" style="padding:12px;">
          <div class="muted" style="font-weight:950;">Make Concentrate (costs 4 of an ingredient)</div>
          <div class="muted" style="margin-top:6px;">Requires the property to be discovered on that ingredient.</div>

          <div class="grid" style="grid-template-columns: 1fr 1fr auto; margin-top:10px;">
            <div>
              <div class="muted" style="margin-bottom:6px;">Ingredient</div>
              <select id="concIng" style="width:100%;"></select>
            </div>
            <div>
              <div class="muted" style="margin-bottom:6px;">Property</div>
              <select id="concEffect" style="width:100%;"></select>
            </div>
            <div style="display:flex; align-items:end;">
              <button class="btn-primary" id="makeConcBtn" type="button" style="width:100%;">Make</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- MIX -->
    <section id="viewMix" class="card hidden" style="margin-top:12px;">
      <div class="topbar">
        <button id="backFromMixBtn" type="button">Back</button>
        <div class="muted" id="mixStatus">Choose items to mix.</div>
      </div>

      <div style="padding:12px;">
        <div class="grid" style="grid-template-columns: repeat(3, minmax(0,1fr));">
          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">First item</div>
            <select id="mixItemA" style="width:100%; margin-top:6px;"></select>
            <div id="mixItemADetail" class="muted" style="margin-top:8px;">Select an item.</div>
          </div>

          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Second item</div>
            <select id="mixItemB" style="width:100%; margin-top:6px;"></select>
            <div id="mixItemBDetail" class="muted" style="margin-top:8px;">Select an item.</div>
          </div>

          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Mixing DC</div>
            <div id="mixDcBox" class="muted" style="margin-top:8px;">Select items to see DC.</div>

            <div class="row" style="margin-top:10px;">
              <button class="btn-primary" id="mixSuccessBtn" type="button">Mix (Success)</button>
              <button id="mixFailBtn" type="button">Fail</button>
            </div>

            <div id="mixCombineResult" class="muted" style="margin-top:10px;">No mixture yet.</div>
          </div>
        </div>

        <div class="muted" style="margin-top:10px;">
          Rules: no concentrate + concentrate, no potion + identical potion, and you cannot mix any potion marked as “mixed”.
          Mixed potions are hidden from the mixing list.
        </div>
      </div>
    </section>

    <!-- HAGCRAFT -->
    <section id="viewHag" class="card hidden" style="margin-top:12px;">
      <div class="topbar">
        <button id="backFromHagBtn" type="button">Back</button>
        <div class="muted" id="hagStatus">Write the hex, then test the check.</div>
      </div>

      <div style="padding:12px;">
        <div class="card" style="padding:12px;">
          <div class="muted" style="font-weight:950;">Hagcraft</div>
          <div class="muted" style="margin-top:8px; line-height:1.35;">
            You may attempt a check to hex a potion in your Bag. The hex effect must be approved by the DM. Write the approved effect below.
            When a potion is hexed, it shows a sigil in the Bag. Clicking the sigil reveals the hex effect.
            Tell the DM which NPC (or PC) you plan to use it on. The DM will help conceal your Hag identity.
          </div>
        </div>

        <div style="height:12px;"></div>

        <div class="grid" style="grid-template-columns: repeat(3, minmax(0,1fr));">
          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Choose potion (unhexed only)</div>
            <select id="hagPotionSel" style="width:100%; margin-top:6px;"></select>
            <div id="hagPotionDetail" class="muted" style="margin-top:8px;">Select a potion.</div>
          </div>

          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Hex effect (DM-approved)</div>
            <textarea id="hagHexText" rows="8" style="width:100%; margin-top:8px;" placeholder="Write the hex effect here."></textarea>
            <div class="muted" style="margin-top:8px;">Hexing does not change dice. It only adds the sigil and the effect note.</div>
          </div>

          <div class="card" style="padding:12px;">
            <div class="muted" style="font-weight:950;">Hexing DC</div>
            <div id="hagDcBox" class="muted" style="margin-top:8px;">Select a potion to see DC.</div>

            <div class="row" style="margin-top:10px;">
              <button class="btn-primary" id="hagSuccessBtn" type="button">Hex (Success)</button>
              <button id="hagFailBtn" type="button">Fail</button>
            </div>

            <div id="hagResult" class="muted" style="margin-top:10px;">No hex yet.</div>
          </div>
        </div>

        <div class="muted" style="margin-top:10px;">
          Note: already hexed potions are hidden from this list.
        </div>
      </div>
    </section>

    <!-- BAG -->
    <section id="viewBag" class="card hidden" style="margin-top:12px;">
      <div class="topbar">
        <button id="backFromBagBtn" type="button">Back</button>
        <div class="muted" id="bagStatus">Packed.</div>
      </div>

      <div style="padding:12px;">
        <div class="row" style="justify-content:space-between;">
          <div class="muted" style="font-weight:950;">Bag</div>
          <div class="muted" id="bagCountText">0 items</div>
        </div>
        <div style="height:10px;"></div>
        <div class="bagGrid" id="bagGrid"></div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay" role="dialog" aria-modal="true">
    <div class="overlayCard">
      <div class="overlayHead">
        <div style="font-weight:1000;" id="overlayTitle">Overlay</div>
        <button id="overlayCancelBtn" type="button">Close</button>
      </div>
      <div class="overlayBody">
        <div class="muted" id="overlaySubtitle"></div>
        <div id="overlayBody"></div>
      </div>
      <div class="overlayFoot">
        <button class="btn-primary" id="overlayConfirmBtn" type="button">Confirm</button>
      </div>
    </div>
  </div>

<script>
/* -----------------------------
   SUPABASE
----------------------------- */
const SUPABASE_URL = "https://yjelzojkirlzdnwftupz.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqZWx6b2praXJsemRud2Z0dXB6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAzNTk0MTEsImV4cCI6MjA4NTkzNTQxMX0.5TCIyj5cAUlCAmNc2yBOIdpfNoN4NLqOOfcnBVbCzZA";

const REST_BASE = `${SUPABASE_URL}/rest/v1`;
const INGREDIENTS_ENDPOINT = `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&order=id.asc`;
const INGREDIENT_BY_MARK = (mark) => `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&id=eq.${encodeURIComponent(mark)}&limit=1`;
const PUBLIC_STORAGE_BASE = `${SUPABASE_URL}/storage/v1/object/public/`;

// Cloud Saves table (must exist): signature (text PK), data (jsonb), updated_at (timestamptz default now())
const SAVES_TABLE = "saves";
const SAVES_UPSERT_ENDPOINT = `${REST_BASE}/${SAVES_TABLE}?on_conflict=signature`;
const SAVES_SELECT_ENDPOINT = (sig) => `${REST_BASE}/${SAVES_TABLE}?select=data&signature=eq.${encodeURIComponent(sig)}&limit=1`;

function headers(extra){
  return {
    apikey: SUPABASE_ANON_KEY,
    Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
    ...(extra || {})
  };
}

/* -----------------------------
   Local state
----------------------------- */
const LOCAL_KEY = "alchemy_tracker_singlefile_v1";
let LOCAL = loadLocal();
let REVEALS = LOCAL.reveals;     // { [id]: [bool,bool,bool,bool] }
let INDEX   = LOCAL.index;       // { [id]: qty }
let RECIPES = LOCAL.recipes;     // stored, not shown
let BAG     = LOCAL.bag;         // { [bagKey]: item }
let HAG     = LOCAL.hag || { revealed:false };

let ING_BY_ID = {};
let currentIngredientId = null;
let theme = "wilderness";
let isFetching = false;

const ADMIN_PASSWORD = "deepvalleywood";
const HEX_SIGIL = "assets/ui/Hexed.webp";

const GENERIC_POTION_ICON = "assets/icons/Generic_Potion.webp";
const GENERIC_CONC_ICON   = "assets/icons/Generic_Concentrate.webp";

/* -----------------------------
   Helpers
----------------------------- */
const el = (id) => document.getElementById(id);

function saveLocal(){
  LOCAL = { reveals: REVEALS, index: INDEX, recipes: RECIPES, bag: BAG, hag: HAG };
  localStorage.setItem(LOCAL_KEY, JSON.stringify(LOCAL));
}

function loadLocal(){
  const raw = localStorage.getItem(LOCAL_KEY);
  if (!raw) return { reveals:{}, index:{}, recipes:[], bag:{}, hag:{revealed:false} };
  try{
    const p = JSON.parse(raw);
    return {
      reveals: (p?.reveals && typeof p.reveals === "object") ? p.reveals : {},
      index:   (p?.index && typeof p.index === "object") ? p.index : {},
      recipes: Array.isArray(p?.recipes) ? p.recipes : [],
      bag:     (p?.bag && typeof p.bag === "object") ? p.bag : {},
      hag:     (p?.hag && typeof p.hag === "object") ? p.hag : { revealed:false }
    };
  }catch{
    return { reveals:{}, index:{}, recipes:[], bag:{}, hag:{revealed:false} };
  }
}

function toast(msg, kind){
  const t = el("toast");
  t.className = "toast" + (kind === "good" ? " good" : kind === "bad" ? " bad" : "");
  t.textContent = msg;
  t.style.display = "block";
  clearTimeout(toast._timer);
  toast._timer = setTimeout(() => t.style.display = "none", 2200);
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[c]));
}

function normKey(s){
  return String(s || "").trim().toLowerCase().replace(/\s+/g, " ");
}

function getImageUrl(image_path){
  if (!image_path) return "";
  return `${PUBLIC_STORAGE_BASE}${image_path}`;
}

function placeholderImageDataUri(label){
  const svg =
    `<svg xmlns='http://www.w3.org/2000/svg' width='800' height='800'>`+
    `<rect width='100%' height='100%' fill='%230b1020'/>`+
    `<rect x='22' y='22' width='756' height='756' rx='40' fill='%23161b2c' stroke='%23ffffff33' stroke-width='6'/>`+
    `<text x='50%' y='52%' dominant-baseline='middle' text-anchor='middle' fill='%23f2f6ff' font-size='42' font-family='system-ui'>${escapeHtml(label)}</text>`+
    `</svg>`;
  return "data:image/svg+xml," + encodeURIComponent(svg);
}

function rarityKeyFromIngredient(r){
  const v = String(r || "").trim().toLowerCase();
  if (v.includes("legend")) return "legendary";
  if (v.includes("rare")) return "rare";
  if (v.includes("uncommon")) return "uncommon";
  return "common";
}
function rarityRank(rk){ return rk==="legendary"?4:rk==="rare"?3:rk==="uncommon"?2:1; }
function maxRarityKey(keys){
  let best="common";
  for (const k of keys){ if (rarityRank(k) > rarityRank(best)) best = k; }
  return best;
}
function dcForRarity(rk){
  if (rk==="legendary") return 18;
  if (rk==="rare") return 15;
  if (rk==="uncommon") return 12;
  return 10;
}
function rarityDisplay(rk){
  return rk==="legendary"?"Legendary":rk==="rare"?"Rare":rk==="uncommon"?"Uncommon":"Common";
}
function normalizeCoins(v){
  let gp = Math.max(0, Math.floor(Number(v?.gp)||0));
  let sp = Math.max(0, Math.floor(Number(v?.sp)||0));
  let cp = Math.max(0, Math.floor(Number(v?.cp)||0));
  if (cp >= 100){ sp += Math.floor(cp/100); cp = cp % 100; }
  if (sp >= 100){ gp += Math.floor(sp/100); sp = sp % 100; }
  return { gp, sp, cp };
}
function addCoins(a,b){
  return normalizeCoins({
    gp:(Number(a?.gp)||0)+(Number(b?.gp)||0),
    sp:(Number(a?.sp)||0)+(Number(b?.sp)||0),
    cp:(Number(a?.cp)||0)+(Number(b?.cp)||0),
  });
}
function fmtCoins(v){
  const n = normalizeCoins(v || {gp:0,sp:0,cp:0});
  const parts = [];
  if (n.gp) parts.push(`<span class="gp">${n.gp}gp</span>`);
  if (n.sp) parts.push(`<span class="sp">${n.sp}sp</span>`);
  if (n.cp) parts.push(`<span class="cp">${n.cp}cp</span>`);
  return parts.length ? parts.join(" ") : `<span class="muted">0gp</span>`;
}

/* -----------------------------
   View switching
----------------------------- */
function showOnly(view){
  const ids = ["viewMain","viewBook","viewIngredient","viewBrew","viewMix","viewHag","viewBag"];
  for (const id of ids) el(id).classList.add("hidden");
  el(view).classList.remove("hidden");
}

/* -----------------------------
   Ingredients fetch
----------------------------- */
async function fetchAllIngredients(){
  if (isFetching) return;
  isFetching = true;
  el("refreshBtn").disabled = true;
  el("bookStatus").textContent = "Turning pages...";

  try{
    const res = await fetch(INGREDIENTS_ENDPOINT, { headers: headers() });
    if (!res.ok) throw new Error(await res.text());
    const rows = await res.json();

    ING_BY_ID = {};
    for (const r of rows){
      const idStr = String(r.id);
      ING_BY_ID[idStr] = r;
      if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
    }

    // prune index keys that no longer exist
    for (const k of Object.keys(INDEX)) if (!ING_BY_ID[k]) delete INDEX[k];

    saveLocal();
    renderIndex();
    renderRightPageConcentrates();
    fillBrewChoices();
    renderBrewDiscovered();
    fillConcentrateChoices();
    renderBag();
    fillMixChoices();
    fillHagChoices();

    el("bookStatus").textContent = "Ready.";
    toast("Notes updated.", "good");
  }catch(e){
    console.error(e);
    el("bookStatus").textContent = "Could not update.";
    toast("The ink smudged. Try again.", "bad");
  }finally{
    isFetching = false;
    el("refreshBtn").disabled = false;
  }
}

async function fetchOne(mark){
  const res = await fetch(INGREDIENT_BY_MARK(mark), { headers: headers() });
  if (!res.ok) throw new Error(await res.text());
  const rows = await res.json();
  return rows?.[0] || null;
}

/* -----------------------------
   Index / inventory
----------------------------- */
function sortedIndexIds(){
  const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id]);
  ids.sort((a,b)=>Number(a)-Number(b));
  return ids;
}
function setQty(idStr, qty){
  const q = Math.max(0, Math.floor(Number(qty)||0));
  INDEX[String(idStr)] = q;
  saveLocal();
}
function renderIndex(){
  const wrap = el("indexList");
  wrap.innerHTML = "";
  const ids = sortedIndexIds();

  if (!ids.length){
    wrap.innerHTML = `<div class="muted">No entries yet.</div>`;
    return;
  }

  for (const idStr of ids){
    const row = ING_BY_ID[idStr];
    const name = row?.name || "Unknown";
    const qty = Number(INDEX[idStr])||0;

    const line = document.createElement("div");
    line.className = "indexRow";

    const left = document.createElement("div");
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "ingBtn";
    btn.textContent = name;
    btn.addEventListener("click", () => openIngredient(idStr));
    left.appendChild(btn);

    const right = document.createElement("div");
    right.className = "invBox";

    const minus = document.createElement("button");
    minus.type="button"; minus.className="qtyBtn"; minus.textContent="−";
    minus.addEventListener("click", () => {
      setQty(idStr, qty-1);
      renderIndex(); fillBrewChoices(); renderBrewDiscovered(); fillConcentrateChoices(); updateDcDisplay();
    });

    const count = document.createElement("div");
    count.className="count"; count.textContent=String(qty);

    const plus = document.createElement("button");
    plus.type="button"; plus.className="qtyBtn"; plus.textContent="+";
    plus.addEventListener("click", () => {
      setQty(idStr, qty+1);
      renderIndex(); fillBrewChoices(); renderBrewDiscovered(); fillConcentrateChoices(); updateDcDisplay();
    });

    right.append(minus,count,plus);
    line.append(left,right);
    wrap.appendChild(line);
  }
}

async function recordIngredientFromMark(mark){
  const clean = String(mark||"").replace(/\D/g,"");
  if (!clean){ toast("Enter a mark.", "bad"); return; }

  if (ING_BY_ID[clean]){
    if (INDEX[clean] === undefined) INDEX[clean] = 0;
    saveLocal();
    renderIndex();
    fillBrewChoices();
    renderBrewDiscovered();
    fillConcentrateChoices();
    toast("Recorded.", "good");
    el("markInput").value = "";
    return;
  }

  try{
    el("recordBtn").disabled = true;
    const row = await fetchOne(clean);
    if (!row){ toast("That mark is unknown.", "bad"); return; }
    ING_BY_ID[clean] = row;
    if (!REVEALS[clean]) REVEALS[clean] = [false,false,false,false];
    if (INDEX[clean] === undefined) INDEX[clean] = 0;
    saveLocal();
    renderIndex();
    fillBrewChoices();
    renderBrewDiscovered();
    fillConcentrateChoices();
    toast("Recorded.", "good");
    el("markInput").value = "";
  }catch(e){
    console.error(e);
    toast("Could not read that mark.", "bad");
  }finally{
    el("recordBtn").disabled = false;
  }
}

/* -----------------------------
   Ingredient page
----------------------------- */
function openIngredient(idStr){
  currentIngredientId = idStr;
  el("backToIndexBtn").classList.remove("hidden");
  showOnly("viewIngredient");
  renderIngredient(idStr);
}
function renderIngredient(idStr){
  const row = ING_BY_ID[idStr];
  if (!row){ toast("That page is missing.", "bad"); showOnly("viewBook"); return; }

  el("ingName").textContent = row.name || "Unknown Ingredient";
  el("ingredientStatus").textContent = "Ready.";

  const imgUrl = getImageUrl(row.image_path);
  el("ingImage").src = imgUrl || placeholderImageDataUri("No sketch");
  el("ingImage").onerror = () => el("ingImage").src = placeholderImageDataUri(row.name || "Unknown");

  el("ingNotes").textContent = row.notes ? String(row.notes) : "No notes written yet.";

  const effects = [row.effect_1,row.effect_2,row.effect_3,row.effect_4].map(v => v || "");
  const revealed = REVEALS[idStr] || [false,false,false,false];

  const list = el("effectsList");
  list.innerHTML = "";

  effects.forEach((eff, idx) => {
    const rr = document.createElement("div");
    rr.className = "card";
    rr.style.padding = "10px";
    rr.style.marginTop = "10px";
    rr.style.background = "rgba(255,255,255,.06)";

    const top = document.createElement("div");
    top.className = "row";
    top.style.justifyContent = "space-between";

    const name = document.createElement("div");
    name.style.fontWeight = "1000";
    name.textContent = `Property ${idx+1}`;

    const btn = document.createElement("button");
    btn.type="button";
    btn.textContent = revealed[idx] ? "Known" : "Reveal";
    btn.disabled = revealed[idx];
    btn.addEventListener("click", () => {
      REVEALS[idStr][idx] = true;
      saveLocal();
      renderIngredient(idStr);
      fillConcentrateChoices();
      toast("Noted.", "good");
    });

    top.append(name, btn);

    const txt = document.createElement("div");
    txt.style.marginTop = "8px";
    txt.style.padding = "10px";
    txt.style.borderRadius = "14px";
    txt.style.border = "1px dashed rgba(255,255,255,.16)";
    txt.style.background = "rgba(0,0,0,.12)";
    txt.style.fontWeight = "950";
    txt.style.minHeight = "18px";
    txt.textContent = eff || "(blank)";
    if (!revealed[idx]){
      txt.style.color = "transparent";
      txt.style.textShadow = "0 0 10px rgba(0,0,0,.65)";
      txt.style.userSelect = "none";
    }

    rr.append(top, txt);
    list.appendChild(rr);
  });

  el("revealRandomBtn").onclick = () => {
    const hidden = [];
    for (let i=0;i<4;i++) if (!REVEALS[idStr][i]) hidden.push(i);
    if (!hidden.length){ toast("Nothing more to learn here.", "good"); return; }
    const pick = hidden[Math.floor(Math.random()*hidden.length)];
    REVEALS[idStr][pick] = true;
    saveLocal();
    renderIngredient(idStr);
    fillConcentrateChoices();
    toast("Noted.", "good");
  };

  el("resetRevealsBtn").onclick = () => {
    REVEALS[idStr] = [false,false,false,false];
    saveLocal();
    renderIngredient(idStr);
    fillConcentrateChoices();
    toast("Forgotten.", "bad");
  };
}

/* -----------------------------
   Brewing
----------------------------- */
function availableForBrewIds(){
  const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id] && (Number(INDEX[id])||0) > 0);
  ids.sort((a,b)=>Number(a)-Number(b));
  return ids;
}
function discoveredEffectsFor(idStr){
  const row = ING_BY_ID[idStr];
  if (!row) return [];
  const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
  const revealed = REVEALS[idStr] || [false,false,false,false];
  const out = [];
  for (let i=0;i<4;i++){
    if (revealed[i] && effs[i]) out.push(String(effs[i]));
  }
  return out;
}
function renderDiscoveredInto(containerId, effects){
  const wrap = el(containerId);
  wrap.innerHTML = effects.length ? effects.map(e => `<div>• ${escapeHtml(e)}</div>`).join("") : `<div class="muted">None yet.</div>`;
}
function renderBrewDiscovered(){
  const aId = el("mixA").value;
  const bId = el("mixB").value;
  const useThird = el("useThird").checked;
  const cId = useThird ? el("mixC").value : "";

  renderDiscoveredInto("discA", aId ? discoveredEffectsFor(aId) : []);
  renderDiscoveredInto("discB", bId ? discoveredEffectsFor(bId) : []);
  if (useThird) renderDiscoveredInto("discC", cId ? discoveredEffectsFor(cId) : []);
}
function fillBrewChoices(){
  const ids = availableForBrewIds();
  const a = el("mixA"), b = el("mixB"), c = el("mixC");

  if (ids.length < 2){
    a.innerHTML=""; b.innerHTML=""; c.innerHTML="";
    el("mixResult").innerHTML = `<span class="muted">Keep at least two ingredients in your Inventory to brew.</span>`;
    el("dcBox").innerHTML = `<span class="muted">Select ingredients to see DC.</span>`;
    renderBrewDiscovered();
    return;
  }

  const opts = ids.map(idStr => {
    const name = ING_BY_ID[idStr]?.name || "Unknown";
    const qty = Number(INDEX[idStr])||0;
    return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
  }).join("");

  const prevA = a.value, prevB=b.value, prevC=c.value;
  a.innerHTML=opts; b.innerHTML=opts; c.innerHTML=opts;

  a.value = ids.includes(prevA) ? prevA : ids[0];
  const bPick = ids.includes(prevB) ? prevB : ids.find(x => x !== a.value);
  b.value = (bPick && bPick !== a.value) ? bPick : (ids.find(x=>x!==a.value) || ids[0]);

  const cDefault = ids.find(x => x !== a.value && x !== b.value) || ids[0];
  c.value = ids.includes(prevC) ? prevC : cDefault;

  renderBrewDiscovered();
  updateDcDisplay();
}
function enforceDistinctMixing(){
  const ids = availableForBrewIds();
  const a = el("mixA"), b = el("mixB"), c = el("mixC");
  if (a.value && b.value && a.value === b.value){
    const next = ids.find(x => x !== a.value);
    if (next) b.value = next;
  }
  if (el("useThird").checked){
    if (c.value === a.value || c.value === b.value){
      const nextC = ids.find(x => x !== a.value && x !== b.value);
      if (nextC) c.value = nextC;
    }
  }
  renderBrewDiscovered();
  updateDcDisplay();
}
function computeShared(ids){
  const rows = ids.map(id => ING_BY_ID[id]).filter(Boolean);
  if (rows.length < 2) return [];
  const sets = rows.map(r => new Set([r.effect_1,r.effect_2,r.effect_3,r.effect_4].filter(Boolean)));
  let shared = sets[0];
  for (let i=1;i<sets.length;i++){
    shared = new Set([...shared].filter(x => sets[i].has(x)));
  }
  return [...shared];
}
function canSpend(ids){
  const need = {};
  for (const id of ids) need[id] = (need[id]||0)+1;
  for (const [id,n] of Object.entries(need)){
    if ((Number(INDEX[id])||0) < n) return false;
  }
  return true;
}
function spend(ids){
  const need = {};
  for (const id of ids) need[id] = (need[id]||0)+1;
  for (const [id,n] of Object.entries(need)){
    setQty(id, (Number(INDEX[id])||0) - n);
  }
}
function revealSharedAutomatically(ids, shared){
  for (const idStr of ids){
    const row = ING_BY_ID[idStr];
    if (!row) continue;
    const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
    if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
    for (let i=0;i<4;i++){
      if (shared.includes(effs[i])) REVEALS[idStr][i] = true;
    }
  }
  saveLocal();
}
function recordRecipe(ids, shared){
  const norm = ids.map(String).slice().sort((a,b)=>Number(a)-Number(b));
  const key = norm.join("+") + "::" + shared.slice().sort().join("|");
  const exists = RECIPES.some(r =>
    (Array.isArray(r.ids)? r.ids.slice().sort((a,b)=>Number(a)-Number(b)).join("+"):"") +
    "::" +
    (Array.isArray(r.effects)? r.effects.slice().sort().join("|"):"") === key
  );
  if (exists) return;
  RECIPES.push({ ids:norm, effects:shared.slice(), at:Date.now() });
  saveLocal();
}
function updateDcDisplay(){
  const aId = el("mixA").value;
  const bId = el("mixB").value;
  const useThird = el("useThird").checked;
  const cId = useThird ? el("mixC").value : "";
  const ids = [aId,bId].filter(Boolean);
  if (useThird && cId) ids.push(cId);

  if (ids.length < 2){
    el("dcBox").innerHTML = `<span class="muted">Select ingredients to see DC.</span>`;
    return;
  }

  const rarities = ids.map(id => rarityKeyFromIngredient(ING_BY_ID[id]?.rarity));
  const maxR = maxRarityKey(rarities);
  const base = dcForRarity(maxR);
  const dc = base + (useThird ? 2 : 0);

  el("dcBox").innerHTML = `<span style="font-weight:1000;">DC ${dc}</span> <span class="muted">(${rarityDisplay(maxR)}${useThird ? " +2" : ""})</span>`;
}

/* -----------------------------
   Overlay system (roll + text)
----------------------------- */
const overlay = el("overlay");
let overlayState = null;

function openTextOverlay(title, subtitle, text){
  overlayState = { mode:"text" };
  el("overlayTitle").textContent = title || "Overlay";
  el("overlaySubtitle").textContent = subtitle || "";
  el("overlayBody").innerHTML = `<div class="overlayTextBlock">${escapeHtml(String(text||""))}</div>`;
  el("overlayConfirmBtn").classList.add("hidden");
  overlay.style.display = "flex";
}
function openRollOverlay({title, subtitle, effects, rarityKey, kind, onConfirm}){
  overlayState = { mode:"roll", effects, rarityKey, kind, onConfirm };
  el("overlayTitle").textContent = title || "Record Rolls";
  el("overlaySubtitle").textContent = subtitle || "";
  el("overlayConfirmBtn").classList.remove("hidden");

  const rows = effects.map((e, idx) => {
    const base = getBaseNote(e.name, rarityKey, kind);
    const bonusDice = getBonusDice(e.name, rarityKey, kind);
    return `
      <div class="rollRow">
        <div style="display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;">
          <div>
            <div style="font-weight:1000;">${escapeHtml(e.name)}</div>
            <div class="muted" style="margin-top:4px;">Roll bonus (${escapeHtml(bonusDice)}). Stored as ${escapeHtml(base)}+X.</div>
          </div>
          <div class="muted" style="font-weight:950;">Base: ${escapeHtml(base)}</div>
        </div>
        <div style="margin-top:8px;">
          <input data-idx="${idx}" inputmode="numeric" placeholder="Bonus result" style="width:160px;" />
        </div>
      </div>
    `;
  }).join("");

  el("overlayBody").innerHTML = rows;
  overlay.style.display = "flex";
}
function closeOverlay(){
  overlay.style.display = "none";
  overlayState = null;
  el("overlayConfirmBtn").classList.remove("hidden");
}
el("overlayCancelBtn").addEventListener("click", closeOverlay);
el("overlayConfirmBtn").addEventListener("click", () => {
  if (!overlayState) return;
  if (overlayState.mode !== "roll") return;

  const inputs = overlay.querySelectorAll("input[data-idx]");
  const nums = [];
  for (const inp of inputs){
    const raw = String(inp.value||"").trim();
    if (!raw || !/^\d+$/.test(raw)){ toast("Enter all bonus results.", "bad"); return; }
    nums.push(Number(raw));
  }
  try{
    overlayState.onConfirm(nums);
    closeOverlay();
  }catch(e){
    console.error(e);
    toast("Could not record.", "bad");
  }
});

/* -----------------------------
   Bag logic (includes hex support)
----------------------------- */
function getIconPath(effectName, kind){
  const cfg = EFFECTS_CONFIG[normKey(effectName)] || null;
  if (!cfg) return kind === "concentrate" ? GENERIC_CONC_ICON : GENERIC_POTION_ICON;
  const p = kind === "concentrate" ? cfg.concentrateIconPath : cfg.potionIconPath;
  return p || (kind === "concentrate" ? GENERIC_CONC_ICON : GENERIC_POTION_ICON);
}
function effectCfg(effectName){
  return EFFECTS_CONFIG[normKey(effectName)] || null;
}
function getEffectValue(effectName, rarityKey, kind){
  const cfg = effectCfg(effectName);
  if (!cfg) return {gp:0,sp:0,cp:0};
  const map = (kind==="concentrate")
    ? (cfg.concentrateValueByRarity || cfg.valueByRarity || {})
    : (cfg.valueByRarity || {});
  return map[rarityKey] || {gp:0,sp:0,cp:0};
}
function getBaseNote(effectName, rarityKey, kind){
  const cfg = effectCfg(effectName);
  if (!cfg) return "2d4";
  const map = (kind==="concentrate")
    ? (cfg.concentrateBaseNoteByRarity || {})
    : (cfg.baseNoteByRarity || {});
  return map[rarityKey] || "2d4";
}
function getBonusDice(effectName, rarityKey, kind){
  const cfg = effectCfg(effectName);
  if (!cfg) return "1d6";
  const map = (kind==="concentrate")
    ? (cfg.concentrateBonusDiceByRarity || {})
    : (cfg.bonusDiceByRarity || {});
  return map[rarityKey] || "1d6";
}

function isHexedItem(it){
  return !!(it && it.kind==="potion" && it.hex && typeof it.hex.text === "string" && it.hex.text.trim());
}

function bagKeyFor(item){
  const kind = item.kind;
  const rarityKey = item.rarityKey || "common";
  const effs = (item.effects || []).map(String);

  const dicePairs = [];
  if (item.diceByEffect && typeof item.diceByEffect === "object"){
    for (const e of effs){
      if (item.diceByEffect[e]) dicePairs.push(`${e}=${item.diceByEffect[e]}`);
    }
  }

  const hexText = item.hex?.text ? String(item.hex.text) : "";
  const hexStamp = item.hex?.at ? String(item.hex.at) : "";
  const hexPart = hexText ? `hex:${hexStamp}:${hexText}` : "hex:none";

  return [
    kind,
    rarityKey,
    effs.join("|"),
    dicePairs.join("|"),
    item.mixed ? "mixed" : "pure",
    hexPart
  ].join("::");
}

function bagAdd(item, qtyAdd){
  const normalizedValue = normalizeCoins(item.value || {gp:0,sp:0,cp:0});
  const key = bagKeyFor(item);
  if (BAG[key]){
    BAG[key].qty = Math.max(0, Math.floor((Number(BAG[key].qty)||0) + (Number(qtyAdd)||0)));
    BAG[key].value = normalizeCoins(BAG[key].value || normalizedValue);
  }else{
    BAG[key] = { ...item, value: normalizedValue, qty: Math.max(0, Math.floor(Number(qtyAdd)||0)) };
  }
  if (BAG[key].qty <= 0) delete BAG[key];
  saveLocal();
  renderBag();
  renderRightPageConcentrates();
  fillMixChoices();
  fillHagChoices();
}

function bagSetQty(key, qty){
  const q = Math.max(0, Math.floor(Number(qty)||0));
  if (!BAG[key]) return;
  if (q <= 0) delete BAG[key];
  else BAG[key].qty = q;
  saveLocal();
}

function bagSpendKey(key){
  const it = BAG[key];
  if (!it) return false;
  const q = Math.max(0, Math.floor(Number(it.qty)||0));
  if (q <= 0) return false;
  if (q === 1) delete BAG[key];
  else it.qty = q - 1;
  saveLocal();
  return true;
}

function listBagKeys(){
  const keys = Object.keys(BAG);
  keys.sort((a,b) => {
    const A = BAG[a], B = BAG[b];
    const r = rarityRank(A?.rarityKey) - rarityRank(B?.rarityKey);
    if (r !== 0) return r;
    const ta = (A?.kind||"").localeCompare(B?.kind||"");
    if (ta !== 0) return ta;
    return (A?.effects||[]).join("|").localeCompare((B?.effects||[]).join("|"));
  });
  return keys;
}

function renderBag(){
  const grid = el("bagGrid");
  grid.innerHTML = "";
  const keys = listBagKeys();
  el("bagCountText").textContent = `${keys.length} item${keys.length===1?"":"s"}`;

  if (!keys.length){
    grid.innerHTML = `<div class="muted">No potions or concentrates yet.</div>`;
    return;
  }

  for (const key of keys){
    const it = BAG[key];
    const kind = it.kind;
    const rk = it.rarityKey || "common";
    const effs = Array.isArray(it.effects) ? it.effects : [];
    const qty = Number(it.qty)||0;
    const first = effs[0] || "Unknown";
    const icon = it.iconPath || getIconPath(first, kind);

    const tile = document.createElement("div");
    tile.className = "bagTile";

    const badge = document.createElement("div");
    badge.className = "badge";
    badge.textContent = rarityDisplay(rk);
    tile.appendChild(badge);

    if (it.mixed){
      const badgeR = document.createElement("div");
      badgeR.className = "badge badgeR";
      badgeR.textContent = "Mixed";
      tile.appendChild(badgeR);
    }

    const iconRow = document.createElement("div");
    iconRow.className = "bagIconRow";

    const img = document.createElement("img");
    img.className = "bagIcon";
    img.src = icon;
    img.alt = "";
    img.onerror = () => img.src = (kind==="concentrate" ? GENERIC_CONC_ICON : GENERIC_POTION_ICON);
    iconRow.appendChild(img);

    if (kind==="potion" && isHexedItem(it)){
      const sigBtn = document.createElement("button");
      sigBtn.type="button";
      sigBtn.className="hexBtn";
      sigBtn.title="Hexed (tap to read)";
      sigBtn.innerHTML = `<img src="${escapeHtml(HEX_SIGIL)}" alt="" />`;
      sigBtn.addEventListener("click", () => {
        const txt = it.hex?.text ? String(it.hex.text) : "No hex recorded.";
        openTextOverlay("Hex Effect", "This effect must be DM-approved.", txt);
      });
      iconRow.appendChild(sigBtn);
    }

    const title = document.createElement("div");
    title.className = "bagTitle";
    title.textContent = kind==="concentrate" ? "Concentrate" : "Concoction";

    const diceBy = (it.diceByEffect && typeof it.diceByEffect === "object") ? it.diceByEffect : {};
    const lines = effs.length
      ? effs.map(e => `of ${e} ${diceBy[e] || "—"}`).join(" | ")
      : "Unknown";

    const effectsLine = document.createElement("div");
    effectsLine.className = "bagLine";
    effectsLine.textContent = lines;

    const valueLine = document.createElement("div");
    valueLine.className = "bagLine";
    valueLine.innerHTML = `Value: ${fmtCoins(it.value || {gp:0,sp:0,cp:0})}`;

    const qtyRow = document.createElement("div");
    qtyRow.className="bagQtyRow";

    const minus = document.createElement("button");
    minus.type="button"; minus.className="qtyBtn"; minus.textContent="−";
    minus.addEventListener("click", () => {
      bagSetQty(key, qty-1);
      renderBag(); renderRightPageConcentrates(); fillMixChoices(); fillHagChoices();
    });

    const count = document.createElement("div");
    count.className="count"; count.textContent=String(qty);

    const plus = document.createElement("button");
    plus.type="button"; plus.className="qtyBtn"; plus.textContent="+";
    plus.addEventListener("click", () => {
      bagSetQty(key, qty+1);
      renderBag(); renderRightPageConcentrates(); fillMixChoices(); fillHagChoices();
    });

    qtyRow.append(minus,count,plus);

    tile.append(iconRow, title, effectsLine, valueLine, qtyRow);
    grid.appendChild(tile);
  }
}

function renderRightPageConcentrates(){
  // On the Index right page: show only concentrates with +/- controls
  const box = el("rightPageBox");
  const concKeys = listBagKeys().filter(k => BAG[k]?.kind === "concentrate");
  if (!concKeys.length){
    box.textContent = "No concentrates yet.";
    return;
  }

  const rows = concKeys.map(k => {
    const it = BAG[k];
    const eff = it.effects?.[0] || "Unknown";
    const qty = Number(it.qty)||0;
    return { k, eff, rk: it.rarityKey||"common", qty };
  });

  box.innerHTML = "";
  for (const r of rows){
    const line = document.createElement("div");
    line.className = "indexRow";
    line.style.gridTemplateColumns = "1fr auto";

    const left = document.createElement("div");
    left.style.fontWeight = "950";
    left.textContent = `Concentrate of ${r.eff} (${rarityDisplay(r.rk)})`;

    const right = document.createElement("div");
    right.className = "invBox";

    const minus = document.createElement("button");
    minus.type="button"; minus.className="qtyBtn"; minus.textContent="−";
    minus.addEventListener("click", () => {
      bagSetQty(r.k, r.qty-1);
      renderRightPageConcentrates(); renderBag(); fillMixChoices(); fillHagChoices();
    });

    const count = document.createElement("div");
    count.className="count"; count.textContent=String(r.qty);

    const plus = document.createElement("button");
    plus.type="button"; plus.className="qtyBtn"; plus.textContent="+";
    plus.addEventListener("click", () => {
      bagSetQty(r.k, r.qty+1);
      renderRightPageConcentrates(); renderBag(); fillMixChoices(); fillHagChoices();
    });

    right.append(minus,count,plus);
    line.append(left,right);
    box.appendChild(line);
  }
}

/* -----------------------------
   Brewing attempt
----------------------------- */
function brewAttempt(isSuccess){
  const aId = el("mixA").value;
  const bId = el("mixB").value;
  const useThird = el("useThird").checked;
  const cId = useThird ? el("mixC").value : "";

  if (aId && bId && aId === bId){ toast("Choose two different ingredients.", "bad"); enforceDistinctMixing(); return; }
  if (useThird && cId && (cId===aId || cId===bId)){ toast("Each ingredient must be different.", "bad"); enforceDistinctMixing(); return; }

  const ids = [aId,bId].filter(Boolean);
  if (useThird && cId) ids.push(cId);
  if (ids.length < 2){ el("mixResult").textContent = "Need at least two ingredients."; return; }

  if (!canSpend(ids)){ toast("Not enough in the Inventory.", "bad"); el("mixResult").textContent = "Not enough inventory."; return; }

  const shared = computeShared(ids);

  // spend always
  spend(ids);
  renderIndex(); fillBrewChoices(); enforceDistinctMixing(); fillConcentrateChoices(); updateDcDisplay();

  if (!isSuccess){
    el("mixResult").innerHTML = `<span style="color:var(--warn); font-weight:950;">The brew fails.</span> <span class="muted">Ingredients were consumed.</span>`;
    toast("Failed.", "bad");
    return;
  }

  if (!shared.length){
    el("mixResult").innerHTML = `<span style="color:var(--warn); font-weight:950;">Fizzles.</span> <span class="muted">Nothing in common.</span>`;
    toast("Fizzled.", "bad");
    return;
  }

  const maxR = maxRarityKey(ids.map(id => rarityKeyFromIngredient(ING_BY_ID[id]?.rarity)));
  const effects = shared.slice(0,3);

  let value = {gp:0,sp:0,cp:0};
  for (const eff of effects){
    value = addCoins(value, getEffectValue(eff, maxR, "potion"));
  }

  openRollOverlay({
    title: "Record Bonus Rolls",
    subtitle: "Roll the bonus dice for each effect, enter the bonus result. Stored as base+bonus.",
    effects: effects.map(n => ({name:n})),
    rarityKey: maxR,
    kind: "potion",
    onConfirm: (bonusNums) => {
      const diceByEffect = {};
      effects.forEach((eff, i) => {
        const base = getBaseNote(eff, maxR, "potion");
        diceByEffect[eff] = `${base}+${bonusNums[i]}`;
      });

      revealSharedAutomatically(ids, effects);
      recordRecipe(ids, effects);

      const iconPath = getIconPath(effects[0] || "Unknown", "potion");
      bagAdd({
        kind:"potion",
        effects,
        rarityKey:maxR,
        diceByEffect,
        value,
        iconPath,
        mixed:false
      }, 1);

      el("mixResult").innerHTML = `<span style="color:var(--good); font-weight:1000;">Concoction recorded.</span> <span class="muted">Added to Bag.</span>`;
      toast("A concoction is born.", "good");
    }
  });
}

/* -----------------------------
   Concentrates (popup occurs HERE)
----------------------------- */
function fillConcentrateChoices(){
  const selIng = el("concIng");
  const selEff = el("concEffect");

  const ids = availableForBrewIds().filter(id => (Number(INDEX[id])||0) >= 4);
  if (!ids.length){
    selIng.innerHTML = `<option value="">(Need 4+ of an ingredient)</option>`;
    selEff.innerHTML = `<option value="">(No properties)</option>`;
    el("makeConcBtn").disabled = true;
    return;
  }

  const opts = ids.map(idStr => {
    const name = ING_BY_ID[idStr]?.name || "Unknown";
    const qty = Number(INDEX[idStr])||0;
    return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
  }).join("");

  const prev = selIng.value;
  selIng.innerHTML = opts;
  selIng.value = ids.includes(prev) ? prev : ids[0];

  function fillEffectsForSelected(){
    const id = selIng.value;
    const effs = discoveredEffectsFor(id);
    if (!effs.length){
      selEff.innerHTML = `<option value="">(No discovered properties)</option>`;
      el("makeConcBtn").disabled = true;
      return;
    }
    selEff.innerHTML = effs.map(e => `<option value="${escapeHtml(e)}">${escapeHtml(e)}</option>`).join("");
    el("makeConcBtn").disabled = false;
  }

  fillEffectsForSelected();
  selIng.onchange = fillEffectsForSelected;
}

function makeConcentrate(){
  const id = el("concIng").value;
  const eff = el("concEffect").value;
  if (!id || !eff){ toast("Pick an ingredient and property.", "bad"); return; }

  const have = Number(INDEX[id])||0;
  if (have < 4){ toast("Need 4 of that ingredient.", "bad"); return; }

  // spend 4
  setQty(id, have-4);
  renderIndex(); fillBrewChoices(); renderBrewDiscovered(); fillConcentrateChoices(); updateDcDisplay();

  const rk = rarityKeyFromIngredient(ING_BY_ID[id]?.rarity);
  const value = getEffectValue(eff, rk, "concentrate");
  const iconPath = getIconPath(eff, "concentrate");

  openRollOverlay({
    title: "Record Concentrate Bonus Roll",
    subtitle: "Roll the concentrate bonus dice, enter the bonus result. Stored as base+bonus.",
    effects: [{name:eff}],
    rarityKey: rk,
    kind:"concentrate",
    onConfirm: (nums) => {
      const bonus = nums[0];
      const base = getBaseNote(eff, rk, "concentrate");
      const diceByEffect = {};
      diceByEffect[eff] = `${base}+${bonus}`;

      bagAdd({
        kind:"concentrate",
        effects:[eff],
        rarityKey:rk,
        diceByEffect,
        value,
        iconPath,
        mixed:false
      }, 1);

      toast("Concentrate made.", "good");
    }
  });
}

/* -----------------------------
   Mixing (no popups, mixed potions hidden)
----------------------------- */
function bagOptionLabel(key){
  const it = BAG[key];
  if (!it) return "Unknown";
  const kind = it.kind;
  const rk = it.rarityKey || "common";
  const effs = Array.isArray(it.effects) ? it.effects : [];
  const first = effs[0] || "Unknown";
  const qty = Number(it.qty)||0;
  const diceBy = it.diceByEffect || {};
  const dice = diceBy[first] || "—";
  const hexMark = (kind==="potion" && isHexedItem(it)) ? " (Hexed)" : "";
  if (kind==="concentrate") return `Concentrate of ${first} ${dice} (${rarityDisplay(rk)}) [${qty}]`;
  return `Concoction of ${first} ${dice} (${rarityDisplay(rk)}) [${qty}]${hexMark}`;
}
function fillMixChoices(){
  const a = el("mixItemA");
  const b = el("mixItemB");

  // Hide mixed potions from mixing list entirely
  const keys = listBagKeys().filter(k => {
    const it = BAG[k];
    if (!it) return false;
    if ((Number(it.qty)||0) <= 0) return false;
    if (it.kind === "potion" && it.mixed) return false;
    return true;
  });

  if (keys.length < 2){
    a.innerHTML=""; b.innerHTML="";
    el("mixCombineResult").textContent = "Add at least two unmixed items to your Bag.";
    el("mixDcBox").textContent = "Select items to see DC.";
    el("mixItemADetail").textContent = "Select an item.";
    el("mixItemBDetail").textContent = "Select an item.";
    return;
  }

  const opts = keys.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(bagOptionLabel(k))}</option>`).join("");
  const prevA = a.value, prevB = b.value;
  a.innerHTML = opts; b.innerHTML = opts;

  a.value = keys.includes(prevA) ? prevA : keys[0];
  const bPick = keys.includes(prevB) ? prevB : keys.find(x => x !== a.value);
  b.value = (bPick && bPick !== a.value) ? bPick : (keys.find(x=>x!==a.value) || keys[0]);

  enforceDistinctMixItems();
}
function renderMixItemDetail(which){
  const key = which==="A" ? el("mixItemA").value : el("mixItemB").value;
  const box = which==="A" ? el("mixItemADetail") : el("mixItemBDetail");
  const it = BAG[key];
  if (!it){ box.textContent = "Select an item."; return; }

  const kind = it.kind;
  const rk = it.rarityKey || "common";
  const effs = Array.isArray(it.effects) ? it.effects : [];
  const diceBy = it.diceByEffect || {};
  const lines = effs.map(e => `${e} ${diceBy[e]||"—"}`).join(", ");

  box.innerHTML = `
    <div style="font-weight:1000;">${escapeHtml(kind==="concentrate" ? "Concentrate" : "Concoction")}</div>
    <div class="muted" style="margin-top:6px;">Rarity: ${escapeHtml(rarityDisplay(rk))}</div>
    <div class="muted" style="margin-top:6px;">Effects: ${escapeHtml(lines || "Unknown")}</div>
    <div class="muted" style="margin-top:6px;">Value: ${fmtCoins(it.value || {gp:0,sp:0,cp:0})}</div>
  `;
}
function enforceDistinctMixItems(){
  const a = el("mixItemA");
  const b = el("mixItemB");
  const keys = listBagKeys().filter(k => {
    const it = BAG[k];
    if (!it) return false;
    if ((Number(it.qty)||0) <= 0) return false;
    if (it.kind === "potion" && it.mixed) return false;
    return true;
  });
  if (a.value && b.value && a.value === b.value){
    const next = keys.find(x => x !== a.value);
    if (next) b.value = next;
  }
  renderMixItemDetail("A");
  renderMixItemDetail("B");
  updateMixDcDisplay();
}
function updateMixDcDisplay(){
  const aKey = el("mixItemA").value;
  const bKey = el("mixItemB").value;
  const A = BAG[aKey], B = BAG[bKey];
  if (!A || !B || aKey === bKey){
    el("mixDcBox").textContent = "Select items to see DC.";
    return;
  }
  const maxR = maxRarityKey([A.rarityKey||"common", B.rarityKey||"common"]);
  const dc = dcForRarity(maxR) + 2;
  el("mixDcBox").innerHTML = `<span style="font-weight:1000;">DC ${dc}</span> <span class="muted">(${rarityDisplay(maxR)} +2 mixing)</span>`;
}
function sameEffectSet(aEffs, bEffs){
  const A = (aEffs||[]).map(normKey).sort();
  const B = (bEffs||[]).map(normKey).sort();
  if (A.length !== B.length) return false;
  for (let i=0;i<A.length;i++) if (A[i] !== B[i]) return false;
  return true;
}
function parseDicePlus(s){
  const m = String(s||"").trim().match(/^([^+]+)\+(\d+)$/);
  if (!m) return { base:"", bonus:0 };
  return { base:m[1].trim(), bonus:Number(m[2])||0 };
}
function findCanonicalEffectName(list, target){
  const tk = normKey(target);
  for (const e of list){
    if (normKey(e) === tk) return e;
  }
  return target;
}
function finalizeMixedPotion(effects, rarityKey, diceByEffect, value){
  const iconPath = getIconPath(effects[0] || "Unknown", "potion");
  bagAdd({
    kind:"potion",
    effects,
    rarityKey,
    diceByEffect,
    value,
    iconPath,
    mixed:true
  }, 1);

  el("mixCombineResult").innerHTML = `<span style="color:var(--good); font-weight:1000;">Mixture recorded.</span> <span class="muted">Added to Bag.</span>`;
  toast("Mixed.", "good");
}

function mixAttempt(isSuccess){
  const aKey = el("mixItemA").value;
  const bKey = el("mixItemB").value;
  if (!aKey || !bKey || aKey === bKey){ toast("Choose two different items.", "bad"); return; }

  const A = BAG[aKey], B = BAG[bKey];
  if (!A || !B){ toast("Missing item.", "bad"); return; }

  // rule: no concentrate + concentrate
  if (A.kind==="concentrate" && B.kind==="concentrate"){
    toast("Concentrate + concentrate is not allowed.", "bad");
    el("mixCombineResult").textContent = "Concentrate + concentrate is not allowed.";
    return;
  }

  // rule: mixed potions cannot be mixed (menu hides them, but keep protection)
  if (A.kind==="potion" && A.mixed){ toast("That potion is already mixed.", "bad"); return; }
  if (B.kind==="potion" && B.mixed){ toast("That potion is already mixed.", "bad"); return; }

  // rule: no identical potion + identical potion
  if (A.kind==="potion" && B.kind==="potion" && sameEffectSet(A.effects, B.effects)){
    toast("Cannot mix identical potions.", "bad");
    el("mixCombineResult").textContent = "Cannot mix identical potions.";
    return;
  }

  // always spend on success or fail
  if (!bagSpendKey(aKey) || !bagSpendKey(bKey)){ toast("Not enough quantity.", "bad"); return; }

  if (!isSuccess){
    renderBag(); renderRightPageConcentrates(); fillMixChoices(); enforceDistinctMixItems(); fillHagChoices();
    el("mixCombineResult").innerHTML = `<span style="color:var(--warn); font-weight:950;">The mix fails.</span> <span class="muted">Items were consumed.</span>`;
    toast("Failed.", "bad");
    return;
  }

  // determine resulting potion
  const potion = (A.kind==="potion") ? A : B;
  const other = (A.kind==="potion") ? B : A;

  if (!potion || potion.kind !== "potion"){ toast("Need at least one potion.", "bad"); return; }

  const baseEffects = Array.isArray(potion.effects) ? potion.effects.slice() : [];
  const otherEffects = Array.isArray(other.effects) ? other.effects.slice() : [];

  // union cap 3
  const union = [];
  const seen = new Set();
  for (const e of baseEffects){ const k=normKey(e); if (!k) continue; if (!seen.has(k)){ seen.add(k); union.push(e); } }
  for (const e of otherEffects){ const k=normKey(e); if (!k) continue; if (!seen.has(k)){ seen.add(k); union.push(e); } }

  if (union.length > 3){
    toast("Cap is 3 effects.", "bad");
    el("mixCombineResult").textContent = "Result would exceed 3 effects.";
    // refund
    bagAdd(A, 1);
    bagAdd(B, 1);
    return;
  }

  const maxR = maxRarityKey([potion.rarityKey||"common", other.rarityKey||"common"]);

  // Start with potion dice + value
  const diceByEffect = { ...(potion.diceByEffect || {}) };
  let value = addCoins(potion.value || {gp:0,sp:0,cp:0}, other.value || {gp:0,sp:0,cp:0});

  if (other.kind === "potion"){
    const od = other.diceByEffect || {};
    for (const e of (other.effects || [])){
      if (!diceByEffect[e] && od[e]) diceByEffect[e] = od[e];
    }
    finalizeMixedPotion(union, maxR, diceByEffect, value);
    return;
  }

  // other is concentrate: use stored roll, no popup here
  const concEff = other.effects?.[0] || "";
  const concDiceBy = other.diceByEffect || {};
  const concDice = concDiceBy[concEff] || "";

  const alreadyHas = baseEffects.some(e => normKey(e) === normKey(concEff));
  if (alreadyHas){
    const effName = findCanonicalEffectName(baseEffects, concEff);
    const cur = diceByEffect[effName] || "";
    const parsedCur = parseDicePlus(cur);
    const parsedConc = parseDicePlus(concDice);
    const newBonus = (parsedCur.bonus||0) + (parsedConc.bonus||0);
    const basePart = parsedCur.base || getBaseNote(effName, maxR, "potion");
    diceByEffect[effName] = `${basePart}+${newBonus}`;
  }else{
    diceByEffect[concEff] = concDice || `${getBaseNote(concEff, maxR, "concentrate")}+0`;
    value = addCoins(value, getEffectValue(concEff, maxR, "concentrate"));
  }

  finalizeMixedPotion(union, maxR, diceByEffect, value);
}

/* -----------------------------
   Hagcraft
----------------------------- */
function setHagRevealed(v){
  HAG.revealed = !!v;
  saveLocal();
  renderHagTileVisibility();
}
function renderHagTileVisibility(){
  el("openHagBtn").classList.toggle("hidden", !HAG.revealed);
}
function tryAdminOverride(){
  const v = String(el("adminOverrideInput").value||"").trim();
  if (!v){ toast("Enter override.", "bad"); return; }
  if (v === ADMIN_PASSWORD){
    setHagRevealed(true);
    toast("Override accepted.", "good");
    el("adminOverrideInput").value = "";
  }else{
    toast("Override denied.", "bad");
  }
}
function bagPotionKeysForHag(){
  return listBagKeys().filter(k => {
    const it = BAG[k];
    if (!it) return false;
    if ((Number(it.qty)||0) <= 0) return false;
    if (it.kind !== "potion") return false;
    if (isHexedItem(it)) return false; // only unhexed
    return true;
  });
}
function hagOptionLabel(key){
  const it = BAG[key];
  if (!it) return "Unknown";
  const rk = it.rarityKey || "common";
  const first = it.effects?.[0] || "Unknown";
  const qty = Number(it.qty)||0;
  return `Concoction of ${first} (${rarityDisplay(rk)}) [${qty}]`;
}
function fillHagChoices(){
  const sel = el("hagPotionSel");
  const keys = bagPotionKeysForHag();

  if (!keys.length){
    sel.innerHTML = `<option value="">(No unhexed potions)</option>`;
    el("hagPotionDetail").textContent = "Add an unhexed potion to your Bag.";
    el("hagDcBox").textContent = "Select a potion to see DC.";
    el("hagSuccessBtn").disabled = true;
    el("hagFailBtn").disabled = true;
    return;
  }

  const prev = sel.value;
  sel.innerHTML = keys.map(k => `<option value="${escapeHtml(k)}">${escapeHtml(hagOptionLabel(k))}</option>`).join("");
  sel.value = keys.includes(prev) ? prev : keys[0];

  el("hagSuccessBtn").disabled = false;
  el("hagFailBtn").disabled = false;

  renderHagDetail();
  updateHagDc();
}
function renderHagDetail(){
  const key = el("hagPotionSel").value;
  const it = BAG[key];
  if (!it){ el("hagPotionDetail").textContent = "Select a potion."; return; }

  const rk = it.rarityKey || "common";
  const effs = Array.isArray(it.effects) ? it.effects : [];
  const diceBy = it.diceByEffect || {};
  const lines = effs.map(e => `${e} ${diceBy[e]||"—"}`).join(", ");

  el("hagPotionDetail").innerHTML = `
    <div style="font-weight:1000;">Concoction</div>
    <div class="muted" style="margin-top:6px;">Rarity: ${escapeHtml(rarityDisplay(rk))}</div>
    <div class="muted" style="margin-top:6px;">Effects: ${escapeHtml(lines || "Unknown")}</div>
    <div class="muted" style="margin-top:6px;">Value: ${fmtCoins(it.value || {gp:0,sp:0,cp:0})}</div>
  `;
}
function updateHagDc(){
  const key = el("hagPotionSel").value;
  const it = BAG[key];
  if (!it){ el("hagDcBox").textContent = "Select a potion to see DC."; return; }
  const base = dcForRarity(it.rarityKey || "common");
  const dc = base + 2;
  el("hagDcBox").innerHTML = `<span style="font-weight:1000;">DC ${dc}</span> <span class="muted">(${rarityDisplay(it.rarityKey || "common")} +2 hagcraft)</span>`;
}
function hagAttempt(isSuccess){
  const key = el("hagPotionSel").value;
  const it = BAG[key];
  if (!key || !it || it.kind !== "potion"){ toast("Choose a potion.", "bad"); return; }
  if (isHexedItem(it)){ toast("That potion is already hexed.", "bad"); return; }

  const hexText = String(el("hagHexText").value||"").trim();

  if (!isSuccess){
    el("hagResult").innerHTML = `<span style="color:var(--warn); font-weight:950;">The hex fails.</span> <span class="muted">Nothing changes.</span>`;
    toast("Failed.", "bad");
    return;
  }

  if (!hexText){ toast("Write the DM-approved hex effect.", "bad"); return; }

  // convert 1 unit into a hexed variant
  if (!bagSpendKey(key)){ toast("Not enough quantity.", "bad"); return; }

  const hexedItem = { ...it, qty:1, hex:{ text:hexText, at:Date.now() } };
  bagAdd(hexedItem, 1);

  el("hagHexText").value = "";
  el("hagResult").innerHTML = `<span style="color:var(--good); font-weight:1000;">Hex recorded.</span> <span class="muted">Sigil added in the Bag.</span>`;
  toast("Hexed.", "good");
  fillHagChoices();
}

/* -----------------------------
   Cloud Save (Commit / Recall)
   (with improved error reporting)
----------------------------- */
function normalizeSignature(raw){
  return String(raw || "").trim().replace(/\s+/g," ").toLowerCase();
}
function packState(){
  return { reveals:REVEALS, index:INDEX, recipes:RECIPES, bag:BAG, hag:HAG, at:Date.now(), version:2 };
}
function applyPackedState(p){
  if (!p || typeof p !== "object") throw new Error("bad");

  REVEALS = (p.reveals && typeof p.reveals === "object") ? p.reveals : {};

  const idx = (p.index && typeof p.index === "object") ? p.index : {};
  const cleanIdx = {};
  for (const [k,v] of Object.entries(idx)){
    const n = Number(v);
    if (Number.isFinite(n) && n >= 0) cleanIdx[String(k)] = Math.floor(n);
  }
  INDEX = cleanIdx;

  RECIPES = Array.isArray(p.recipes) ? p.recipes : [];

  const bag = (p.bag && typeof p.bag === "object") ? p.bag : {};
  const cleanBag = {};
  for (const [k,v] of Object.entries(bag)){
    if (!v || typeof v !== "object") continue;
    const qty = Math.max(0, Math.floor(Number(v.qty)||0));
    if (qty <= 0) continue;
    const hex = (v.hex && typeof v.hex === "object") ? v.hex : null;
    cleanBag[String(k)] = { ...v, qty, ...(hex ? {hex} : {}) };
  }
  BAG = cleanBag;

  const hag = (p.hag && typeof p.hag === "object") ? p.hag : { revealed:false };
  HAG = { revealed: !!hag.revealed };

  saveLocal();
}

async function cloudCommit(){
  const sigRaw = el("cloudSignature").value;
  const sig = normalizeSignature(sigRaw);
  if (!sig){ toast("Write a Signature.", "bad"); return; }

  el("bookStatus").textContent = "Committing...";
  try{
    const body = [{ signature:sig, data: packState() }];

    const res = await fetch(SAVES_UPSERT_ENDPOINT, {
      method:"POST",
      headers: headers({
        "Content-Type":"application/json",
        "Accept":"application/json",
        "Prefer":"resolution=merge-duplicates,return=representation"
      }),
      body: JSON.stringify(body)
    });

    const txt = await res.text();
    if (!res.ok){
      console.error("Commit error:", res.status, txt);
      toast(`Cannot commit (${res.status}). ${txt || ""}`.trim(), "bad");
      el("bookStatus").textContent = "Could not commit.";
      return;
    }

    toast("Committed.", "good");
    el("bookStatus").textContent = "Ready.";
  }catch(e){
    console.error(e);
    toast("Cannot commit (network).", "bad");
    el("bookStatus").textContent = "Could not commit.";
  }
}

async function cloudRecall(){
  const sigRaw = el("cloudSignature").value;
  const sig = normalizeSignature(sigRaw);
  if (!sig){ toast("Write a Signature.", "bad"); return; }

  el("bookStatus").textContent = "Recalling...";
  try{
    const res = await fetch(SAVES_SELECT_ENDPOINT(sig), {
      method:"GET",
      headers: headers({ "Accept":"application/json" })
    });

    const txt = await res.text();
    if (!res.ok){
      console.error("Recall error:", res.status, txt);
      toast(`Cannot recall (${res.status}). ${txt || ""}`.trim(), "bad");
      el("bookStatus").textContent = "Could not recall.";
      return;
    }

    const rows = JSON.parse(txt || "[]");
    const data = rows?.[0]?.data || null;
    if (!data){
      toast("No memory found for that Signature.", "bad");
      el("bookStatus").textContent = "No memory found.";
      return;
    }

    applyPackedState(data);

    // refresh UI
    renderHagTileVisibility();
    renderIndex();
    renderRightPageConcentrates();
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateChoices();
    updateDcDisplay();

    renderBag();
    fillMixChoices();
    enforceDistinctMixItems();
    fillHagChoices();

    if (currentIngredientId) renderIngredient(currentIngredientId);

    toast("Recalled.", "good");
    el("bookStatus").textContent = "Ready.";
  }catch(e){
    console.error(e);
    toast("Cannot recall (network).", "bad");
    el("bookStatus").textContent = "Could not recall.";
  }
}

/* -----------------------------
   Export / Import / Wipe
----------------------------- */
function doExport(){
  el("saveBox").value = JSON.stringify({ reveals:REVEALS, index:INDEX, recipes:RECIPES, bag:BAG, hag:HAG }, null, 2);
  toast("Copied to the box.", "good");
}
function doImport(){
  try{
    const parsed = JSON.parse(el("saveBox").value);
    applyPackedState({
      reveals: parsed.reveals,
      index: parsed.index,
      recipes: parsed.recipes,
      bag: parsed.bag,
      hag: parsed.hag
    });

    renderHagTileVisibility();
    renderIndex();
    renderRightPageConcentrates();
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateChoices();
    updateDcDisplay();
    renderBag();
    fillMixChoices();
    fillHagChoices();

    toast("Restored.", "good");
  }catch(e){
    console.error(e);
    toast("Those notes do not make sense.", "bad");
  }
}
function doWipe(){
  if (!confirm("Burn all notes on this device?")) return;
  REVEALS = {};
  INDEX = {};
  RECIPES = [];
  BAG = {};
  HAG = { revealed:false };
  saveLocal();
  renderHagTileVisibility();
  renderIndex();
  renderRightPageConcentrates();
  fillBrewChoices();
  enforceDistinctMixing();
  fillConcentrateChoices();
  updateDcDisplay();
  renderBag();
  fillMixChoices();
  fillHagChoices();
  showOnly("viewMain");
  toast("Ashes and silence.", "bad");
}

/* -----------------------------
   Theme toggle (minimal)
----------------------------- */
function setTheme(next){
  theme = next;
  toast(`Theme: ${theme}`, "good");
}

/* -----------------------------
   Wire up UI
----------------------------- */
el("refreshBtn").addEventListener("click", fetchAllIngredients);

el("openBookBtn").addEventListener("click", () => {
  showOnly("viewBook");
  renderIndex();
  renderRightPageConcentrates();
});
el("closeBookBtn").addEventListener("click", () => showOnly("viewMain"));
el("backToIndexBtn").addEventListener("click", () => {
  showOnly("viewBook");
  el("backToIndexBtn").classList.add("hidden");
  renderIndex();
  renderRightPageConcentrates();
});
el("backFromIngredientBtn").addEventListener("click", () => {
  showOnly("viewBook");
  el("backToIndexBtn").classList.add("hidden");
  renderIndex();
  renderRightPageConcentrates();
});

el("openBrewBtn").addEventListener("click", () => {
  showOnly("viewBrew");
  fillBrewChoices();
  enforceDistinctMixing();
  fillConcentrateChoices();
  updateDcDisplay();
});
el("backFromBrewBtn").addEventListener("click", () => showOnly("viewMain"));

el("openMixBtn").addEventListener("click", () => {
  showOnly("viewMix");
  fillMixChoices();
  enforceDistinctMixItems();
});
el("backFromMixBtn").addEventListener("click", () => showOnly("viewMain"));

el("openBagBtn").addEventListener("click", () => {
  showOnly("viewBag");
  renderBag();
});
el("backFromBagBtn").addEventListener("click", () => showOnly("viewMain"));

el("openHagBtn").addEventListener("click", () => {
  showOnly("viewHag");
  fillHagChoices();
});
el("backFromHagBtn").addEventListener("click", () => showOnly("viewMain"));

el("recordBtn").addEventListener("click", () => recordIngredientFromMark(el("markInput").value));
el("markInput").addEventListener("keydown", (e) => { if (e.key === "Enter") recordIngredientFromMark(el("markInput").value); });

el("useThird").addEventListener("change", () => {
  el("thirdSlot").classList.toggle("hidden", !el("useThird").checked);
  fillBrewChoices();
  enforceDistinctMixing();
});
el("mixA").addEventListener("change", enforceDistinctMixing);
el("mixB").addEventListener("change", enforceDistinctMixing);
el("mixC").addEventListener("change", enforceDistinctMixing);

el("brewSuccessBtn").addEventListener("click", () => brewAttempt(true));
el("brewFailBtn").addEventListener("click", () => brewAttempt(false));

el("makeConcBtn").addEventListener("click", makeConcentrate);

el("mixItemA").addEventListener("change", enforceDistinctMixItems);
el("mixItemB").addEventListener("change", enforceDistinctMixItems);
el("mixSuccessBtn").addEventListener("click", () => mixAttempt(true));
el("mixFailBtn").addEventListener("click", () => mixAttempt(false));

el("hagPotionSel").addEventListener("change", () => { renderHagDetail(); updateHagDc(); });
el("hagSuccessBtn").addEventListener("click", () => hagAttempt(true));
el("hagFailBtn").addEventListener("click", () => hagAttempt(false));

el("adminOverrideBtn").addEventListener("click", tryAdminOverride);
el("adminOverrideInput").addEventListener("keydown", (e) => { if (e.key === "Enter") tryAdminOverride(); });

el("exportBtn").addEventListener("click", doExport);
el("importBtn").addEventListener("click", doImport);
el("wipeBtn").addEventListener("click", doWipe);

el("cloudCommitBtn").addEventListener("click", cloudCommit);
el("cloudRecallBtn").addEventListener("click", cloudRecall);

el("themeToggleBtn").addEventListener("click", () => setTheme(theme === "wilderness" ? "town" : "wilderness"));

/* -----------------------------
   Init
----------------------------- */
renderHagTileVisibility();
showOnly("viewMain");
fetchAllIngredients();

/* -----------------------------
   EFFECT CONFIG (edit me)
   Add new effects INSIDE cfg only.
----------------------------- */
const EFFECTS_CONFIG = (() => {
  const cfg = {
    "Restore Health": {
      bonusDiceByRarity: { common: "1d6", uncommon: "1d8", rare: "1d12", legendary: "2d20" },
      baseNoteByRarity:  { common: "2d4", uncommon: "2d4", rare: "2d4", legendary: "2d4" },

      concentrateBonusDiceByRarity: { common: "2d6", uncommon: "2d8", rare: "2d12", legendary: "4d20" },
      concentrateBaseNoteByRarity:  { common: "4d4", uncommon: "4d4", rare: "4d4", legendary: "4d4" },

      valueByRarity: {
        common:    { gp: 0, sp: 5,  cp: 0 },
        uncommon:  { gp: 1, sp: 0,  cp: 0 },
        rare:      { gp: 5, sp: 0,  cp: 0 },
        legendary: { gp: 25, sp: 0, cp: 0 }
      },

      potionIconPath: "assets/icons/Red_Potion.webp",
      concentrateIconPath: "assets/icons/Red_Concentrate.webp"
    },

    "Resist Shock": {
      bonusDiceByRarity: { common: "1d6", uncommon: "1d8", rare: "1d12", legendary: "2d20" },
      baseNoteByRarity:  { common: "2d4", uncommon: "4d4", rare: "8d4", legendary: "10d4" },

      concentrateBonusDiceByRarity: { common: "2d6", uncommon: "2d8", rare: "2d12", legendary: "4d20" },
      concentrateBaseNoteByRarity:  { common: "4d4", uncommon: "8d4", rare: "16d4", legendary: "20d4" },

      valueByRarity: {
        common:    { gp: 0, sp: 5,  cp: 0 },
        uncommon:  { gp: 1, sp: 50, cp: 0 },
        rare:      { gp: 5, sp: 0,  cp: 0 },
        legendary: { gp: 50, sp: 0, cp: 0 }
      },

      potionIconPath: "assets/icons/Yellow_Resistance.webp",
      concentrateIconPath: "assets/icons/Yellow_Concentrate.webp"
    }

    // Add new effect entries above this line
  };

  // DO NOT ADD BELOW THIS LINE
  const out = {};
  for (const [k,v] of Object.entries(cfg)) out[normKey(k)] = v;
  return out;
})();
</script>
</body>
</html>
