<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Field Notes</title>

  <style>
    * { box-sizing: border-box; }

    :root{
      --ink:#000000;

      /* Dark app theme */
      --app-bg-1:#0a1020;
      --app-bg-2:#05070d;
      --panel-bg: rgba(26, 30, 40, 0.72);
      --panel-border: rgba(120, 130, 155, 0.38);
      --scene-bg: rgba(22, 26, 36, 0.70);
      --scene-border: rgba(120, 130, 155, 0.34);

      --edge:#d9c8aa;
      --good:#1f7a3a;
      --warn:#8a5a00;
      --bad:#8b1d2c;
      --shadow: 0 16px 40px rgba(0,0,0,0.38);
      --shadow2: 0 10px 24px rgba(0,0,0,0.32);

      --base: 13px;
      --small: 12px;
      --h1: 18px;

      /* Book UI scale */
      --book-ui: 0.84;

      /* Book overlay placement */
      --book-top: 19.8%;
      --book-bottom: 10%;
      --book-left: 3.6%;
      --book-right: 15.5%;
      --book-gap: 2.4%;
      --book-pad: 8px;

      /* Width control inside pages */
      --page-content-width: 78%;
      --line-width: 78%;
      --right-box-width: 96%;

      /* Right page shift: moves right page content left without touching left page */
      --right-page-shift: 150px;

      --brew-maxw: 1000px;

      /* Bag UI */
      --bag-maxw: 1100px;
      --bag-grid-min: 140px;

      /* Rarity colors */
      --rar-common: #2f9e44;   /* green */
      --rar-uncommon: #2b74ff; /* blue */
      --rar-rare: #9b59ff;     /* purple */
      --rar-legend: #ff8a00;   /* orange */

      /* Coin colors */
      --coin-gp: #d4af37; /* gold */
      --coin-sp: #c0c0c0; /* silver */
      --coin-cp: #b87333; /* copper */
    }

    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
    }

    body{
      color: #e9edf6;
      background:
        radial-gradient(1100px 640px at 12% 0%, rgba(90,120,255,0.10), transparent 60%),
        radial-gradient(900px 520px at 90% 20%, rgba(0,255,200,0.06), transparent 60%),
        linear-gradient(180deg, var(--app-bg-1), var(--app-bg-2));
      font-family: "Segoe Print","Bradley Hand","Comic Sans MS",cursive,system-ui;
      letter-spacing: 0.12px;
      font-size: var(--base);
      line-height: 1.15;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -webkit-touch-callout: none;
    }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 12px;
    }
    .hidden{ display:none !important; }

    button, input, select, textarea{
      font-size: var(--base);
      padding: 8px 9px;
      border-radius: 14px;
      border: 1px solid rgba(217,200,170,0.35);
      background: rgba(255,255,255,0.84);
      color: #000;
      outline: none;
      box-shadow: 0 2px 0 rgba(0,0,0,0.04) inset;
      font-family: inherit;
      line-height: 1.1;
      transition: all 120ms ease;
    }

    button:hover:not(:disabled){
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.12);
    }
    button:active:not(:disabled){
      transform: translateY(1px);
      box-shadow: 0 2px 0 rgba(0,0,0,0.04) inset;
    }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    input::placeholder, textarea::placeholder{
      color: rgba(0,0,0,0.45);
    }

    .btn-primary{
      background: linear-gradient(180deg, rgba(122,62,31,0.92), rgba(122,62,31,0.78));
      color: #fff7ee;
      border-color: rgba(122,62,31,0.45);
      box-shadow: 0 10px 22px rgba(0,0,0,0.28);
      font-weight: 900;
    }
    .btn-primary:hover:not(:disabled){
      box-shadow: 0 14px 28px rgba(0,0,0,0.32);
    }

    .btn-quiet{
      background: rgba(255,255,255,0.70);
      color: #000;
      font-weight: 900;
    }

    input:focus, select:focus, textarea:focus{
      border-color: rgba(122,62,31,0.6);
      box-shadow: 0 0 0 3px rgba(122,62,31,0.15) inset;
    }

    .muted{ color: rgba(233,237,246,0.78); font-size: var(--small); }

    .title{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
      flex-wrap: wrap;
    }
    h1{
      margin:0;
      font-size: var(--h1);
      line-height:1.05;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-weight: 900;
      color: #f2f6ff;
    }
    .sub{ margin-top:4px; color: rgba(233,237,246,0.78); font-size: var(--small); }

    /* Main screen */
    .main-grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: stretch;
    }
    @media (min-width: 860px){
      .main-grid{ grid-template-columns: 1fr 1fr; }
    }

    .panel{
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      background: var(--panel-bg);
      box-shadow: var(--shadow2);
      overflow:hidden;
      min-height: 220px;
      position: relative;
      transition: transform 200ms ease, box-shadow 200ms ease;
    }
    .panel:hover{
      transform: translateY(-2px);
      box-shadow: var(--shadow);
    }
    .panel button.overlayBtn{
      all: unset;
      cursor: pointer;
      display:block;
      width:100%;
      height:100%;
    }
    .panel img.coverArt{
      width:100%;
      height:100%;
      object-fit: contain;
      display:block;
      background: rgba(0,0,0,0.10);
      filter: saturate(1.02);
    }
    .panel .hint{
      position:absolute;
      left: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(20,22,30,0.88);
      box-shadow: 0 10px 20px rgba(0,0,0,0.32);
      font-weight: 900;
      color: #f2f6ff;
      font-size: var(--small);
      pointer-events: none;
      animation: pulse 2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ opacity:0.8; }
      50%{ opacity:1; }
    }

    /* Scene wrapper */
    .scene{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: var(--scene-bg);
      box-shadow: var(--shadow2);
      overflow:hidden;
      position: relative;
    }

    .sceneTopBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      background: rgba(15,18,26,0.62);
      flex-wrap: wrap;
    }
    .topLeftBtns{
      display:flex;
      gap: 8px;
      align-items:center;
      flex-wrap: wrap;
    }

    .backBtn{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.72);
      box-shadow: 0 8px 16px rgba(0,0,0,0.32);
      font-weight: 900;
      color: #f2f6ff;
      font-size: var(--small);
      cursor: pointer;
    }
    .backBtn:hover{
      background: rgba(30,35,50,0.82);
      box-shadow: 0 10px 20px rgba(0,0,0,0.40);
    }
    .backBtn img{ width: 16px; height: 16px; opacity: 0.92; filter: brightness(1.2); }

    /* Book layout */
    .bookWrap{
      position: relative;
      width:100%;
      height: min(86vh, 800px);
      min-height: 560px;
      background: rgba(0,0,0,0.10);
    }
    .bookBg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit: contain;
      opacity: 0.98;
      pointer-events:none;
      user-select:none;
      background: rgba(0,0,0,0.05);
    }

    .bookPages{
      position:absolute;
      top: var(--book-top);
      bottom: var(--book-bottom);
      left: var(--book-left);
      right: var(--book-right);
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--book-gap);
      align-items: stretch;
      box-sizing: border-box;
      z-index: 2;

      transform: scale(var(--book-ui));
      transform-origin: top left;
      width: calc(100% / var(--book-ui));
      height: calc(100% / var(--book-ui));
    }

    /* Force all book text black */
    .bookPages, .bookPages *{
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }
    .bookPages .muted{
      opacity: 1 !important;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }

    @media (max-width: 760px){
      :root{
        --book-top: 21.5%;
        --book-bottom: 12%;
        --book-left: 4.5%;
        --book-right: 10%;
        --book-gap: 10px;
        --book-ui: 0.88;
        --page-content-width: 90%;
        --line-width: 90%;
        --right-box-width: 98%;
        --right-page-shift: 0px;
      }
      .bookWrap{
        height: auto;
        min-height: 920px;
      }
      .bookPages{
        grid-template-columns: 1fr;
        gap: 12px;
      }
    }

    /* Page alignment */
    .page{
      border-radius: 14px;
      padding: var(--book-pad);
      background: rgba(255,255,255,0.00);
      overflow: hidden;
      min-height: 0;
      display:flex;
      justify-content:flex-start;
      flex-direction: column;
      align-items: stretch;
    }
    .pageInner{
      height: 100%;
      overflow:auto;
      padding-right: 6px;
      width: var(--page-content-width);
      max-width: var(--page-content-width);
      margin-left: 0;
      margin-right: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(0,0,0,0.2) transparent;
    }
    .pageInner::-webkit-scrollbar{ width: 4px; }
    .pageInner::-webkit-scrollbar-track{ background: transparent; }
    .pageInner::-webkit-scrollbar-thumb{ background: rgba(0,0,0,0.2); border-radius: 2px; }

    /* Right page: shift left (only right page) */
    .pageRight{
      justify-content: center;
      align-items: flex-start;
      overflow: visible;
    }
    .pageRight .pageInner{
      width: var(--right-box-width);
      max-width: var(--right-box-width);
      margin-left: 0;
      margin-right: auto;
      padding-right: 10px;
      transform: translateX(calc(-1 * var(--right-page-shift)));
      display:flex;
      flex-direction: column;
      height: 100%;
    }

    .leftCentered{
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }

    .page h2{
      margin: 0 0 6px 0;
      font-size: 13.5px;
      font-weight: 950;
      width: 100%;
    }
    .page h3{
      margin: 10px 0 6px 0;
      font-size: 12px;
      font-weight: 950;
      width: 100%;
    }
    .hr{
      height:1px;
      background: rgba(0,0,0,0.35);
      margin: 9px auto;
      width: var(--line-width);
    }

    .bookPages button, .bookPages input, .bookPages select, .bookPages textarea{
      font-size: var(--small);
      padding: 7px 8px;
      border-radius: 12px;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
    }
    .bookPages textarea::placeholder,
    .bookPages input::placeholder{
      opacity: 0.55 !important;
      -webkit-text-fill-color: rgba(0,0,0,0.55) !important;
    }

    .bookPages .btn-quiet,
    .bookPages button.backBtn,
    .bookPages button.smallBtn,
    .bookPages button.qtyBtn,
    .bookPages button#revealRandomBtn,
    .bookPages button#resetRevealsBtn{
      background: rgba(255,255,255,0.20);
      box-shadow: none;
      border: 1px solid rgba(0,0,0,0.18);
    }

    /* Index rows */
    .indexRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items:center;
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      box-shadow: none;
      margin: 0 auto 6px auto;
      width: var(--line-width);
      transition: background 150ms ease;
    }
    .indexRow:hover{ background: rgba(0,0,0,0.04); }

    @media (max-width: 420px){
      .indexRow{ grid-template-columns: 1fr; width: 100%; }
      .inventoryBox{ justify-content:flex-start; }
      .hr{ width: 100%; }
    }

    .ingNameBtn{
      all: unset;
      cursor:pointer;
      font-weight: 950;
      padding: 2px 3px;
      font-size: 12.5px;
      transition: opacity 120ms ease;
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
      opacity: 0.85;
    }
    .ingNameBtn:hover{ opacity: 1; }

    .inventoryBox{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap: 4px;
      flex-wrap: nowrap;
    }
    .count{
      min-width: 28px;
      text-align:center;
      font-weight: 950;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      font-size: var(--small);
    }
    .qtyBtn{
      padding: 4px 6px;
      border-radius: 10px;
      font-weight: 950;
      min-width: 28px;
      background: rgba(255,255,255,0.00);
      box-shadow:none;
      border: 1px solid rgba(0,0,0,0.22);
      font-size: var(--small);
    }

    /* Ingredient page */
    .noteBox{
      border-radius: 12px;
      border: 1px dashed rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.18);
      padding: 8px 9px;
      font-size: var(--small);
      line-height: 1.2;
      white-space: pre-wrap;
      word-break: break-word;
      width: 100%;
      color:#000 !important;
      -webkit-text-fill-color:#000 !important;
      max-height: 220px;
      overflow-y: auto;
    }

    .plantImg{
      width:100%;
      max-width: 250px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.12);
      box-shadow: none;
      display:block;
      margin: 0 auto;
    }

    .pill{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.22);
      background: rgba(255,255,255,0.00);
      font-size: var(--small);
      font-weight: 950;
      box-shadow:none;
    }
    .pill-rare{ border-color: rgba(31,122,58,0.40); }
    .pill-common{ border-color: rgba(122,62,31,0.40); }
    .pill-unknown{ border-color: rgba(0,0,0,0.22); }

    .effects{
      display:grid;
      gap: 7px;
      margin-top: 9px;
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }
    .effect-line{
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap: 6px;
      align-items: stretch;
    }
    .effect-text{
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px dashed rgba(0,0,0,0.28);
      background: rgba(255,255,255,0.18);
      box-shadow: none;
      min-height: 16px;
      display:flex;
      align-items:center;
      font-size: var(--small);
      line-height: 1.15;
      word-break: break-word;
    }
    .effect-hidden{
      color: transparent !important;
      -webkit-text-fill-color: transparent !important;
      text-shadow: 0 0 10px rgba(0,0,0,0.55);
      user-select: none;
    }
    .smallBtn{
      padding: 4px 8px;
      font-size: var(--small);
      border-radius: 10px;
      font-weight: 950;
      background: rgba(255,255,255,0.00);
      box-shadow:none;
      border: 1px solid rgba(0,0,0,0.22);
      white-space: nowrap;
    }

    /* Brewing UI */
    .brewPage{
      max-width: var(--brew-maxw);
      margin: 0 auto;
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .brewImageFrame{
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid var(--scene-border);
      background: rgba(0,0,0,0.15);
      box-shadow: var(--shadow2);
    }
    .brewBgImg{
      width:100%;
      height: min(52vh, 520px);
      min-height: 300px;
      object-fit: contain;
      background: rgba(0,0,0,0.10);
      display:block;
    }
    .brewControls{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: rgba(18, 22, 30, 0.72);
      box-shadow: var(--shadow);
      padding: 12px;
      color:#f2f6ff;
    }
    .brewControls .muted{ color: rgba(233,237,246,0.78); }

    .brewTopRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .themeBtn{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 7px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.72);
      box-shadow: 0 8px 16px rgba(0,0,0,0.32);
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
      cursor: pointer;
    }
    .themeBtn:hover{
      background: rgba(30,35,50,0.82);
      box-shadow: 0 10px 20px rgba(0,0,0,0.40);
    }
    .themeBtn img{ width: 16px; height: 16px; opacity: 0.92; filter: brightness(1.2); }

    .brewGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 760px){
      .brewGrid{ grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    }
    .slotTitle{ font-weight: 950; margin-bottom: 6px; font-size: var(--small); color:#f2f6ff; }
    .slotBox{
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,0.20);
      background: rgba(255,255,255,0.06);
      padding: 10px;
    }
    .slotBox select{ width: 100%; }

    .discoveredList{
      margin-top: 8px;
      display:flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .discoveredPill{
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      padding: 4px 8px;
      background: rgba(255,255,255,0.10);
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
    }

    .resultBox{
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      padding: 10px;
      font-size: var(--small);
      line-height: 1.2;
      color: #f2f6ff;
      min-height: 40px;
      display:flex;
      align-items:center;
    }

    .dcLine{
      margin-top: 8px;
      font-weight: 950;
      color: #f2f6ff;
      font-size: var(--small);
    }

    select{
      background: rgba(255,255,255,0.86);
      color:#000;
      border: 1px solid rgba(255,255,255,0.25);
    }

    /* Bag UI */
    .bagPage{
      max-width: var(--bag-maxw);
      margin: 0 auto;
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .bagFrame{
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid var(--scene-border);
      background: rgba(0,0,0,0.15);
      box-shadow: var(--shadow2);
      position: relative;
    }
    .bagBgImg{
      width:100%;
      height: min(60vh, 620px);
      min-height: 360px;
      object-fit: contain;
      background: rgba(0,0,0,0.10);
      display:block;
    }

    .bagOverlay{
      position:absolute;
      inset: 0;
      padding: 34px 44px 40px 44px;
      display:flex;
      align-items: stretch;
      justify-content: center;
      pointer-events: none;
    }
    @media (max-width: 760px){
      .bagOverlay{ padding: 26px 18px 26px 18px; }
    }

    .bagInner{
      width: min(980px, 100%);
      height: 100%;
      pointer-events: auto;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .bagHeader{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .bagTitle{
      font-weight: 1000;
      font-size: 14px;
      color:#f2f6ff;
    }

    .bagGrid{
      flex: 1 1 auto;
      overflow:auto;
      padding: 8px;
      border-radius: 16px;
      background: rgba(0,0,0,0.14);
      border: 1px solid rgba(255,255,255,0.10);
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--bag-grid-min), 1fr));
      gap: 10px;
    }

    .bagItem{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      padding: 10px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.22);
      display:flex;
      flex-direction: column;
      gap: 8px;
    }

    .bagTop{
      display:flex;
      align-items:center;
      justify-content: center;
      gap: 8px;
      flex-direction: column;
    }
    .bagIcon{
      width: 46px;
      height: 46px;
      object-fit: contain;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.25));
    }

    .bagLines{
      text-align:center;
      color:#f2f6ff;
      line-height: 1.12;
      display:flex;
      flex-direction: column;
      gap: 4px;
      min-height: 90px;
      justify-content: center;
    }
    .bagKind{
      font-weight: 1000;
      font-size: 13px;
    }
    .bagOf{
      font-weight: 950;
      font-size: 12.5px;
      opacity: 0.98;
    }
    .bagRarity{
      font-weight: 1000;
      font-size: 11px;
      opacity: 0.95;
    }
    .bagFormula{
      font-weight: 950;
      font-size: 12px;
      opacity: 0.95;
    }
    .bagValue{
      font-weight: 950;
      font-size: 11.5px;
      opacity: 0.95;
    }

    .qtyRow{
      display:flex;
      align-items:center;
      justify-content: center;
      gap: 6px;
      margin-top: 4px;
    }
    .qtyRow .count{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.20);
      color:#f2f6ff;
      min-width: 30px;
    }
    .qtyRow .qtyBtn{
      border-color: rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.08);
      color:#f2f6ff;
    }

    /* Rarity helpers */
    .rar-common{ color: var(--rar-common) !important; }
    .rar-uncommon{ color: var(--rar-uncommon) !important; }
    .rar-rare{ color: var(--rar-rare) !important; }
    .rar-legendary{ color: var(--rar-legend) !important; }

    /* Coin helpers */
    .coin-gp{ color: var(--coin-gp) !important; font-weight: 1000; }
    .coin-sp{ color: var(--coin-sp) !important; font-weight: 1000; }
    .coin-cp{ color: var(--coin-cp) !important; font-weight: 1000; }

    /* Mixing UI */
    .mixPage{
      max-width: var(--brew-maxw);
      margin: 0 auto;
      padding: 12px;
      display:flex;
      flex-direction: column;
      gap: 12px;
    }
    .mixControls{
      border-radius: 18px;
      border: 1px solid var(--scene-border);
      background: rgba(18, 22, 30, 0.72);
      box-shadow: var(--shadow);
      padding: 12px;
      color:#f2f6ff;
    }

    /* Modal overlay (brew success/fail entry, and mixing result confirmation) */
    .modalShade{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.64);
      display:none;
      z-index: 80;
      align-items: center;
      justify-content: center;
      padding: 14px;
    }
    .modal{
      width: min(720px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,22,30,0.96);
      box-shadow: var(--shadow);
      padding: 12px;
      color:#f2f6ff;
    }
    .modalHead{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      padding: 6px 4px 10px 4px;
      border-bottom: 1px solid rgba(255,255,255,0.14);
      margin-bottom: 10px;
    }
    .modalTitle{
      font-weight: 1000;
      font-size: 14px;
    }
    .modalBody{
      display:flex;
      flex-direction: column;
      gap: 10px;
      padding: 4px;
    }
    .rollRow{
      border-radius: 14px;
      border: 1px dashed rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      padding: 10px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }
    .rollRow .label{
      font-weight: 950;
      line-height: 1.15;
    }
    .rollRow input{
      width: 120px;
      text-align: center;
      font-weight: 1000;
    }
    .modalBtns{
      display:flex;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.14);
    }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(20,22,30,0.95);
      border: 1px solid rgba(255,255,255,0.18);
      color: #f2f6ff;
      border-radius: 999px;
      padding: 9px 12px;
      box-shadow: var(--shadow);
      max-width: calc(100vw - 32px);
      display:none;
      z-index: 90;
      font-size: var(--small);
      font-weight: 950;
    }
    .toast.good{ border-color: rgba(31,122,58,0.40); }
    .toast.bad{ border-color: rgba(139,29,44,0.45); }

    /* Collapsible */
    details{
      border: 1px dashed rgba(0,0,0,0.25);
      border-radius: 14px;
      background: rgba(255,255,255,0.12);
      padding: 10px;
      margin-top: 12px;
      width: var(--line-width);
      margin-left: auto;
      margin-right: auto;
    }
    details summary{
      cursor: pointer;
      font-weight: 950;
      list-style: none;
      font-size: var(--small);
    }
    details summary::-webkit-details-marker{ display:none; }
    .sigil{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      letter-spacing: 0.4px;
      font-size: 10px;
      opacity: 0.7;
    }

    /* Loading dot */
    .loading{
      display:inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: #f2f6ff;
      animation: spin 800ms linear infinite;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    @media (max-width: 480px){
      .title{ flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>Field Notes</h1>
        <div class="sub">A travel-worn record of leaves, powders, and quiet discoveries.</div>
      </div>
      <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button class="btn-quiet" id="refreshBtn" title="Pulls in any prepared ingredients.">
          <span id="refreshText">Update Notes</span>
        </button>
      </div>
    </div>

    <!-- MAIN -->
    <section id="viewMain">
      <div class="main-grid">
        <div class="panel" title="Open Field Notes">
          <button class="overlayBtn" id="openBookBtn" aria-label="Open Field Notes">
            <img class="coverArt" src="assets/ui/cover_closed.webp" alt="Field Notes cover" />
            <div class="hint">Tap to open</div>
          </button>
        </div>

        <div class="panel" title="Brewing">
          <button class="overlayBtn" id="openBrewBtn" aria-label="Open brewing">
            <img class="coverArt" src="assets/ui/cauldron_main.webp" alt="Brewing cauldron" />
            <div class="hint">Brewing</div>
          </button>
        </div>

        <div class="panel" title="Mixing">
          <button class="overlayBtn" id="openMixBtn" aria-label="Open mixing">
            <img class="coverArt" src="assets/ui/Mixer.webp" alt="Mixing kit" />
            <div class="hint">Mixing</div>
          </button>
        </div>

        <div class="panel" title="Bag">
          <button class="overlayBtn" id="openBagBtn" aria-label="Open bag">
            <img class="coverArt" src="assets/ui/Backpack.webp" alt="Backpack" />
            <div class="hint">Bag</div>
          </button>
        </div>
      </div>

      <div class="muted" style="margin-top:12px;">
        Your discoveries stay on this device.
      </div>
    </section>

    <!-- BOOK -->
    <section id="viewBook" class="scene hidden">
      <div class="sceneTopBar">
        <div class="topLeftBtns">
          <button class="backBtn" id="closeBookBtn" type="button" aria-label="Close book">
            <img src="assets/icons/arrow_back.webp" alt="" />
            Close
          </button>

          <button class="backBtn hidden" id="backToIndexTopBtn" type="button" aria-label="Back to Index">
            <img src="assets/icons/arrow_back.webp" alt="" />
            Index
          </button>
        </div>

        <div class="muted" id="bookStatus">Ready.</div>
      </div>

      <div class="bookWrap">
        <img class="bookBg" src="assets/ui/book_open.webp" alt="" />

        <!-- BOOK: INDEX SPREAD -->
        <div class="bookPages" id="spreadIndex">
          <div class="page">
            <div class="pageInner">
              <div class="leftCentered">
                <h2 style="text-align:center;">Index</h2>
                <div class="muted" style="text-align:center; margin-bottom:8px;">Tap a name to open its page.</div>
              </div>

              <div class="hr"></div>

              <div class="leftCentered">
                <h3>Record Ingredient</h3>
                <div class="muted">Write the mark you were given.</div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; width:100%;">
                  <input id="markInput" inputmode="numeric" placeholder="Mark" aria-label="Mark" />
                  <button class="btn-primary" id="recordBtn" type="button">Record</button>
                </div>
              </div>

              <div class="hr"></div>

              <div class="leftCentered">
                <h3 style="text-align:center;">Inventory</h3>
              </div>

              <div id="indexList"></div>

              <details>
                <summary>ðŸ“‹ Keep Safe</summary>
                <div class="muted" style="margin-top:8px;">
                  If you change devices, export your notes first.
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:9px;">
                  <button id="exportBtn" type="button">Export Notes</button>
                  <button id="importBtn" type="button">Import Notes</button>
                  <button id="wipeBtn" type="button">Burn All Notes</button>
                </div>
                <textarea id="saveBox" rows="6" style="width:100%; margin-top:9px;" placeholder="Notes appear here for export or import."></textarea>
                <div class="muted sigil" style="margin-top:8px;">
                  This page never sends your discoveries anywhere, unless you export them.
                </div>
              </details>
            </div>
          </div>

          <!-- Right page is now Concentrates inventory -->
          <div class="page pageRight">
            <div class="pageInner">
              <h2>Concentrates</h2>
              <div class="muted">Track what you carry. Crafting happens in Brewing.</div>
              <div class="hr" style="width:100%;"></div>
              <div id="concIndexList"></div>
            </div>
          </div>
        </div>

        <!-- BOOK: INGREDIENT SPREAD -->
        <div class="bookPages hidden" id="spreadIngredient">
          <div class="page">
            <div class="pageInner">
              <div style="width:var(--line-width); margin: 0 auto;">
                <h2 id="ingName" style="margin:0;">Ingredient</h2>
              </div>

              <div style="margin-top:8px; width:var(--line-width); margin-left:auto; margin-right:auto; text-align:center;">
                <span class="pill" id="rarityPill">Unknown</span>
              </div>

              <div style="margin-top:8px; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <img class="plantImg" id="ingImage" alt="Ingredient" />
              </div>

              <div style="margin-top:9px; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <h3 style="margin:0 0 6px 0;">Description</h3>
                <div class="noteBox" id="ingNotes"></div>
              </div>

              <div style="margin-top:9px; display:flex; gap:8px; flex-wrap:wrap; justify-content:center; width:var(--line-width); margin-left:auto; margin-right:auto;">
                <button id="revealRandomBtn" type="button">Reveal a Property</button>
                <button id="resetRevealsBtn" type="button" class="btn-quiet">Forget Properties</button>
              </div>

              <div class="effects" id="effectsList"></div>
            </div>
          </div>

          <div class="page pageRight">
            <div class="pageInner">
              <h2>Known Recipes</h2>
              <div class="muted">What you have learned so far.</div>
              <div class="hr" style="width:100%;"></div>
              <div id="recipesList" class="noteBox" style="max-height: 340px;"></div>
            </div>
          </div>
        </div>

      </div>
    </section>

    <!-- BREW -->
    <section id="viewBrew" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromBrewBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="brewStatus">Choose your ingredients.</div>
      </div>

      <div class="brewPage">
        <div class="brewImageFrame">
          <img class="brewBgImg" id="brewBg" src="assets/themes/wilderness_bg.webp" alt="" />
        </div>

        <div class="brewControls">
          <div class="brewTopRow">
            <button class="themeBtn" id="themeToggleBtn" type="button" aria-label="Switch theme">
              <img id="themeIcon" src="assets/icons/theme_wilderness.webp" alt="" />
              <span id="themeLabel">Wilderness</span>
            </button>

            <label style="display:flex; align-items:center; gap:7px; font-weight:950; color:#f2f6ff; font-size:var(--small); cursor:pointer;">
              <input type="checkbox" id="useThird" />
              Third ingredient (optional)
            </label>
          </div>

          <div class="brewGrid">
            <div class="slotBox">
              <div class="slotTitle">First ingredient</div>
              <select id="mixA"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discA"></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Second ingredient</div>
              <select id="mixB"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discB"></div>
            </div>

            <div class="slotBox hidden" id="thirdSlot">
              <div class="slotTitle">Third ingredient</div>
              <select id="mixC"></select>
              <div class="muted" style="margin-top:7px;">Discovered effects</div>
              <div class="discoveredList" id="discC"></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Brew</div>
              <button class="btn-primary" id="brewBtn" type="button" style="width:100%;">Brew</button>
              <div class="dcLine" id="brewDcLine">DC: â€”</div>
              <div class="resultBox" id="mixResult" style="margin-top:9px;">
                <div class="muted">No mixture yet.</div>
              </div>
            </div>
          </div>

          <div class="hr" style="width:100%; margin-top:12px; margin-bottom:12px; background: rgba(255,255,255,0.14);"></div>

          <div class="brewGrid">
            <div class="slotBox">
              <div class="slotTitle">Make a concentrate (cost: 4)</div>
              <div class="muted">Choose an ingredient you have, then choose a discovered property.</div>

              <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
                <select id="concFromIng" style="flex:1 1 220px;"></select>
                <select id="concEffect" style="flex:1 1 220px;"></select>
              </div>

              <div class="dcLine" id="concInfoLine" style="margin-top:10px;">Concentrate: â€”</div>

              <button class="btn-primary" id="makeConcBtn" type="button" style="width:100%; margin-top:10px;">
                Create Concentrate
              </button>

              <div class="muted" style="margin-top:10px;">
                Concentrates appear in the book (Concentrates page) and in your Bag.
              </div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Notes</div>
              <div class="muted" style="margin-top:6px; line-height:1.25;">
                Brewing consumes ingredients either way. If a shared property exists and you succeed, you create a potion and note the shared property.
              </div>
              <div class="muted" style="margin-top:10px; line-height:1.25;">
                Base is always <b>2d4</b>. You roll only the bonus and record it as <b>2d4+X</b>.
              </div>
            </div>
          </div>

          <div class="muted" style="margin-top:10px;">
            Brewing draws from your Inventory. If you lack an ingredient, the attempt is refused.
          </div>
        </div>
      </div>
    </section>

    <!-- MIXING -->
    <section id="viewMix" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromMixBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="mixStatus">Pick from your Bag and Concentrates.</div>
      </div>

      <div class="mixPage">
        <div class="mixControls">
          <div class="brewGrid">
            <div class="slotBox">
              <div class="slotTitle">First</div>
              <select id="mixItemA"></select>
              <div class="muted" style="margin-top:7px;">Details</div>
              <div class="resultBox" id="mixItemADetail"><div class="muted">â€”</div></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Second</div>
              <select id="mixItemB"></select>
              <div class="muted" style="margin-top:7px;">Details</div>
              <div class="resultBox" id="mixItemBDetail"><div class="muted">â€”</div></div>
            </div>

            <div class="slotBox">
              <div class="slotTitle">Mix</div>
              <button class="btn-primary" id="mixBtn" type="button" style="width:100%;">Mix</button>
              <div class="dcLine" id="mixDcLine">DC: â€”</div>
              <div class="resultBox" id="mixOut" style="margin-top:9px;">
                <div class="muted">No mixture yet.</div>
              </div>
            </div>
          </div>

          <div class="muted" style="margin-top:10px;">
            Rules: Potion + Potion and Potion + Concentrate are allowed. Final potion is capped at 3 effects. Mixed potions cannot be mixed again.
          </div>
        </div>
      </div>
    </section>

    <!-- BAG -->
    <section id="viewBag" class="scene hidden">
      <div class="sceneTopBar">
        <button class="backBtn" id="backFromBagBtn" type="button" aria-label="Back to main">
          <img src="assets/icons/arrow_back.webp" alt="" />
          Back
        </button>
        <div class="muted" id="bagStatus">Inventory.</div>
      </div>

      <div class="bagPage">
        <div class="bagFrame">
          <img class="bagBgImg" src="assets/ui/Backpack_UI.webp" alt="Bag" />

          <div class="bagOverlay">
            <div class="bagInner">
              <div class="bagHeader">
                <div class="bagTitle">Bag</div>
                <div class="muted">Honor system, adjust counts as needed.</div>
              </div>

              <div id="bagGrid" class="bagGrid"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

  </div>

  <div class="toast" id="toast"></div>

  <div class="modalShade" id="modalShade">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Record</div>
        <button id="modalCloseBtn" type="button">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
      <div class="modalBtns" id="modalBtns"></div>
    </div>
  </div>

  <audio id="sfxPage" src="assets/sfx/page_turn.mp3" preload="auto"></audio>
  <audio id="sfxSuccess" src="assets/sfx/brew_success.mp3" preload="auto"></audio>

<script>
  const SUPABASE_URL = "https://yjelzojkirlzdnwftupz.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlqZWx6b2praXJsemRud2Z0dXB6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAzNTk0MTEsImV4cCI6MjA4NTkzNTQxMX0.5TCIyj5cAUlCAmNc2yBOIdpfNoN4NLqOOfcnBVbCzZA";

  const REST_BASE = `${SUPABASE_URL}/rest/v1`;
  const INGREDIENTS_ENDPOINT = `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&order=id.asc`;
  const INGREDIENT_BY_MARK = (mark) => `${REST_BASE}/ingredients?select=id,name,effect_1,effect_2,effect_3,effect_4,image_path,rarity,notes&id=eq.${encodeURIComponent(mark)}&limit=1`;
  const PUBLIC_STORAGE_BASE = `${SUPABASE_URL}/storage/v1/object/public/`;

  const LOCAL_KEY = "field_notes_v2";
  let LOCAL = loadLocal();

  let REVEALS = LOCAL.reveals;
  let INDEX = LOCAL.index;
  let RECIPES = LOCAL.recipes;

  // New inventories
  // POTIONS: array of items with individual keys so different 2d4+X variants can coexist
  // CONCS: map keyed by concKey -> { key, effect, rarity, formula, value, qty }
  let POTIONS = LOCAL.potions;
  let CONCS = LOCAL.concentrates;

  let ING_BY_ID = {};
  let currentIngredientId = null;
  let theme = "wilderness";
  let isFetching = false;

  const viewMain = document.getElementById("viewMain");
  const viewBook = document.getElementById("viewBook");
  const viewBrew = document.getElementById("viewBrew");
  const viewMix = document.getElementById("viewMix");
  const viewBag = document.getElementById("viewBag");
  const spreadIndex = document.getElementById("spreadIndex");
  const spreadIngredient = document.getElementById("spreadIngredient");

  const el = (id) => document.getElementById(id);

  function headers() {
    return { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${SUPABASE_ANON_KEY}` };
  }

  function saveLocal() {
    LOCAL = {
      reveals: REVEALS,
      index: INDEX,
      recipes: RECIPES,
      potions: POTIONS,
      concentrates: CONCS
    };
    localStorage.setItem(LOCAL_KEY, JSON.stringify(LOCAL));
  }

  function loadLocal() {
    const raw = localStorage.getItem(LOCAL_KEY);
    if (!raw) return { reveals: {}, index: {}, recipes: [], potions: [], concentrates: {} };
    try {
      const parsed = JSON.parse(raw);

      const reveals = (parsed && typeof parsed.reveals === "object" && parsed.reveals) ? parsed.reveals : {};
      const index = (parsed && typeof parsed.index === "object" && parsed.index) ? parsed.index : {};
      const recipes = Array.isArray(parsed?.recipes) ? parsed.recipes : [];

      const cleanIndex = {};
      for (const [k,v] of Object.entries(index)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) cleanIndex[String(k)] = Math.floor(n);
      }

      const potions = Array.isArray(parsed?.potions) ? parsed.potions : [];
      const concentrates = (parsed && typeof parsed.concentrates === "object" && parsed.concentrates) ? parsed.concentrates : {};

      return { reveals, index: cleanIndex, recipes, potions, concentrates };
    } catch {
      return { reveals: {}, index: {}, recipes: [], potions: [], concentrates: {} };
    }
  }

  function toast(msg, kind) {
    const t = el("toast");
    t.className = "toast";
    if (kind === "good") t.classList.add("good");
    if (kind === "bad") t.classList.add("bad");
    t.textContent = msg;
    t.style.display = "block";
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => { t.style.display = "none"; }, 2200);
  }

  function playSfx(audioId) {
    const a = document.getElementById(audioId);
    if (!a) return;
    a.currentTime = 0;
    a.play().catch(() => {});
  }

  function showOnly(which) {
    viewMain.classList.add("hidden");
    viewBook.classList.add("hidden");
    viewBrew.classList.add("hidden");
    viewMix.classList.add("hidden");
    viewBag.classList.add("hidden");
    if (which === "main") viewMain.classList.remove("hidden");
    if (which === "book") viewBook.classList.remove("hidden");
    if (which === "brew") viewBrew.classList.remove("hidden");
    if (which === "mix") viewMix.classList.remove("hidden");
    if (which === "bag") viewBag.classList.remove("hidden");
  }

  function showBookSpread(which) {
    spreadIndex.classList.add("hidden");
    spreadIngredient.classList.add("hidden");
    el("backToIndexTopBtn").classList.toggle("hidden", which !== "ingredient");
    if (which === "index") spreadIndex.classList.remove("hidden");
    if (which === "ingredient") spreadIngredient.classList.remove("hidden");
  }

  function getImageUrl(image_path) {
    if (!image_path) return "";
    return `${PUBLIC_STORAGE_BASE}${image_path}?t=${Date.now()}`;
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "\"": "&quot;",
      "'": "&#39;"
    }[c]));
  }

  function placeholderImageDataUri(label) {
    const svg =
      `<svg xmlns='http://www.w3.org/2000/svg' width='800' height='800'>` +
      `<rect width='100%' height='100%' fill='%23ffffff'/>` +
      `<rect x='20' y='20' width='760' height='760' rx='38' ry='38' fill='%23f6f0e3' stroke='%23d9c8aa' stroke-width='6'/>` +
      `<text x='50%' y='52%' dominant-baseline='middle' text-anchor='middle' fill='%23000' font-size='42' font-family='Segoe Print,Bradley Hand,cursive'>${escapeHtml(label)}</text>` +
      `</svg>`;
    return "data:image/svg+xml," + encodeURIComponent(svg);
  }

  function rarityClass(r) {
    const v = String(r || "").trim().toLowerCase();
    if (!v) return "pill-unknown";
    if (v.includes("legend")) return "pill-rare";
    if (v.includes("rare") || v.includes("uncommon")) return "pill-rare";
    return "pill-common";
  }

  function rarityLabel(r) {
    const v = String(r || "").trim();
    return v ? v : "Unknown";
  }

  function rarityTier(r) {
    const v = String(r || "").trim().toLowerCase();
    if (v.includes("legend")) return "legendary";
    if (v.includes("rare")) return "rare";
    if (v.includes("uncommon")) return "uncommon";
    return "common";
  }

  function rarityCssClass(tier) {
    if (tier === "legendary") return "rar-legendary";
    if (tier === "rare") return "rar-rare";
    if (tier === "uncommon") return "rar-uncommon";
    return "rar-common";
  }

  function rarityDcBase(tier) {
    if (tier === "legendary") return 18;
    if (tier === "rare") return 15;
    if (tier === "uncommon") return 12;
    return 10;
  }

  function tierRank(tier) {
    if (tier === "legendary") return 4;
    if (tier === "rare") return 3;
    if (tier === "uncommon") return 2;
    return 1;
  }

  function bestTier(a, b) {
    return tierRank(a) >= tierRank(b) ? a : b;
  }

  function formatCoins(value) {
    const gp = Number(value?.gp) || 0;
    const sp = Number(value?.sp) || 0;
    const cp = Number(value?.cp) || 0;
    const parts = [];
    if (gp) parts.push(`<span class="coin-gp">${gp}gp</span>`);
    if (sp) parts.push(`<span class="coin-sp">${sp}sp</span>`);
    if (cp) parts.push(`<span class="coin-cp">${cp}cp</span>`);
    if (!parts.length) return `<span class="muted">0</span>`;
    return parts.join(" ");
  }

  function effectConfig(effectName) {
    const key = String(effectName || "").trim().toLowerCase();
    return POTION_EFFECTS[key] || null;
  }

  function valueForEffect(effectName, tier) {
    const cfg = effectConfig(effectName);
    const byTier = cfg?.value?.[tier];
    if (!byTier) return { gp: 0, sp: 0, cp: 0 };
    return {
      gp: Number(byTier.gp) || 0,
      sp: Number(byTier.sp) || 0,
      cp: Number(byTier.cp) || 0
    };
  }

  function addCoinValues(a, b) {
    return {
      gp: (Number(a?.gp)||0) + (Number(b?.gp)||0),
      sp: (Number(a?.sp)||0) + (Number(b?.sp)||0),
      cp: (Number(a?.cp)||0) + (Number(b?.cp)||0)
    };
  }

  function bonusDieLabelByTier(tier) {
    if (tier === "legendary") return "2d20"; // kept as requested (rarity-only)
    if (tier === "rare") return "d12";
    if (tier === "uncommon") return "d8";
    return "d6";
  }

  function concentrateBoostByTier(tier) {
    // Reward concentrates without extra DC (you asked not to punish concentrates).
    // This is a fixed bonus added to the concentrate formula line and to the effect when applied via mixing.
    // Tuned to feel meaningful without being absurd.
    if (tier === "legendary") return 6;
    if (tier === "rare") return 6;
    if (tier === "uncommon") return 4;
    return 3;
  }

  function modalHide() {
    el("modalShade").style.display = "none";
    el("modalBody").innerHTML = "";
    el("modalBtns").innerHTML = "";
  }

  function modalShow({ title, bodyNodes, buttons }) {
    el("modalTitle").textContent = title || "Record";
    const body = el("modalBody");
    const btns = el("modalBtns");
    body.innerHTML = "";
    btns.innerHTML = "";

    (bodyNodes || []).forEach(n => body.appendChild(n));
    (buttons || []).forEach(b => btns.appendChild(b));

    el("modalShade").style.display = "flex";
  }

  el("modalCloseBtn").addEventListener("click", modalHide);
  el("modalShade").addEventListener("click", (e) => {
    if (e.target === el("modalShade")) modalHide();
  });

  async function fetchAllIngredients() {
    if (isFetching) return;
    isFetching = true;

    el("refreshBtn").disabled = true;
    el("refreshText").innerHTML = '<span class="loading"></span>';

    el("bookStatus").textContent = "Turning pages...";
    el("brewStatus").textContent = "Stirring embers...";

    try {
      const res = await fetch(INGREDIENTS_ENDPOINT, { headers: headers() });
      if (!res.ok) throw new Error(await res.text());
      const rows = await res.json();

      ING_BY_ID = {};
      for (const r of rows) {
        const idStr = String(r.id);
        ING_BY_ID[idStr] = r;
        if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
      }

      for (const idStr of Object.keys(INDEX)) {
        if (!ING_BY_ID[idStr]) delete INDEX[idStr];
      }

      saveLocal();
      renderIndex();
      renderConcentratesIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateCraftChoices();
      updateBrewDcLine();
      renderBag();
      fillMixChoices();
      updateMixDcLine();

      el("bookStatus").textContent = "Ready.";
      el("brewStatus").textContent = "Choose your ingredients.";
      toast("Notes updated.", "good");
    } catch (e) {
      el("bookStatus").textContent = "Could not update.";
      el("brewStatus").textContent = "Could not update.";
      toast("The ink smudged. Try again.", "bad");
      console.error(e);
    } finally {
      isFetching = false;
      el("refreshBtn").disabled = false;
      el("refreshText").textContent = "Update Notes";
    }
  }

  async function fetchOne(mark) {
    const res = await fetch(INGREDIENT_BY_MARK(mark), { headers: headers() });
    if (!res.ok) throw new Error(await res.text());
    const rows = await res.json();
    return rows?.[0] || null;
  }

  function sortedIndexIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id]);
    ids.sort((a,b) => Number(a) - Number(b));
    return ids;
  }

  function setQty(idStr, qty) {
    const q = Math.max(0, Math.floor(Number(qty) || 0));
    INDEX[String(idStr)] = q;
    saveLocal();
  }

  function renderIndex() {
    const wrap = el("indexList");
    wrap.innerHTML = "";

    const ids = sortedIndexIds();
    if (ids.length === 0) {
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No entries yet.";
      wrap.appendChild(d);
      return;
    }

    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      const name = row?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;

      const line = document.createElement("div");
      line.className = "indexRow";

      const left = document.createElement("div");
      const nameBtn = document.createElement("button");
      nameBtn.type = "button";
      nameBtn.className = "ingNameBtn";
      nameBtn.textContent = name;
      nameBtn.addEventListener("click", () => {
        playSfx("sfxPage");
        openIngredient(idStr);
      });
      left.appendChild(nameBtn);

      const right = document.createElement("div");
      right.className = "inventoryBox";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "âˆ’";
      minus.addEventListener("click", () => {
        setQty(idStr, qty - 1);
        renderIndex();
        fillBrewChoices();
        renderBrewDiscovered();
        fillConcentrateCraftChoices();
        updateBrewDcLine();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        setQty(idStr, qty + 1);
        renderIndex();
        fillBrewChoices();
        renderBrewDiscovered();
        fillConcentrateCraftChoices();
        updateBrewDcLine();
      });

      right.appendChild(minus);
      right.appendChild(count);
      right.appendChild(plus);

      line.appendChild(left);
      line.appendChild(right);
      wrap.appendChild(line);
    }
  }

  async function recordIngredientFromMark(mark) {
    const clean = String(mark || "").replace(/\D/g, "");
    if (!clean) {
      toast("Enter a mark.", "bad");
      return;
    }

    if (ING_BY_ID[clean]) {
      if (INDEX[clean] === undefined) INDEX[clean] = 0;
      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateCraftChoices();
      updateBrewDcLine();
      toast("Recorded.", "good");
      el("markInput").value = "";
      return;
    }

    try {
      el("recordBtn").disabled = true;
      const row = await fetchOne(clean);
      if (!row) {
        toast("That mark is unknown.", "bad");
        el("recordBtn").disabled = false;
        return;
      }
      ING_BY_ID[clean] = row;
      if (!REVEALS[clean]) REVEALS[clean] = [false,false,false,false];
      if (INDEX[clean] === undefined) INDEX[clean] = 0;
      saveLocal();
      renderIndex();
      fillBrewChoices();
      renderBrewDiscovered();
      fillConcentrateCraftChoices();
      updateBrewDcLine();
      toast("Recorded.", "good");
      el("markInput").value = "";
      el("recordBtn").disabled = false;
    } catch {
      toast("Could not read that mark.", "bad");
      el("recordBtn").disabled = false;
    }
  }

  function openIngredient(idStr) {
    currentIngredientId = idStr;
    showBookSpread("ingredient");
    renderIngredient(idStr);
  }

  function renderIngredient(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) {
      toast("That page is missing.", "bad");
      showBookSpread("index");
      return;
    }

    el("ingName").textContent = row.name || "Unknown Ingredient";
    const pill = el("rarityPill");
    pill.className = "pill " + rarityClass(row?.rarity);
    pill.textContent = rarityLabel(row?.rarity);

    const imgUrl = getImageUrl(row.image_path);
    el("ingImage").src = imgUrl || placeholderImageDataUri("No sketch");
    el("ingImage").onerror = () => {
      el("ingImage").src = placeholderImageDataUri(row.name);
    };

    el("ingNotes").textContent = row.notes ? String(row.notes) : "No notes written yet.";

    const effects = [row.effect_1,row.effect_2,row.effect_3,row.effect_4].map(v => v || "");
    const revealed = REVEALS[idStr] || [false,false,false,false];

    const list = el("effectsList");
    list.innerHTML = "";

    effects.forEach((eff, idx) => {
      const line = document.createElement("div");
      line.className = "effect-line";

      const label = document.createElement("div");
      label.className = "pill";
      label.textContent = `Property ${idx + 1}`;

      const text = document.createElement("div");
      text.className = "effect-text";
      text.textContent = eff || "(blank)";
      if (!revealed[idx]) text.classList.add("effect-hidden");

      const btn = document.createElement("button");
      btn.className = "smallBtn";
      btn.textContent = revealed[idx] ? "Known" : "Reveal";
      btn.disabled = revealed[idx];
      btn.addEventListener("click", () => {
        REVEALS[idStr][idx] = true;
        saveLocal();
        renderIngredient(idStr);
        toast("Noted.", "good");
      });

      line.appendChild(label);
      line.appendChild(text);
      line.appendChild(btn);
      list.appendChild(line);
    });

    el("revealRandomBtn").onclick = () => {
      const hidden = [];
      for (let i = 0; i < 4; i++) if (!REVEALS[idStr][i]) hidden.push(i);
      if (hidden.length === 0) {
        toast("Nothing more to learn here.", "good");
        return;
      }
      const pick = hidden[Math.floor(Math.random() * hidden.length)];
      REVEALS[idStr][pick] = true;
      saveLocal();
      renderIngredient(idStr);
      toast("Noted.", "good");
    };

    el("resetRevealsBtn").onclick = () => {
      REVEALS[idStr] = [false,false,false,false];
      saveLocal();
      renderIngredient(idStr);
      toast("Forgotten.", "bad");
    };

    renderRecipesForIngredient(idStr);
  }

  function renderRecipesForIngredient(idStr) {
    const box = el("recipesList");
    const nameOf = (iid) => ING_BY_ID[iid]?.name || `Ingredient ${iid}`;

    const related = RECIPES.filter(r => Array.isArray(r.ids) && r.ids.includes(idStr));
    if (related.length === 0) {
      box.textContent = "No recipes recorded yet.";
      return;
    }

    const lines = related.map(r => {
      const parts = r.ids.map(x => nameOf(String(x)));
      const effects = Array.isArray(r.effects) ? r.effects : [];
      const effText = effects.length ? effects.join(", ") : "Unknown";
      return `â€¢ ${parts.join(" + ")} = Concoction of ${effText}`;
    });

    box.textContent = lines.join("\n");
  }

  function setTheme(next) {
    theme = next;
    if (theme === "wilderness") {
      el("brewBg").src = "assets/themes/wilderness_bg.webp?t=" + Date.now();
      el("themeIcon").src = "assets/icons/theme_wilderness.webp?t=" + Date.now();
      el("themeLabel").textContent = "Wilderness";
    } else {
      el("brewBg").src = "assets/themes/town_bg.webp?t=" + Date.now();
      // Placeholder icon path, you can replace this asset later if you want a different image.
      el("themeIcon").src = "assets/icons/theme_town.webp?t=" + Date.now();
      el("themeLabel").textContent = "Town";
    }
    el("themeIcon").onerror = () => {
      // If the file doesn't exist yet, fall back to a generic placeholder.
      el("themeIcon").src = placeholderImageDataUri("Theme");
    };
  }

  function availableForBrewIds() {
    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id] && (Number(INDEX[id]) || 0) > 0);
    ids.sort((a,b) => Number(a) - Number(b));
    return ids;
  }

  function fillBrewChoices() {
    const a = el("mixA"), b = el("mixB"), c = el("mixC");
    const ids = availableForBrewIds();

    if (ids.length < 2) {
      a.innerHTML = "";
      b.innerHTML = "";
      c.innerHTML = "";
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      renderBrewDiscovered();
      updateBrewDcLine();
      return;
    }

    const opts = ids.map(idStr => {
      const name = ING_BY_ID[idStr]?.name || "Unknown";
      const qty = Number(INDEX[idStr]) || 0;
      return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
    }).join("");

    const prevA = a.value, prevB = b.value, prevC = c.value;

    a.innerHTML = opts;
    b.innerHTML = opts;
    c.innerHTML = opts;

    a.value = ids.includes(prevA) ? prevA : ids[0];
    const bCandidate = ids.includes(prevB) ? prevB : ids.find(x => x !== a.value);
    b.value = (bCandidate && bCandidate !== a.value) ? bCandidate : (ids.find(x => x !== a.value) || ids[0]);

    const cDefault = ids.find(x => x !== a.value && x !== b.value) || ids[0];
    c.value = ids.includes(prevC) ? prevC : cDefault;
    if (el("useThird").checked && (c.value === a.value || c.value === b.value)) c.value = cDefault;

    renderBrewDiscovered();
    updateBrewDcLine();
  }

  function enforceDistinctMixing() {
    const a = el("mixA"), b = el("mixB"), c = el("mixC");
    const ids = availableForBrewIds();

    if (a.value && b.value && a.value === b.value) {
      const next = ids.find(x => x !== a.value);
      if (next) b.value = next;
    }

    if (el("useThird").checked) {
      if (c.value === a.value || c.value === b.value) {
        const nextC = ids.find(x => x !== a.value && x !== b.value);
        if (nextC) c.value = nextC;
      }
      if (a.value === c.value) {
        const nextA = ids.find(x => x !== c.value && x !== b.value);
        if (nextA) a.value = nextA;
      }
      if (b.value === c.value) {
        const nextB = ids.find(x => x !== c.value && x !== a.value);
        if (nextB) b.value = nextB;
      }
    }

    renderBrewDiscovered();
    updateBrewDcLine();
    fillConcentrateCraftChoices();
  }

  function discoveredEffectsFor(idStr) {
    const row = ING_BY_ID[idStr];
    if (!row) return [];
    const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
    const revealed = REVEALS[idStr] || [false,false,false,false];
    const known = [];
    for (let i = 0; i < 4; i++) {
      if (revealed[i] && effs[i]) known.push(String(effs[i]));
    }
    return known;
  }

  function renderDiscoveredInto(containerId, effects) {
    const wrap = el(containerId);
    wrap.innerHTML = "";
    if (!effects.length) {
      const s = document.createElement("div");
      s.className = "muted";
      s.textContent = "None yet.";
      wrap.appendChild(s);
      return;
    }
    effects.forEach(e => {
      const p = document.createElement("div");
      p.className = "discoveredPill";
      p.textContent = e;
      wrap.appendChild(p);
    });
  }

  function renderBrewDiscovered() {
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    renderDiscoveredInto("discA", aId ? discoveredEffectsFor(aId) : []);
    renderDiscoveredInto("discB", bId ? discoveredEffectsFor(bId) : []);
    if (useThird) renderDiscoveredInto("discC", cId ? discoveredEffectsFor(cId) : []);
  }

  function computeShared(ids) {
    const rows = ids.map(id => ING_BY_ID[id]).filter(Boolean);
    if (rows.length < 2) return [];
    const sets = rows.map(r => new Set([r.effect_1,r.effect_2,r.effect_3,r.effect_4].filter(Boolean)));
    let shared = sets[0];
    for (let i = 1; i < sets.length; i++) {
      shared = new Set([...shared].filter(x => sets[i].has(x)));
    }
    return [...shared];
  }

  function canSpend(ids) {
    const needed = {};
    for (const id of ids) needed[id] = (needed[id] || 0) + 1;
    for (const [id, n] of Object.entries(needed)) {
      const have = Number(INDEX[id]) || 0;
      if (have < n) return false;
    }
    return true;
  }

  function spend(ids) {
    const needed = {};
    for (const id of ids) needed[id] = (needed[id] || 0) + 1;
    for (const [id, n] of Object.entries(needed)) {
      setQty(id, (Number(INDEX[id]) || 0) - n);
    }
  }

  function revealSharedAutomatically(ids, shared) {
    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      if (!row) continue;
      const effs = [row.effect_1,row.effect_2,row.effect_3,row.effect_4];
      if (!REVEALS[idStr]) REVEALS[idStr] = [false,false,false,false];
      for (let i = 0; i < 4; i++) {
        if (shared.includes(effs[i])) REVEALS[idStr][i] = true;
      }
    }
    saveLocal();
  }

  function recordRecipe(ids, shared) {
    const norm = ids.map(String).slice().sort((a,b) => Number(a) - Number(b));
    const key = norm.join("+") + "::" + shared.slice().sort().join("|");
    const exists = RECIPES.some(r =>
      (Array.isArray(r.ids) ? r.ids.slice().sort((a,b)=>Number(a)-Number(b)).join("+") : "") +
      "::" +
      (Array.isArray(r.effects)? r.effects.slice().sort().join("|"):"") === key
    );
    if (exists) return;
    RECIPES.push({ ids: norm, effects: shared.slice(), at: Date.now() });
    saveLocal();
  }

  function highestRarityTierForIngredientIds(ids) {
    let tier = "common";
    for (const idStr of ids) {
      const row = ING_BY_ID[idStr];
      if (!row) continue;
      tier = bestTier(tier, rarityTier(row.rarity));
    }
    return tier;
  }

  function updateBrewDcLine() {
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";
    const ids = [aId,bId].filter(Boolean);
    if (useThird && cId) ids.push(cId);

    if (ids.length < 2) {
      el("brewDcLine").textContent = "DC: â€”";
      return;
    }

    const tier = highestRarityTierForIngredientIds(ids);
    let dc = rarityDcBase(tier);
    if (ids.length === 3) dc += 2;

    el("brewDcLine").textContent = `DC: ${dc}`;
  }

  function makePotionKey({ kind, effects, isMixed }) {
    const normEffects = (effects || [])
      .map(e => ({
        name: String(e.name || "").trim(),
        bonus: Number(e.bonus) || 0,
        base: "2d4",
        tier: String(e.tier || "common")
      }))
      .sort((a,b) => (a.name.localeCompare(b.name) || a.bonus - b.bonus));

    const signature = normEffects.map(e => `${e.name}::${e.tier}::${e.base}+${e.bonus}`).join("||");
    return `${kind}::${isMixed ? "mixed" : "base"}::${signature}`;
  }

  function potionValue(effects) {
    let total = { gp:0, sp:0, cp:0 };
    for (const e of effects || []) {
      total = addCoinValues(total, valueForEffect(e.name, e.tier));
    }
    return total;
  }

  function brew() {
    const aId = el("mixA").value;
    const bId = el("mixB").value;
    const useThird = el("useThird").checked;
    const cId = useThird ? el("mixC").value : "";

    if (aId && bId && aId === bId) {
      toast("Choose two different ingredients.", "bad");
      el("mixResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Choose two different ingredients.</div>`;
      enforceDistinctMixing();
      return;
    }
    if (useThird) {
      if ((aId && cId && aId === cId) || (bId && cId && bId === cId)) {
        toast("Each ingredient must be different.", "bad");
        el("mixResult").innerHTML = `<div style="color:var(--warn); font-weight:950;">Each ingredient must be different.</div>`;
        enforceDistinctMixing();
        return;
      }
    }

    const ids = [aId,bId].filter(Boolean);
    if (useThird && cId) ids.push(cId);

    if (ids.length < 2) {
      el("mixResult").innerHTML = `<div class="muted">Keep at least two ingredients in your Inventory to brew.</div>`;
      return;
    }

    if (!canSpend(ids)) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">Not enough in the Inventory.</div>
        <div class="muted" style="margin-top:6px;">You are missing one of the chosen ingredients.</div>
      `;
      toast("Not enough in the Inventory.", "bad");
      return;
    }

    const shared = computeShared(ids);

    // Spend immediately (your tabletop rule says ingredients are consumed either way)
    spend(ids);
    renderIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateCraftChoices();
    updateBrewDcLine();

    if (shared.length === 0) {
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">The mixture fizzles.</div>
        <div class="muted" style="margin-top:6px;">Nothing in common, nothing takes hold.</div>
      `;
      toast("Fizzled.", "bad");
      return;
    }

    // Determine rarity tier for potion (highest rarity among ingredients)
    const tier = highestRarityTierForIngredientIds(ids);
    const dc = rarityDcBase(tier) + (ids.length === 3 ? 2 : 0);

    // Auto reveal shared on the ingredients
    revealSharedAutomatically(ids, shared);
    recordRecipe(ids, shared);

    // Prompt player for bonus roll values (one per shared effect)
    const nodes = [];
    const inputs = [];
    const note = document.createElement("div");
    note.className = "muted";
    note.style.lineHeight = "1.25";
    note.innerHTML = `DC: <b>${dc}</b> (Base by rarity, +2 if 3 ingredients).<br/>Base is <b>2d4</b>. Roll only the bonus (<b>${bonusDieLabelByTier(tier)}</b>) and record it as <b>2d4+X</b>.`;
    nodes.push(note);

    shared.forEach((eff) => {
      const row = document.createElement("div");
      row.className = "rollRow";

      const label = document.createElement("div");
      label.className = "label";
      label.textContent = `Concoction of ${String(eff)}`;

      const input = document.createElement("input");
      input.type = "number";
      input.inputMode = "numeric";
      input.placeholder = "Bonus";
      input.min = "0";
      input.step = "1";
      inputs.push({ effect: String(eff), input });

      row.appendChild(label);
      row.appendChild(input);
      nodes.push(row);
    });

    const btnSuccess = document.createElement("button");
    btnSuccess.className = "btn-primary";
    btnSuccess.type = "button";
    btnSuccess.textContent = "Success, record potion";
    btnSuccess.addEventListener("click", () => {
      // Validate inputs
      const effects = [];
      for (const it of inputs) {
        const n = Number(it.input.value);
        if (!Number.isFinite(n) || n < 0) {
          toast("Enter a bonus number for each effect.", "bad");
          return;
        }
        effects.push({
          name: it.effect,
          tier,
          base: "2d4",
          bonus: Math.floor(n)
        });
      }

      const val = potionValue(effects);
      const key = makePotionKey({ kind: "concoction", effects, isMixed: false });

      // Store as distinct potion item
      const existing = POTIONS.find(p => p.key === key);
      if (existing) {
        existing.qty = (Number(existing.qty)||0) + 1;
      } else {
        POTIONS.push({
          key,
          kind: "concoction",
          isMixed: false,
          effects,
          tier,
          value: val,
          qty: 1,
          at: Date.now()
        });
      }

      saveLocal();
      playSfx("sfxSuccess");
      renderBag();
      fillMixChoices();

      const effectText = shared.join(", ");
      el("mixResult").innerHTML = `
        <div style="color:rgba(120,255,170,0.95); font-weight:1000;">Concoction recorded: ${escapeHtml(effectText)}</div>
        <div class="muted" style="margin-top:6px;">Open Bag to adjust counts anytime.</div>
      `;
      toast("A concoction is born.", "good");
      modalHide();
    });

    const btnFail = document.createElement("button");
    btnFail.type = "button";
    btnFail.textContent = "Failure (consume, no potion)";
    btnFail.addEventListener("click", () => {
      toast("Failed brew recorded.", "bad");
      el("mixResult").innerHTML = `
        <div style="color:var(--warn); font-weight:950;">Failed brew.</div>
        <div class="muted" style="margin-top:6px;">Ingredients consumed.</div>
      `;
      modalHide();
    });

    const btnCancel = document.createElement("button");
    btnCancel.type = "button";
    btnCancel.textContent = "Cancel";
    btnCancel.addEventListener("click", modalHide);

    modalShow({
      title: "Record Brewing Result",
      bodyNodes: nodes,
      buttons: [btnCancel, btnFail, btnSuccess]
    });
  }

  // Concentrates
  function concKey(effectName, tier) {
    return `${String(effectName||"").trim().toLowerCase()}::${tier}`;
  }

  function renderConcentratesIndex() {
    const wrap = el("concIndexList");
    wrap.innerHTML = "";

    const keys = Object.keys(CONCS || {});
    keys.sort((a,b) => a.localeCompare(b));

    if (!keys.length) {
      const d = document.createElement("div");
      d.className = "muted";
      d.textContent = "No concentrates yet.";
      wrap.appendChild(d);
      return;
    }

    for (const k of keys) {
      const c = CONCS[k];
      if (!c) continue;

      const qty = Number(c.qty) || 0;

      const line = document.createElement("div");
      line.className = "indexRow";
      line.style.width = "100%";

      const left = document.createElement("div");
      left.style.fontWeight = "950";
      left.innerHTML = `Concentrate of ${escapeHtml(c.effect)} <span class="${rarityCssClass(c.tier)}" style="font-weight:1000; margin-left:6px;">${escapeHtml(capTier(c.tier))}</span>`;

      const right = document.createElement("div");
      right.className = "inventoryBox";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "âˆ’";
      minus.addEventListener("click", () => {
        c.qty = Math.max(0, qty - 1);
        if (c.qty === 0) delete CONCS[k];
        saveLocal();
        renderConcentratesIndex();
        renderBag();
        fillMixChoices();
      });

      const count = document.createElement("div");
      count.className = "count";
      count.textContent = String(qty);

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";
      plus.addEventListener("click", () => {
        c.qty = qty + 1;
        saveLocal();
        renderConcentratesIndex();
        renderBag();
        fillMixChoices();
      });

      right.appendChild(minus);
      right.appendChild(count);
      right.appendChild(plus);

      line.appendChild(left);
      line.appendChild(right);
      wrap.appendChild(line);
    }
  }

  function fillConcentrateCraftChoices() {
    const selIng = el("concFromIng");
    const selEff = el("concEffect");

    const ids = Object.keys(INDEX).filter(id => ING_BY_ID[id] && (Number(INDEX[id])||0) > 0);
    ids.sort((a,b) => Number(a)-Number(b));

    if (ids.length === 0) {
      selIng.innerHTML = `<option value="">(No ingredients in inventory)</option>`;
      selEff.innerHTML = `<option value="">(No properties)</option>`;
      el("concInfoLine").textContent = "Concentrate: â€”";
      el("makeConcBtn").disabled = true;
      return;
    }

    const prev = selIng.value;
    selIng.innerHTML = ids.map(idStr => {
      const name = ING_BY_ID[idStr]?.name || "Unknown";
      const qty = Number(INDEX[idStr])||0;
      return `<option value="${escapeHtml(idStr)}">${escapeHtml(name)} (${qty})</option>`;
    }).join("");

    selIng.value = ids.includes(prev) ? prev : ids[0];
    fillConcentrateEffectsForSelected();
  }

  function fillConcentrateEffectsForSelected() {
    const selIng = el("concFromIng");
    const selEff = el("concEffect");

    const idStr = selIng.value;
    const known = idStr ? discoveredEffectsFor(idStr) : [];

    if (!known.length) {
      selEff.innerHTML = `<option value="">(No discovered properties)</option>`;
      el("concInfoLine").textContent = "Concentrate: Choose a discovered property.";
      el("makeConcBtn").disabled = true;
      return;
    }

    const prevEff = selEff.value;
    selEff.innerHTML = known.map(e => `<option value="${escapeHtml(e)}">${escapeHtml(e)}</option>`).join("");
    selEff.value = known.includes(prevEff) ? prevEff : known[0];

    const tier = idStr ? rarityTier(ING_BY_ID[idStr]?.rarity) : "common";
    const boost = concentrateBoostByTier(tier);
    const effName = selEff.value;

    const val = valueForEffect(effName, tier);
    el("concInfoLine").innerHTML = `Concentrate of <b>${escapeHtml(effName)}</b> (<span class="${rarityCssClass(tier)}">${escapeHtml(capTier(tier))}</span>) | Formula: <b>2d4+${boost}</b> | Value: ${formatCoins(val)}`;

    // Need 4 units of the selected ingredient
    const have = Number(INDEX[idStr]) || 0;
    el("makeConcBtn").disabled = !(have >= 4);
  }

  function capTier(tier) {
    if (tier === "legendary") return "Legendary";
    if (tier === "rare") return "Rare";
    if (tier === "uncommon") return "Uncommon";
    return "Common";
  }

  function makeConcentrate() {
    const idStr = el("concFromIng").value;
    const eff = el("concEffect").value;

    if (!idStr || !ING_BY_ID[idStr]) {
      toast("Choose an ingredient.", "bad");
      return;
    }
    if (!eff) {
      toast("Choose a discovered property.", "bad");
      return;
    }

    const have = Number(INDEX[idStr]) || 0;
    if (have < 4) {
      toast("Need 4 of that ingredient.", "bad");
      return;
    }

    const tier = rarityTier(ING_BY_ID[idStr]?.rarity);
    const boost = concentrateBoostByTier(tier);
    const key = concKey(eff, tier);

    // Spend 4 units
    setQty(idStr, have - 4);
    renderIndex();
    fillBrewChoices();
    renderBrewDiscovered();
    fillConcentrateCraftChoices();
    updateBrewDcLine();

    const val = valueForEffect(eff, tier);
    if (!CONCS[key]) {
      CONCS[key] = {
        key,
        effect: String(eff),
        tier,
        boost,
        base: "2d4",
        value: val,
        qty: 0,
        at: Date.now()
      };
    }
    CONCS[key].qty = (Number(CONCS[key].qty)||0) + 1;

    saveLocal();
    playSfx("sfxSuccess"); // requested: concentrate should use brew success sound
    renderConcentratesIndex();
    renderBag();
    fillMixChoices();

    toast("Concentrate created.", "good");
  }

  // Bag rendering
  function potionDisplayName(p) {
    // Centered "Concoction" then "of X" etc
    const effectNames = (p.effects || []).map(e => String(e.name));
    if (!effectNames.length) return "Unknown";
    if (effectNames.length === 1) return effectNames[0];
    return effectNames.join(" + ");
  }

  function potionRarityTier(p) {
    // Use stored tier if present
    return String(p.tier || "common");
  }

  function potionFormulaLine(p) {
    // For a potion with multiple effects, show one per effect separated by " | " as 2d4+X
    // For concentrates, same.
    const parts = (p.effects || []).map(e => `2d4+${Number(e.bonus)||0}`);
    return parts.join(" | ");
  }

  function valueLineForPotion(p) {
    const v = p.value || potionValue(p.effects||[]);
    return formatCoins(v);
  }

  function renderBag() {
    const grid = el("bagGrid");
    grid.innerHTML = "";

    const items = [];

    // Potions
    for (const p of (POTIONS || [])) {
      const qty = Number(p.qty) || 0;
      if (qty <= 0) continue;
      items.push({ type: "potion", data: p });
    }

    // Concentrates in bag
    for (const k of Object.keys(CONCS || {})) {
      const c = CONCS[k];
      const qty = Number(c?.qty) || 0;
      if (!c || qty <= 0) continue;
      items.push({ type: "conc", data: c });
    }

    // Sort for stable viewing
    items.sort((a,b) => {
      const an = a.type === "potion" ? potionDisplayName(a.data) : a.data.effect;
      const bn = b.type === "potion" ? potionDisplayName(b.data) : b.data.effect;
      return an.localeCompare(bn);
    });

    if (!items.length) {
      const d = document.createElement("div");
      d.className = "muted";
      d.style.padding = "10px";
      d.textContent = "Bag is empty.";
      grid.appendChild(d);
      return;
    }

    items.forEach((it) => {
      const card = document.createElement("div");
      card.className = "bagItem";

      const top = document.createElement("div");
      top.className = "bagTop";

      const icon = document.createElement("img");
      icon.className = "bagIcon";
      if (it.type === "conc") icon.src = "assets/icons/Generic_Concentrate.webp";
      else icon.src = "assets/icons/Generic_Potion.webp";
      icon.alt = "";
      icon.onerror = () => { icon.src = placeholderImageDataUri("Item"); };

      const lines = document.createElement("div");
      lines.className = "bagLines";

      if (it.type === "conc") {
        const c = it.data;
        const tier = c.tier || "common";
        const rarityCls = rarityCssClass(tier);
        const kind = document.createElement("div");
        kind.className = "bagKind";
        kind.textContent = "Concentrate";

        const of = document.createElement("div");
        of.className = "bagOf";
        of.textContent = `of ${c.effect}`;

        const rar = document.createElement("div");
        rar.className = "bagRarity " + rarityCls;
        rar.textContent = capTier(tier);

        const formula = document.createElement("div");
        formula.className = "bagFormula";
        formula.textContent = `2d4+${Number(c.boost)||0}`;

        const val = document.createElement("div");
        val.className = "bagValue";
        val.innerHTML = valueLineForConcentrate(c);

        lines.appendChild(kind);
        lines.appendChild(of);
        lines.appendChild(rar);
        lines.appendChild(formula);
        lines.appendChild(val);
      } else {
        const p = it.data;
        const tier = potionRarityTier(p);
        const rarityCls = rarityCssClass(tier);

        const kind = document.createElement("div");
        kind.className = "bagKind";
        kind.textContent = "Concoction";

        const of = document.createElement("div");
        of.className = "bagOf";
        of.textContent = `of ${potionDisplayName(p)}`;

        const rar = document.createElement("div");
        rar.className = "bagRarity " + rarityCls;
        rar.textContent = capTier(tier);

        const formula = document.createElement("div");
        formula.className = "bagFormula";
        formula.textContent = potionFormulaLine(p);

        const val = document.createElement("div");
        val.className = "bagValue";
        val.innerHTML = valueLineForPotion(p);

        lines.appendChild(kind);
        lines.appendChild(of);
        lines.appendChild(rar);
        lines.appendChild(formula);
        lines.appendChild(val);
      }

      const qtyRow = document.createElement("div");
      qtyRow.className = "qtyRow";

      const minus = document.createElement("button");
      minus.type = "button";
      minus.className = "qtyBtn";
      minus.textContent = "âˆ’";

      const count = document.createElement("div");
      count.className = "count";

      const plus = document.createElement("button");
      plus.type = "button";
      plus.className = "qtyBtn";
      plus.textContent = "+";

      if (it.type === "conc") {
        const c = it.data;
        const qty = Number(c.qty) || 0;
        count.textContent = String(qty);

        minus.addEventListener("click", () => {
          c.qty = Math.max(0, qty - 1);
          if (c.qty === 0) delete CONCS[c.key];
          saveLocal();
          renderBag();
          renderConcentratesIndex();
          fillMixChoices();
        });
        plus.addEventListener("click", () => {
          c.qty = qty + 1;
          saveLocal();
          renderBag();
          renderConcentratesIndex();
          fillMixChoices();
        });
      } else {
        const p = it.data;
        const qty = Number(p.qty) || 0;
        count.textContent = String(qty);

        minus.addEventListener("click", () => {
          p.qty = Math.max(0, qty - 1);
          saveLocal();
          renderBag();
          fillMixChoices();
        });
        plus.addEventListener("click", () => {
          p.qty = qty + 1;
          saveLocal();
          renderBag();
          fillMixChoices();
        });
      }

      qtyRow.appendChild(minus);
      qtyRow.appendChild(count);
      qtyRow.appendChild(plus);

      top.appendChild(icon);
      card.appendChild(top);
      card.appendChild(lines);
      card.appendChild(qtyRow);
      grid.appendChild(card);
    });
  }

  function valueLineForConcentrate(c) {
    const v = c.value || { gp:0, sp:0, cp:0 };
    return formatCoins(v);
  }

  // Mixing
  function potionOptionLabel(p) {
    // Distinguish by formula and effect list
    const name = potionDisplayName(p);
    const formula = potionFormulaLine(p);
    return `Potion of ${name} (${formula})`;
  }

  function concentrateOptionLabel(c) {
    return `Concentrate of ${c.effect} (2d4+${Number(c.boost)||0})`;
  }

  function mixChoiceItems() {
    const list = [];

    // Potions with qty > 0
    for (const p of (POTIONS || [])) {
      const qty = Number(p.qty)||0;
      if (qty > 0) list.push({ kind: "potion", key: p.key, ref: p });
    }

    // Concentrates with qty > 0
    for (const k of Object.keys(CONCS || {})) {
      const c = CONCS[k];
      const qty = Number(c?.qty)||0;
      if (c && qty > 0) list.push({ kind: "conc", key: c.key, ref: c });
    }

    list.sort((a,b) => {
      const al = a.kind === "potion" ? potionOptionLabel(a.ref) : concentrateOptionLabel(a.ref);
      const bl = b.kind === "potion" ? potionOptionLabel(b.ref) : concentrateOptionLabel(b.ref);
      return al.localeCompare(bl);
    });

    return list;
  }

  function fillMixChoices() {
    const a = el("mixItemA");
    const b = el("mixItemB");
    const items = mixChoiceItems();

    if (items.length < 2) {
      a.innerHTML = `<option value="">(Need at least 2 items)</option>`;
      b.innerHTML = `<option value="">(Need at least 2 items)</option>`;
      el("mixItemADetail").innerHTML = `<div class="muted">Add potions or concentrates first.</div>`;
      el("mixItemBDetail").innerHTML = `<div class="muted">Add potions or concentrates first.</div>`;
      el("mixDcLine").textContent = "DC: â€”";
      return;
    }

    const opts = items.map(it => {
      const label = it.kind === "potion" ? potionOptionLabel(it.ref) : concentrateOptionLabel(it.ref);
      return `<option value="${escapeHtml(it.kind + "::" + it.key)}">${escapeHtml(label)}</option>`;
    }).join("");

    const prevA = a.value;
    const prevB = b.value;

    a.innerHTML = opts;
    b.innerHTML = opts;

    const values = items.map(it => it.kind + "::" + it.key);
    a.value = values.includes(prevA) ? prevA : values[0];

    const bCandidate = values.includes(prevB) ? prevB : values.find(v => v !== a.value);
    b.value = (bCandidate && bCandidate !== a.value) ? bCandidate : (values.find(v => v !== a.value) || values[0]);

    enforceDistinctMixItems();
    renderMixDetails();
    updateMixDcLine();
  }

  function enforceDistinctMixItems() {
    const a = el("mixItemA");
    const b = el("mixItemB");
    const values = Array.from(a.options).map(o => o.value).filter(Boolean);
    if (a.value && b.value && a.value === b.value) {
      const next = values.find(v => v !== a.value);
      if (next) b.value = next;
    }
  }

  function parseMixValue(v) {
    const s = String(v || "");
    const [kind, ...rest] = s.split("::");
    const key = rest.join("::");
    if (kind !== "potion" && kind !== "conc") return null;
    if (!key) return null;
    return { kind, key };
  }

  function getMixRef(selValue) {
    const parsed = parseMixValue(selValue);
    if (!parsed) return null;
    if (parsed.kind === "potion") {
      const p = (POTIONS || []).find(x => x.key === parsed.key);
      if (!p || (Number(p.qty)||0) <= 0) return null;
      return { kind: "potion", ref: p };
    }
    const c = CONCS?.[parsed.key];
    if (!c || (Number(c.qty)||0) <= 0) return null;
    return { kind: "conc", ref: c };
  }

  function renderMixDetails() {
    const aRef = getMixRef(el("mixItemA").value);
    const bRef = getMixRef(el("mixItemB").value);

    el("mixItemADetail").innerHTML = mixDetailHtml(aRef);
    el("mixItemBDetail").innerHTML = mixDetailHtml(bRef);
  }

  function mixDetailHtml(it) {
    if (!it) return `<div class="muted">â€”</div>`;
    if (it.kind === "conc") {
      const c = it.ref;
      return `
        <div style="font-weight:1000;">Concentrate of ${escapeHtml(c.effect)}</div>
        <div class="muted" style="margin-top:6px;">${escapeHtml(capTier(c.tier))} | 2d4+${Number(c.boost)||0} | Value ${formatCoins(c.value)}</div>
      `;
    }
    const p = it.ref;
    const tier = potionRarityTier(p);
    return `
      <div style="font-weight:1000;">Potion of ${escapeHtml(potionDisplayName(p))}</div>
      <div class="muted" style="margin-top:6px;">${escapeHtml(capTier(tier))} | ${escapeHtml(potionFormulaLine(p))} | Value ${formatCoins(p.value)}</div>
      <div class="muted" style="margin-top:6px;">${p.isMixed ? "Mixed potion (cannot be mixed again)." : "Base potion (can be mixed)."} </div>
    `;
  }

  function highestTierAmongItems(items) {
    let tier = "common";
    for (const it of items) {
      if (!it) continue;
      if (it.kind === "conc") tier = bestTier(tier, String(it.ref.tier || "common"));
      else tier = bestTier(tier, potionRarityTier(it.ref));
    }
    return tier;
  }

  function updateMixDcLine() {
    const aRef = getMixRef(el("mixItemA").value);
    const bRef = getMixRef(el("mixItemB").value);

    if (!aRef || !bRef) {
      el("mixDcLine").textContent = "DC: â€”";
      return;
    }

    const tier = highestTierAmongItems([aRef, bRef]);
    const dc = rarityDcBase(tier) + 2; // potion+potion +2, potion+conc +2 (your rule)
    el("mixDcLine").textContent = `DC: ${dc}`;
  }

  function mixAction() {
    const aRef = getMixRef(el("mixItemA").value);
    const bRef = getMixRef(el("mixItemB").value);

    if (!aRef || !bRef) {
      toast("Choose two items.", "bad");
      return;
    }

    // Determine allowed combos
    const isPotionA = aRef.kind === "potion";
    const isPotionB = bRef.kind === "potion";
    const isConcA = aRef.kind === "conc";
    const isConcB = bRef.kind === "conc";

    if (isConcA && isConcB) {
      toast("Mixing two concentrates is not supported.", "bad");
      el("mixOut").innerHTML = `<div style="color:var(--warn); font-weight:950;">Choose at least one potion.</div>`;
      return;
    }

    // Identify potion side and concentrate side (if any)
    const potion = isPotionA ? aRef.ref : (isPotionB ? bRef.ref : null);
    const otherPotion = (isPotionA && isPotionB) ? bRef.ref : (isPotionB && isPotionA ? aRef.ref : null);
    const conc = isConcA ? aRef.ref : (isConcB ? bRef.ref : null);

    // Restriction: cannot mix potions that have already been mixed (no chaining)
    if (potion && potion.isMixed) {
      toast("Mixed potions cannot be mixed again.", "bad");
      el("mixOut").innerHTML = `<div style="color:var(--warn); font-weight:950;">Mixed potions cannot be mixed again.</div>`;
      return;
    }
    if (otherPotion && otherPotion.isMixed) {
      toast("Mixed potions cannot be mixed again.", "bad");
      el("mixOut").innerHTML = `<div style="color:var(--warn); font-weight:950;">Mixed potions cannot be mixed again.</div>`;
      return;
    }

    // Build resulting effects
    const effects = [];
    const pushOrUpgrade = (e) => {
      const name = String(e.name || "").trim();
      if (!name) return;
      const tier = String(e.tier || "common");
      const bonus = Number(e.bonus) || 0;

      const existing = effects.find(x => x.name.toLowerCase() === name.toLowerCase());
      if (!existing) {
        effects.push({ name, tier, base: "2d4", bonus });
        return;
      }
      // If duplicate effect, keep the higher tier, and keep the higher bonus
      existing.tier = bestTier(existing.tier, tier);
      existing.bonus = Math.max(Number(existing.bonus)||0, bonus);
    };

    if (potion) (potion.effects || []).forEach(pushOrUpgrade);
    if (otherPotion) (otherPotion.effects || []).forEach(pushOrUpgrade);

    if (conc) {
      // Applying a concentrate adds its effect with its boost as the bonus
      pushOrUpgrade({ name: conc.effect, tier: conc.tier, bonus: Number(conc.boost)||0 });
    }

    // Cap final potion at 3 effects
    if (effects.length > 3) {
      toast("Final potion is capped at 3 effects.", "bad");
      el("mixOut").innerHTML = `<div style="color:var(--warn); font-weight:950;">Final potion capped at 3 effects.</div><div class="muted" style="margin-top:6px;">Choose different items.</div>`;
      return;
    }

    // DC
    const tier = highestTierAmongItems([aRef, bRef]);
    const dc = rarityDcBase(tier) + 2;

    // Prompt: Success or Failure, consume either way
    const nodes = [];
    const note = document.createElement("div");
    note.className = "muted";
    note.style.lineHeight = "1.25";
    note.innerHTML = `DC: <b>${dc}</b>. On failure, items are still consumed.`;
    nodes.push(note);

    const preview = document.createElement("div");
    preview.className = "resultBox";
    preview.style.marginTop = "6px";
    preview.innerHTML = `
      <div>
        <div style="font-weight:1000;">Result: Potion of ${escapeHtml(effects.map(e => e.name).join(" + "))}</div>
        <div class="muted" style="margin-top:6px;">${escapeHtml(effects.map(e => `2d4+${Number(e.bonus)||0}`).join(" | "))}</div>
      </div>
    `;
    nodes.push(preview);

    const btnSuccess = document.createElement("button");
    btnSuccess.className = "btn-primary";
    btnSuccess.type = "button";
    btnSuccess.textContent = "Success, create mixed potion";
    btnSuccess.addEventListener("click", () => {
      // Consume
      if (potion) potion.qty = Math.max(0, (Number(potion.qty)||0) - 1);
      if (otherPotion) otherPotion.qty = Math.max(0, (Number(otherPotion.qty)||0) - 1);
      if (conc) {
        conc.qty = Math.max(0, (Number(conc.qty)||0) - 1);
        if (conc.qty === 0) delete CONCS[conc.key];
      }

      const outTier = tier; // rarity of the mixed potion for display and DC purposes
      const val = potionValue(effects);
      const key = makePotionKey({ kind: "concoction", effects, isMixed: true });

      const existing = POTIONS.find(p => p.key === key);
      if (existing) {
        existing.qty = (Number(existing.qty)||0) + 1;
      } else {
        POTIONS.push({
          key,
          kind: "concoction",
          isMixed: true,
          effects,
          tier: outTier,
          value: val,
          qty: 1,
          at: Date.now()
        });
      }

      saveLocal();
      renderBag();
      renderConcentratesIndex();
      fillMixChoices();
      updateMixDcLine();

      playSfx("sfxSuccess");
      el("mixOut").innerHTML = `<div style="color:rgba(120,255,170,0.95); font-weight:1000;">Mixed potion recorded.</div><div class="muted" style="margin-top:6px;">Open Bag to adjust counts.</div>`;
      toast("Mixed potion recorded.", "good");
      modalHide();
    });

    const btnFail = document.createElement("button");
    btnFail.type = "button";
    btnFail.textContent = "Failure (consume, no potion)";
    btnFail.addEventListener("click", () => {
      if (potion) potion.qty = Math.max(0, (Number(potion.qty)||0) - 1);
      if (otherPotion) otherPotion.qty = Math.max(0, (Number(otherPotion.qty)||0) - 1);
      if (conc) {
        conc.qty = Math.max(0, (Number(conc.qty)||0) - 1);
        if (conc.qty === 0) delete CONCS[conc.key];
      }

      saveLocal();
      renderBag();
      renderConcentratesIndex();
      fillMixChoices();
      updateMixDcLine();

      el("mixOut").innerHTML = `<div style="color:var(--warn); font-weight:950;">Failed mix.</div><div class="muted" style="margin-top:6px;">Items consumed.</div>`;
      toast("Failed mix recorded.", "bad");
      modalHide();
    });

    const btnCancel = document.createElement("button");
    btnCancel.type = "button";
    btnCancel.textContent = "Cancel";
    btnCancel.addEventListener("click", modalHide);

    modalShow({
      title: "Record Mixing Result",
      bodyNodes: nodes,
      buttons: [btnCancel, btnFail, btnSuccess]
    });
  }

  function exportNotes() {
    el("saveBox").value = JSON.stringify({
      reveals: REVEALS,
      index: INDEX,
      recipes: RECIPES,
      potions: POTIONS,
      concentrates: CONCS
    }, null, 2);
    toast("Copied to the box.", "good");
  }

  function importNotes() {
    try {
      const parsed = JSON.parse(el("saveBox").value);
      if (!parsed || typeof parsed !== "object") throw new Error("bad");

      REVEALS = (parsed.reveals && typeof parsed.reveals === "object") ? parsed.reveals : {};
      const idx = (parsed.index && typeof parsed.index === "object") ? parsed.index : {};
      const clean = {};
      for (const [k,v] of Object.entries(idx)) {
        const n = Number(v);
        if (Number.isFinite(n) && n >= 0) clean[String(k)] = Math.floor(n);
      }
      INDEX = clean;

      RECIPES = Array.isArray(parsed.recipes) ? parsed.recipes : [];
      POTIONS = Array.isArray(parsed.potions) ? parsed.potions : [];
      CONCS = (parsed.concentrates && typeof parsed.concentrates === "object") ? parsed.concentrates : {};

      saveLocal();
      renderIndex();
      renderConcentratesIndex();
      fillBrewChoices();
      enforceDistinctMixing();
      renderBrewDiscovered();
      fillConcentrateCraftChoices();
      updateBrewDcLine();
      renderBag();
      fillMixChoices();
      updateMixDcLine();

      toast("Restored.", "good");
    } catch {
      toast("Those notes do not make sense.", "bad");
    }
  }

  function burnAll() {
    if (!confirm("Burn all notes on this device?")) return;
    REVEALS = {};
    INDEX = {};
    RECIPES = [];
    POTIONS = [];
    CONCS = {};
    saveLocal();
    renderIndex();
    renderConcentratesIndex();
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateCraftChoices();
    updateBrewDcLine();
    renderBag();
    fillMixChoices();
    updateMixDcLine();
    showOnly("main");
    toast("Ashes and silence.", "bad");
  }

  // Wiring
  el("refreshBtn").addEventListener("click", fetchAllIngredients);

  el("openBookBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    showOnly("book");
    showBookSpread("index");
    renderIndex();
    renderConcentratesIndex();
  });

  el("openBrewBtn").addEventListener("click", () => {
    showOnly("brew");
    fillBrewChoices();
    enforceDistinctMixing();
    fillConcentrateCraftChoices();
    updateBrewDcLine();
  });

  el("openMixBtn").addEventListener("click", () => {
    showOnly("mix");
    fillMixChoices();
    renderMixDetails();
    updateMixDcLine();
  });

  el("openBagBtn").addEventListener("click", () => {
    showOnly("bag");
    renderBag();
  });

  el("closeBookBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    showOnly("main");
  });

  el("backToIndexTopBtn").addEventListener("click", () => {
    playSfx("sfxPage");
    currentIngredientId = null;
    showBookSpread("index");
    renderIndex();
    renderConcentratesIndex();
  });

  el("backFromBrewBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("backFromMixBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("backFromBagBtn").addEventListener("click", () => {
    showOnly("main");
  });

  el("recordBtn").addEventListener("click", () => {
    recordIngredientFromMark(el("markInput").value);
  });

  el("markInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") recordIngredientFromMark(el("markInput").value);
  });

  el("themeToggleBtn").addEventListener("click", () => {
    setTheme(theme === "wilderness" ? "town" : "wilderness");
  });

  el("useThird").addEventListener("change", () => {
    const on = el("useThird").checked;
    el("thirdSlot").classList.toggle("hidden", !on);
    fillBrewChoices();
    enforceDistinctMixing();
    updateBrewDcLine();
  });

  el("mixA").addEventListener("change", () => { enforceDistinctMixing(); updateBrewDcLine(); });
  el("mixB").addEventListener("change", () => { enforceDistinctMixing(); updateBrewDcLine(); });
  el("mixC").addEventListener("change", () => { enforceDistinctMixing(); updateBrewDcLine(); });
  el("brewBtn").addEventListener("click", brew);

  el("concFromIng").addEventListener("change", fillConcentrateEffectsForSelected);
  el("concEffect").addEventListener("change", fillConcentrateEffectsForSelected);
  el("makeConcBtn").addEventListener("click", makeConcentrate);

  el("mixItemA").addEventListener("change", () => { enforceDistinctMixItems(); renderMixDetails(); updateMixDcLine(); });
  el("mixItemB").addEventListener("change", () => { enforceDistinctMixItems(); renderMixDetails(); updateMixDcLine(); });
  el("mixBtn").addEventListener("click", mixAction);

  el("exportBtn").addEventListener("click", exportNotes);
  el("importBtn").addEventListener("click", importNotes);
  el("wipeBtn").addEventListener("click", burnAll);

  // Init
  setTheme("wilderness");
  showOnly("main");
  fetchAllIngredients();

  /*
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    POTION EFFECT CONFIG (Edit here)
    - Keys are lowercase effect names.
    - numeric: true/false (for future use, currently not shown to players)
    - value is by rarity tier and supports gp/sp/cp.

    Example:

    "restore health": {
      numeric: true,
      value: {
        common:    { gp: 0, sp: 5,  cp: 0 },
        uncommon:  { gp: 1, sp: 0,  cp: 0 },
        rare:      { gp: 5, sp: 0,  cp: 0 },
        legendary: { gp: 25, sp: 0, cp: 0 }
      }
    }
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  */
  const POTION_EFFECTS = {
    "restore health": {
      numeric: true,
      value: {
        common:    { gp: 0,  sp: 5,  cp: 0 },
        uncommon:  { gp: 1,  sp: 0,  cp: 0 },
        rare:      { gp: 5,  sp: 0,  cp: 0 },
        legendary: { gp: 25, sp: 0,  cp: 0 }
      }
    },
    "resist shock": {
      numeric: false,
      value: {
        common:    { gp: 0, sp: 4,  cp: 0 },
        uncommon:  { gp: 1, sp: 0,  cp: 0 },
        rare:      { gp: 4, sp: 0,  cp: 0 },
        legendary: { gp: 20, sp: 0, cp: 0 }
      }
    }
  };
</script>
</body>
</html>
